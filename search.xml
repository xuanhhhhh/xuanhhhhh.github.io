<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>docker</title>
    <url>/2023/07/30/Docker/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><span id="more"></span>

<h1 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h1><p>Docker是一个开源平台，通过将应用程序隔离到轻量级、可移植的容器中，自动化应用程序的部署、扩展和管理。容器是独立的可执行单元，封装了运行应用程序所需的所有必要依赖项、库和配置文件，可以在各种环境中稳定地运行。</p>
<p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows操作系统的机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口</p>
<p>隔离：docker核心思想！</p>
<p>docker的思想来源于集装箱</p>
<p>docker  十分轻巧！！！</p>
<p>基于Go语言开发的，开源项目！</p>
<p>虚拟机也是属于虚拟化技术，Docker 容器技术，也是一种 虚拟化技术!</p>
<ul>
<li>Vm:     linux centos原生镜像 (一个电脑!) 隔离，需要开启多个虚拟机!                        几个G                      几分钟</li>
<li>docker:隔离,境像(最核心的环境 4m + jdk + mysql)十分的小巧， 运行像就可以了! 小巧! 几个M KB秒级启动!</li>
</ul>
<p><strong>虚拟机技术缺点:</strong><br>1、资源占用十分多<br>2、冗余步骤多<br>3、启动很慢 !<br><strong>容器化技术</strong><br><strong><code>容器化技术不是模拟的一个完整的提作系统</code></strong></p>
<p><strong>比较Docker 和 虚拟机技术的不同:</strong></p>
<ul>
<li>传统虚拟机，虚拟出一条硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件</li>
<li>容器内的应用直接运行在 宿主机的内容，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便</li>
<li>每个容器间是互相隔离，每个容器内都有一个属于自己的文件系统，互不影响。</li>
</ul>
<p>官网: <a href="https://www.docker.com/">https://www.docker.com/</a></p>
<p>文档地址: <a href="https://docs.docker.com/">https://docs.docker.com/</a> (超级详细)</p>
<p>仓库地址: <a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<h2 id="容器和Docker"><a href="#容器和Docker" class="headerlink" title="容器和Docker"></a><strong>容器和Docker</strong></h2><p>Docker是一种简化创建、部署和管理容器的平台。它为开发人员和管理员提供了一组工具和API，用于管理容器化的应用程序。使用Docker，您可以将应用程序代码、库和依赖项构建和打包成一个容器映像，该映像可以在支持Docker的任何环境中分发和一致地运行。</p>
<h2 id="容器的必要性"><a href="#容器的必要性" class="headerlink" title="容器的必要性"></a><strong>容器的必要性</strong></h2><p><strong>应用更快速的交付和部署</strong><br>传统:一堆帮助文档，安装程序<br>Docker: 打包镜像发布测试，一键运行<br><strong>更便捷的升级和扩缩容</strong><br>使用了Docker之后，我们部署应用就和搭积木一样!<br>项目打包为一个镜像，扩展 服务器A ! 服务器B</p>
<p><strong>更简单的系统运维</strong><br>在容器化之后，我们的开发，测试环境都是高度一致的。</p>
<p><strong>更高效的计算资源利用</strong></p>
<p>Docker 是 内核级别的虚拟化，可以在一个物理机上可以运行很多的客器实例!服务器的性能可以被压榨到极致.</p>
<h1 id="Docker-的基本组成"><a href="#Docker-的基本组成" class="headerlink" title="Docker 的基本组成"></a>Docker 的基本组成</h1><p><img src="https://img-blog.csdnimg.cn/img_convert/be7adea748abd28eee7d4ec814b7a316.jpeg" alt="img"></p>
<p><strong>镜像(image )</strong> :<br>docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，tomcat镜像&#x3D;&#x3D;&#x3D;&gt; run &#x3D;&#x3D;&gt; tomcat01 容器(提供服务器)通过这个镜像可以创建多个容器( 最终服务运行或者项目运行就是在容器中的)。<br><strong>容器(container) :</strong><br>Docker利用容器技术，独立运行一个或者一个组应用，通过镜像来创建的</p>
<p>启动，停止，删除，基本命令!</p>
<p>目前就可以把这个容器理解为就是一个简易的linux系统</p>
<p><strong>仓库(repository) :</strong><br>仓库就是存放镜像的地方!<br>仓库分为公有仓库和私有仓库!<br>Docker Hub(默认是国外的)   阿里云….都有容器服务器(配置镜像加速 !)</p>
<h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><p><strong>环境准备</strong></p>
<ol>
<li>Linux基础</li>
<li>CentOS 7或以上版本</li>
<li>使用Xshell连接远程服务器进行操作</li>
</ol>
<p><strong>环境查看</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#系统内核是3.10以上</span><br><span class="line">用uname -r查看</span><br></pre></td></tr></table></figure>

<p>系统版本</p>
<p>[root@163 ~]# cat &#x2F;etc&#x2F;os-release<br>NAME&#x3D;”CentOS Linux”<br>VERSION&#x3D;”8”<br>ID&#x3D;”centos”<br>ID_LIKE&#x3D;”rhel fedora”<br>VERSION_ID&#x3D;”8”<br>PLATFORM_ID&#x3D;”platform:el8”<br>PRETTY_NAME&#x3D;”CentOS Linux 8”<br>ANSI_COLOR&#x3D;”0;31”<br>CPE_NAME&#x3D;”cpe:&#x2F;o:centos:centos:8”<br>HOME_URL&#x3D;”<a href="https://centos.org/">https://centos.org/</a>“<br>BUG_REPORT_URL&#x3D;”<a href="https://bugs.centos.org/">https://bugs.centos.org/</a>“<br>CENTOS_MANTISBT_PROJECT&#x3D;”CentOS-8”<br>CENTOS_MANTISBT_PROJECT_VERSION&#x3D;”8”</p>
<p><strong>安装</strong></p>
<ol>
<li><p><strong>卸载旧版本</strong></p>
<pre><code>yum remove docker \
            docker-client \
            docker-client-latest \
            docker-common \
            docker-latest \
            docker-latest-logrotate \
            docker-logrotate \
            docker-engine
</code></pre>
</li>
<li><p><strong>需要的安装包</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置镜像的仓库</strong></p>
<p>yum-config-manager –add-repo <a href="https://download.docker.com/linux/centos/docker-ce.repo">https://download.docker.com/linux/centos/docker-ce.repo</a> &#x2F;&#x2F;默认是国外的，非常慢</p>
<p>yum-config-manager –add-repo <a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a> &#x2F;&#x2F;阿里云镜像</p>
<p>##更新yum软件包索引  yum makecache fast</p>
</li>
<li><p><strong>安装docker相关的</strong></p>
<p>yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</p>
<p>ce 社区  ee企业</p>
</li>
<li><p><strong>启动Docker</strong></p>
<p>systemctl start docker</p>
</li>
<li><p><strong>使用docker version查看是否安装成功</strong></p>
<p>[root@163 ~]# docker version<br>Client: Docker Engine - Community<br> Version:           24.0.5<br> API version:       1.43<br> Go version:        go1.20.6<br> Git commit:        ced0996<br> Built:             Fri Jul 21 20:36:32 2023<br> OS&#x2F;Arch:           linux&#x2F;amd64<br> Context:           default</p>
<p>Server: Docker Engine - Community<br> Engine:<br>  Version:          24.0.5<br>  API version:      1.43 (minimum version 1.12)<br>  Go version:       go1.20.6<br>  Git commit:       a61e2b4<br>  Built:            Fri Jul 21 20:35:32 2023<br>  OS&#x2F;Arch:          linux&#x2F;amd64<br>  Experimental:     false<br> containerd:<br>  Version:          1.6.21<br>  GitCommit:        3dce8eb055cbb6872793272b4f20ed16117344f8<br> runc:<br>  Version:          1.1.7<br>  GitCommit:        v1.1.7-0-g860f061<br> docker-init:<br>  Version:          0.19.0<br>  GitCommit:        de40ad0</p>
</li>
<li><p><strong>sudo docker run hello-world</strong></p>
</li>
<li><p><strong>查看一下下载的这个 hello-world镜像</strong></p>
<p>docker images</p>
</li>
</ol>
<p><strong>了解</strong></p>
<p>docker卸载</p>
<ol>
<li>卸载依赖</li>
</ol>
<p>  <code>yum remove docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras</code></p>
<ol start="2">
<li><p>删除资源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo rm -rf /var/lib/docker   //docker默认工作路径</span><br><span class="line">sudo rm -rf /var/lib/containerd</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h1><ol>
<li>登录阿里云找到容器镜像服务</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/14c9919761fe4833b59b16f1944f39fc.png" alt="请添加图片描述"></p>
<ol start="2">
<li><p>找到镜像加速器</p>
</li>
<li><p>配置使用</p>
</li>
</ol>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker </span><br><span class="line"></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27; </span><br><span class="line">&#123; </span><br><span class="line"> &quot;registry-mirrors&quot;: [&quot;https://kzsz87k0.mirror.aliyuncs.com&quot;] </span><br><span class="line">&#125; </span><br><span class="line">EOF </span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload </span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h1 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h1><p><strong>Docker是什么工作的?</strong><br>Docker 是一个Client-Server 结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问<br>DockerServer 接收到 Docker-Client 的指令，就会执行这个命令</p>
<p><strong>Docker为什么比VM快</strong><br>1、Docker有着比虚拟机更少的抽象层<br>2、docker 利用的是宿主机的内核，vm 需要是 Guest OS。<br><img src="https://img-blog.csdnimg.cn/9b835a379a044e06869c036190e649aa.png" alt="在这里插入图片描述"><br>所以说，新建一个容器的时候，docker不需要想虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载 Guest OS，分钟级别的，而docker 是利用 宿主机的操作系统吗，省略了这个复杂的过程，秒级!</p>
<p><img src="https://img-blog.csdnimg.cn/2725bac4251243ce9e42eff23e2e44ac.png" alt="在这里插入图片描述"></p>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker相关部署</title>
    <url>/2023/07/31/Docker2/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><span id="more"></span>

<h1 id="Docker安装Nginx"><a href="#Docker安装Nginx" class="headerlink" title="Docker安装Nginx"></a>Docker安装Nginx</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.搜索镜像 docker search nginx</span><br><span class="line">2.下载镜像 docker pull nginx</span><br><span class="line">3.运行测试</span><br><span class="line">[root@163 ~]# docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx         latest    605c77e624dd   19 months ago   141MB</span><br><span class="line">centos        latest    5d0da3dc9764   22 months ago   231MB</span><br><span class="line">-d 后台运行（停止了容器后，容器还可以查到）</span><br><span class="line">--name 给容器命名</span><br><span class="line">-p 宿主机:容器内部端口</span><br><span class="line">[root@163 ~]# docker run -d --name nginx01 -p 3344:80 nginx</span><br><span class="line">bb07f6e55670b129a14434aae3a9422cf3f7091f2d3079a5f96005613a909993</span><br><span class="line">[root@163 ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                                   NAMES</span><br><span class="line">bb07f6e55670   nginx     &quot;/docker-entrypoint.…&quot;   9 seconds ago   Up 8 seconds   0.0.0.0:3344-&gt;80/tcp, :::3344-&gt;80/tcp   nginx01</span><br><span class="line">[root@163 ~]# curl localhost:3344</span><br><span class="line"></span><br><span class="line">4.进入容器</span><br><span class="line">[root@163 ~]# docker exec -it nginx01 /bin/bash</span><br><span class="line">root@bb07f6e55670:/# whereis nginx</span><br><span class="line">nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx</span><br><span class="line">root@bb07f6e55670:/# cd /etc/nginx</span><br><span class="line">root@bb07f6e55670:/etc/nginx# ls</span><br><span class="line">conf.d		mime.types  nginx.conf	 uwsgi_params</span><br><span class="line">fastcgi_params	modules     scgi_params</span><br><span class="line">root@bb07f6e55670:/etc/nginx# </span><br></pre></td></tr></table></figure>

<h1 id="Docker安装Tomcat"><a href="#Docker安装Tomcat" class="headerlink" title="Docker安装Tomcat"></a>Docker安装Tomcat</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#官方使用</span><br><span class="line">docker run -it --rm tomcat:9.0</span><br><span class="line">docker run -it --rm一般用于测试，用完立即删除</span><br><span class="line"></span><br><span class="line">#下载再使用</span><br><span class="line">docker pull tomcat:9.0</span><br><span class="line"></span><br><span class="line">#启动运行</span><br><span class="line">docker run -d -p 3355:8080 --name tomcat01 tomcat</span><br><span class="line">#测试访问没有问题</span><br><span class="line"></span><br><span class="line">#进入容器</span><br><span class="line">[root@163 ~]# docker exec -it tomcat01 /bin/bash</span><br><span class="line">#发现问题，1.1inux命今少了，2.没有webapps 阿里云镜像的原因。默认是最小的镜像，所有不必要的都被剔除掉。保证最小可运行的环境</span><br></pre></td></tr></table></figure>

<h1 id="部署es-kibana"><a href="#部署es-kibana" class="headerlink" title="部署es+kibana"></a>部署es+kibana</h1><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">--net somenetwork  网络配置</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动</span></span><br><span class="line">docker run -d --name elasticsearch (--net somenetwork) -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:8.8.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动了 1inux就卡住了</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">es 暴露的端口很多!</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">es 十分的耗内存</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">es 的数据一般霉要放置到安全目录!挂载</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker stats 查看 cpu的状态</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试一下es构建是否成功</span></span><br><span class="line">    curl localhost:9200</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">马上关闭，增加内存限制 修改配置文件 -e 环境配置修改</span></span><br><span class="line">docker run -d --name elasticsearch (--net somenetwork) -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:8.8.1</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Basics</title>
    <url>/2023/07/26/Basics/</url>
    <content><![CDATA[<h1 id="Windows基础"><a href="#Windows基础" class="headerlink" title="Windows基础"></a>Windows基础</h1><span id="more"></span>

<h3 id="一-使用-Linux-和-Windows-文件和目录时，可能需要调整区分大小写的处理方式。"><a href="#一-使用-Linux-和-Windows-文件和目录时，可能需要调整区分大小写的处理方式。" class="headerlink" title="一.使用 Linux 和 Windows 文件和目录时，可能需要调整区分大小写的处理方式。"></a>一.使用 Linux 和 Windows 文件和目录时，可能需要调整区分大小写的处理方式。</h3><p>标准行为：<br>Windovws 文件系统将文件和目录名称视为不区分大小写。 FOO.txt 和 foo.txt 将被视为等效文件。<br>Linux 文件系统将文件和目录名称视为区分大小写。 FOO.txt 和 foo.txt 将被视为不同文件。</p>
<p>Windows 文件系统支持使用属性标志按目录设置区分大小写。 虽然标准行为是不区分大小写，但你可以分配属性标志来使目录区分大小写，以便它能够识别可能仅大小写不同的 Linux 文件和文件夹。<br>在将驱动器装载到适用于 Linux 的 Windows 子系统 (WSL) 文件系统时，尤其如此。 在 WSL 文件系统中工作时，运行的是 Linux，因此默认情况下，文件和目录被视为区分大小写。</p>
<h3 id="二、Windows-常用快捷键"><a href="#二、Windows-常用快捷键" class="headerlink" title="二、Windows 常用快捷键"></a>二、Windows 常用快捷键</h3><blockquote>
<p>1 保存 Ctrl + S 必用<br>2 复制 Ctrl + C<br>3 粘贴 Ctrl + V<br>4 剪切 Ctrl + X<br>5 撤销 Ctrl + Z<br>6 全选 Ctrl + A<br>7 显示桌面 Win + D<br>8 打开资源管理器（此电脑） Win + E<br>9 关闭窗口、浏览器标签 Ctrl + W<br>10 切换打开的程序窗口 Alt + Tab<br>11 新建文件夹 Ctrl + Shift + N<br>12 刷新 Ctrl + R<br>13【浏览器快捷键】恢复 Chrome 中刚被关掉的网页Ctrl + Shift + T<br>14【浏览器快捷键】地址栏搜索Ctrl + E<br>15【浏览器快捷键】全选地址栏内容Ctrl + L<br>16【浏览器快捷键】标签之间切换 Ctrl + Tab<br>17 删除文件（进回收站） Ctrl + D<br>18 彻底删除文件 Shift + Delete<br>19 打开任务管理器 Ctrl + Shift + Esc<br>20 锁定计算机 Win + L<br>21 打印 Ctrl + P<br>22 投影 Win + P<br>23 打开 Windows 常用功能列表 Win + X</p>
</blockquote>
<h3 id="三、Windows-运行命令"><a href="#三、Windows-运行命令" class="headerlink" title="三、Windows 运行命令"></a>三、Windows 运行命令</h3><table>
<thead>
<tr>
<th align="center">作用</th>
<th align="center">命令</th>
</tr>
</thead>
<tbody><tr>
<td align="center">打开运行窗口</td>
<td align="center">Win + R</td>
</tr>
<tr>
<td align="center">打开运行窗口</td>
<td align="center">Win + R</td>
</tr>
<tr>
<td align="center">打开控制面板</td>
<td align="center">control</td>
</tr>
<tr>
<td align="center">打开计算器</td>
<td align="center">calc</td>
</tr>
<tr>
<td align="center">打开记事本</td>
<td align="center">notepad</td>
</tr>
<tr>
<td align="center">打开任务管理器</td>
<td align="center">taskmgr</td>
</tr>
<tr>
<td align="center">打开系统配置</td>
<td align="center">msconfig</td>
</tr>
<tr>
<td align="center">打开注册表</td>
<td align="center">regedit</td>
</tr>
<tr>
<td align="center">打开卸载程序界面</td>
<td align="center">appwiz.cpl</td>
</tr>
<tr>
<td align="center">打开防火墙设置</td>
<td align="center">firewall.cpl</td>
</tr>
<tr>
<td align="center">打开系统服务</td>
<td align="center">services.msc</td>
</tr>
<tr>
<td align="center">打开网络连接</td>
<td align="center">ncpa.cpl</td>
</tr>
<tr>
<td align="center">打开系统属性</td>
<td align="center">sysdm.cpl</td>
</tr>
<tr>
<td align="center">快速启动任务栏软件</td>
<td align="center">Win + （1 ~ 9）</td>
</tr>
<tr>
<td align="center">用命令关机</td>
<td align="center">shutdown -s -t 0</td>
</tr>
<tr>
<td align="center">用命令重启</td>
<td align="center">shutdown -r -t 0</td>
</tr>
<tr>
<td align="center">炫酷下滑关机</td>
<td align="center">slideToShutDown(在桌面新建“关机.txt”，在文件里输入 SlideToShutDown，再把 文件名改为“关 机.bat”，双击这个文件，自己看看效果~~~~)</td>
</tr>
</tbody></table>
<h3 id="四、必装软件"><a href="#四、必装软件" class="headerlink" title="四、必装软件"></a>四、必装软件</h3><ol>
<li><p>Everything：免费，本地硬盘文件极速搜索工具 （必用）<br>官网下载： <a href="https://www.voidtools.com/zh-cn/">https://www.voidtools.com/zh-cn/</a></p>
</li>
<li><p>Wox：免费，效率神器 （必用）<br>百度搜索 Wox 下载或官网下载：<a href="https://github.com/Wox-launcher/Wox">https://github.com/Wox-launcher/Wox</a></p>
</li>
<li><p>程序员必用：Markdown 工具（Typora 版本：v0.9.86） （必用）</p>
</li>
</ol>
<p>  Markdown 教程：<a href="https://www.runoob.com/markdown/md-tutorial.html">https://www.runoob.com/markdown/md-tutorial.html</a></p>
<ol start="4">
<li>Notepad++ ：免费，功能强大的文本编辑器 （常用）</li>
</ol>
<p>  官网下载：<a href="https://notepad-plus.en.softonic.com/">https://notepad-plus.en.softonic.com/</a></p>
<ol start="5">
<li>VS Code：编程神器，可开发多种语言，多用于前端开发 （常用）</li>
</ol>
<p>  官网下载：<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p>
<ol start="6">
<li>FDM：免费，非常棒的下载工具</li>
</ol>
<p>​       官网下载：<a href="https://www.freedownloadmanager.org/zh/download.htm">https://www.freedownloadmanager.org/zh/download.htm</a></p>
<ol start="7">
<li>Chrome、Firefox：程序员用的浏览器，调试 Web 前端 （必用）</li>
</ol>
<p>​        百度搜索：Chrome 下载、Firefox 下载</p>
]]></content>
      <tags>
        <tag>Windows常用快捷键</tag>
        <tag>Windows运行命令</tag>
        <tag>必备软件</tag>
      </tags>
  </entry>
  <entry>
    <title>Java简介</title>
    <url>/2023/07/26/Java1/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><span id="more"></span>

<h2 id="什么是Java"><a href="#什么是Java" class="headerlink" title="什么是Java"></a>什么是Java</h2><p>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。</p>
<h2 id="诞生背景"><a href="#诞生背景" class="headerlink" title="诞生背景"></a>诞生背景</h2><p>任职于Sun公司(Stanford University Network斯坦福网络公司)的詹姆斯·高斯林和麦克·舍林丹等人于1990年代初开发Java语言的雏形，最初被命名为Oak，Oak的目标是作为家用电器等小型系统的编程语言，用于电视机、电话、闹钟、烤面包机等家用电器的控制和通信。由于这些智能化家电的市场需求没有预期的高，Sun公司放弃了该项计划。随着1990年代互联网的发展，Sun公司发现Oak在互联网上应用的前景，于是改造了Oak，于1995年5月以Java的名称正式发布。伴随着互联网的迅猛发展，Java逐渐成为重要的网络编程语言。</p>
<h2 id="语言特点与应用场景"><a href="#语言特点与应用场景" class="headerlink" title="语言特点与应用场景"></a>语言特点与应用场景</h2><p>Java语言具有简单性、面向对象、分布式、健壮性、安全性、跨平台性、可移植性、多线程与动态性等特点。Java语言可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统等 。Java 快速、安全、可靠。从笔记本电脑到数据中心，从游戏控制台到超级计算机，从手机到互联网，Java 无处不在！</p>
<h2 id="JVM、JRE和JDK的关系"><a href="#JVM、JRE和JDK的关系" class="headerlink" title="JVM、JRE和JDK的关系"></a>JVM、JRE和JDK的关系</h2><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><p>Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</p>
<h4 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h4><p>Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包</p>
<p>如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p>
<h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4><p>Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等</p>
<p>JVM&amp;JRE&amp;JDK关系图</p>
<p><img src="https://img-blog.csdnimg.cn/20210430091557268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmcxMzU2Mzc1ODEyOA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h1 id="Java是编译型还是解释型语言"><a href="#Java是编译型还是解释型语言" class="headerlink" title="Java是编译型还是解释型语言"></a>Java是编译型还是解释型语言</h1><h3 id="1-编译型语言和解释型语言"><a href="#1-编译型语言和解释型语言" class="headerlink" title="1.编译型语言和解释型语言"></a>1.编译型语言和解释型语言</h3><h5 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a>编译型语言</h5><p><strong>定义</strong>：在程序运行之前，通过编译器将源程序编译成机器码(可运行的二进制代码)，以后执行这个程序时，就不用再进行编译了。</p>
<p><strong>优点</strong>：编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高，可以脱离语言环境独立运行。</p>
<p><strong>缺点</strong>：编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。</p>
<p><strong>总结</strong>：执行速度快、效率高；依靠编译器、跨平台性差些。</p>
<p><strong>代表语言</strong>：C、C++、Pascal、Object-C以及Swift。</p>
<h6 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h6><p><strong>定义</strong>：解释型语言的源代码不是直接翻译成机器码，而是先翻译成中间代码，再由解释器对中间代码进行解释运行。在运行的时候才将源程序翻译成机器码，翻译一句，然后执行一句，直至结束。</p>
<p>优点：有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）。灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。</p>
<p><strong>缺点</strong>：每次运行的时候都要解释一遍，性能上不如编译型语言。</p>
<p><strong>总结</strong>：执行速度慢、效率低；依靠解释器、跨平台性好。</p>
<p><strong>代表语言</strong>：JavaScript、Python、Erlang、PHP、Perl、Ruby。</p>
<h5 id="混合型语言"><a href="#混合型语言" class="headerlink" title="混合型语言"></a>混合型语言</h5><p><strong>定义</strong>：既然编译型和解释型各有缺点就会有人想到把两种类型整合起来，取其精华去其糟粕，就出现了半编译，半解释型语言。</p>
<p>比如C#，C#在编译的时候不是直接编译成机器码而是中间码，.NET平台提供了中间语言运行库运行中间码，中间语言运行库类似于Java虚拟机。.NET在编译成IL代码后，保存在dll中，首次运行时由JIT在编译成机器码缓存在内存中，下次直接执行。严格来说混合型语言属于解释型语言，C#更接近编译型语言。</p>
<p><strong>Java即是编译型的，也是解释型语言，总的来说Java更接近解释型语言。</strong></p>
<p>可以说它是编译型的。因为所有的Java代码都是要编译的，.java不经过编译就什么用都没有。同时围绕JVM的效率问题，会涉及一些如JIT、AOT等优化技术，例如JIT技术，会将热点代码编译成机器码。而AOT技术，是在运行前，通过工具直接将字节码转换为机器码。</p>
<p>可以说它是解释型的。因为Java代码编译后不能直接运行，它是解释运行在JVM上的，所以它是解释运行的。</p>
<h3 id="2-动态类型语言和静态类型语言"><a href="#2-动态类型语言和静态类型语言" class="headerlink" title="2.动态类型语言和静态类型语言"></a>2.动态类型语言和静态类型语言</h3><h6 id="动态类型语言"><a href="#动态类型语言" class="headerlink" title="动态类型语言"></a>动态类型语言</h6><p>动态类型语言：在运行期间才去做数据类型检查的语言，说的是数据类型。动态类型语言的数据类型不是在编译阶段决定的，而是把类型绑定延后到了运行阶段。</p>
<p>代表语言：Python、Ruby、Erlang、JavaScript、Swift、PHP、Perl。</p>
<h6 id="静态类型语言"><a href="#静态类型语言" class="headerlink" title="静态类型语言"></a>静态类型语言</h6><p>静态类型语言的数据类型是在编译期间（或运行之前）确定的，编写代码的时候要明确确定变量的数据类型。</p>
<p>代表语言：C、C++、C#、Java、Object-C。</p>
<h3 id="3-动态语言和静态语言"><a href="#3-动态语言和静态语言" class="headerlink" title="3.动态语言和静态语言"></a>3.动态语言和静态语言</h3><h5 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h5><p>动态类型语言和动态语言是完全不同的两个概念。</p>
<p>动态语言：说的是运行时改变结构，说的是代码结构。在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。</p>
<p>代表语言：Object-C、C#、JavaScript、PHP、Python、Erlang。</p>
<h5 id="静态语言"><a href="#静态语言" class="headerlink" title="静态语言"></a>静态语言</h5><p>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker命令</title>
    <url>/2023/07/31/Docker%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Docker的常用命令"><a href="#Docker的常用命令" class="headerlink" title="Docker的常用命令"></a>Docker的常用命令</h1><span id="more"></span>

<h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><p>docker version      #显示docker的版本信息<br>docker info            #显示docker的系统信息，包括境像和容器的数量<br>docker 命令 –help# 帮助命令</p>
<p>帮助文档的地址：<a href="https://docs.docker.com/engine/reference/commandline">https://docs.docker.com/engine/reference/commandline</a></p>
<h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><p>docker images 查看所有本地的主机上的镜像<br>[root@xxx &#x2F;]# docker images<br>REPOSITORY			TAG	    	IMAGE ID		      CREATED	         	SIZE<br>he11o-world			Tatest		bf756fblae65		4 months ago		13.3kB<br><strong>解释</strong></p>
<p>REPOSITORY    镜像的仓库源<br>TAG		      	 镜像的标签<br>IMAGE ID		  镜像的id<br>CREATED		  镜像的创建时间<br>SIZE					镜像的大小</p>
<p><strong>可选项</strong></p>
<p>-a，–all						   列出所有镜像<br>-q，–quiet  				    只显示ID</p>
<h3 id="docker-search-搜索镜像"><a href="#docker-search-搜索镜像" class="headerlink" title="docker search 搜索镜像"></a>docker search 搜索镜像</h3><p>[root@xxx &#x2F;]# docker search mysql<br>NAME                            DESCRIPTION                                                    STARS     OFFICIAL   AUTOMATED<br>mysql                 MySQL is a widely used, open-source relation…    14338        [OK]<br>mariadb             MariaDB Server is a high performing open sou…   5474         [OK]       </p>
<p><strong>可选项，通过搜藏来过滤</strong></p>
<p>–filter&#x3D;STARS&#x3D;3000# 搜索出来的镜像就是STARS大于3000的</p>
<p>[root@xxx ~]# docker search mysql –filter&#x3D;STARS&#x3D;3000<br>NAME        					 DESCRIPTION                              			  STARS     OFFICIAL   AUTOMATED<br>mysql     MySQL is a widely used, open-source relation…   	14338     [OK]<br>mariadb   MariaDB Server is a high performing open sou…    5474      [OK]       </p>
<h3 id="拉取镜像docker-pull-镜像名-tag"><a href="#拉取镜像docker-pull-镜像名-tag" class="headerlink" title="拉取镜像docker pull 镜像名[:tag]"></a><strong>拉取镜像docker pull 镜像名[:tag]</strong></h3><p>[root@163 ~]# docker pull mysql<br>Using default tag: latest  #如果不写tag，默认最新版本<br>latest: Pulling from library&#x2F;mysql<br>72a69066d2fe: Pull complete 		#分层下载，docker  image的核心  联合文件系统<br>93619dbc5b36: Pull complete<br>99da31dd6142: Pull complete<br>626033c43d70: Pull complete<br>37d5d7efb64e: Pull complete<br>ac563158d721: Pull complete<br>d2ba16033dad: Pull complete<br>688ba7d5c01a: Pull complete<br>00e060b6d11d: Pull complete<br>1c04857f594f: Pull complete<br>4d7cfa90e6ea: Pull complete<br>e0431212d27d: Pull complete<br>Digest: sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709  #签名<br>Status: Downloaded newer image for mysql:latest<br>docker.io&#x2F;library&#x2F;mysql:latest	#真实地址</p>
<p><strong>docker pull mysql等价于docker pull docker.io&#x2F;library&#x2F;mysql:latest</strong></p>
<p><strong>docker pull mysql:5.7</strong></p>
<p>[root@163 ~]# docker pull mysql:5.7<br>5.7: Pulling from library&#x2F;mysql<br>72a69066d2fe: Already exists<br>93619dbc5b36: Already exists<br>99da31dd6142: Already exists<br>626033c43d70: Already exists<br>37d5d7efb64e: Already exists<br>ac563158d721: Already exists<br>d2ba16033dad: Already exists &#x2F;&#x2F;以上为重复部分<br>0ceb82207cd7: Pull complete<br>37f2405cae96: Pull complete<br>e2482e017e53: Pull complete<br>70deed891d42: Pull complete<br>Digest: sha256:f2ad209efe9c67104167fc609cca6973c8422939491c9345270175a300419f94<br>Status: Downloaded newer image for mysql:5.7<br>docker.io&#x2F;library&#x2F;mysql:5.7</p>
<h3 id="删除镜像docker-rmi"><a href="#删除镜像docker-rmi" class="headerlink" title="删除镜像docker rmi"></a>删除镜像docker rmi</h3><p>docker rmi -f   容器ID			 &#x2F;&#x2F;删除指定镜像</p>
<p>docker rmi -f   容器ID  容器ID  容器ID	&#x2F;&#x2F;删除多个镜像</p>
<p>docker rmi -f  $(docker images -aq)	  &#x2F;&#x2F;删除镜像</p>
<h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p><strong>说明:我们有了镜像才可以创建容器，linux，下载一个 centos 镜像来测试学习</strong><br>docker pull centos</p>
<h3 id="新建容器并启动"><a href="#新建容器并启动" class="headerlink" title="新建容器并启动"></a>新建容器并启动</h3><p>docker run [可选参数] image</p>
<p>#参数说明<br>–name&#x3D;”Name”		   容器名字 tomcat01 tomcat02，用来区分容器<br>-d									后台方式运行<br>-it									使用交互方式运行，进入容器查看内容</p>
<p>-p								   指定容器的端口-p  8080:8080</p>
<p>​       	 	-p ip:主机端口:容器端口<br>​				-p 主机端口:容器端口 (常用)<br>​				-p 容器端口<br>​				容器端口</p>
<p>-P								   随机指定端口</p>
<p>#测试，启动并进入容器</p>
<p>[root@xxx ~]# docker run -it centos &#x2F;bin&#x2F;bash</p>
<p>[root@c0eed8b69c30 &#x2F;]# ls   &#x2F;&#x2F;查看容器内的centos,基础版本，很多命令都不完善<br>bin  etc   lib	  lost+found  mnt  proc  run   srv  tmp  var	</p>
<p>dev  home  lib64  media       opt  root  sbin  sys  usr</p>
<p>exit		&#x2F;&#x2F;从容器中退回主机</p>
<h3 id="列出所有运行的容器"><a href="#列出所有运行的容器" class="headerlink" title="列出所有运行的容器"></a>列出所有运行的容器</h3><p>#docker ps 命令</p>
<p>​		列出当前正在运行的容器</p>
<p>-a 		&#x2F;&#x2F;列出当前正在运行的容器+带出历史运行过的容器<br>-n&#x3D;? 	&#x2F;&#x2F; 显示最近创建的容器</p>
<p>-q		&#x2F;&#x2F;只显示容器的编号</p>
<h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><p>exit 				   &#x2F;&#x2F;直接容器停止并退出  </p>
<p>Ctrl + P + Q 	&#x2F;&#x2F;容不停止退出</p>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>docker rm 容器id		&#x2F;&#x2F;删除指定的容器，不能除正在运行的容器，如果要强制刚除 rm -f<br>docker rm -f $(docker ps -aq)		&#x2F;&#x2F;删除所有的容器</p>
<p>docker ps -a -q|xargs docker rm 		&#x2F;&#x2F; 删除所有的容器</p>
<h3 id="启动和停止容器的操作"><a href="#启动和停止容器的操作" class="headerlink" title="启动和停止容器的操作"></a>启动和停止容器的操作</h3><p>docker start 容器id			启动容器<br>docker restart 容器id		重启容器<br>docker stop 容器id			停止当前正在运行的容器<br>docker kill 容器id			  强制停止当前容器</p>
<h2 id="常用其他命令"><a href="#常用其他命令" class="headerlink" title="常用其他命令"></a>常用其他命令</h2><p><strong>后台启动容器</strong></p>
<p>#命令 docker run -d 镜像名!</p>
<p>[root@xxx &#x2F;]# docker run -d centos</p>
<p>#问题docker ps，发现 centos 停止了</p>
<p>#常见的坑:docker 容器使用后台运行，就必须要有要一个前台进程，docker发现没有应用，就会自动停止</p>
<p>#nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了<br><strong>查看日志</strong><br>docker logs -f -t –tail 容器，没有日志</p>
<p>#自己编写一段shell脚本</p>
<p>[root@xxx &#x2F;]# docker run -d centos &#x2F;bin&#x2F;sh -c “while true;do echo hhhhhh;sleep 1;done”</p>
<p>[root@xxx &#x2F;]# docker ps</p>
<p>CONTAINER ID			IMAGE<br>dce7b86171bf			centos</p>
<p>#显示日志</p>
<p>-tf								&#x2F;&#x2F;显示日志</p>
<p>–tai1 number			&#x2F;&#x2F;要显示日志条数</p>
<p>[root@xxx &#x2F;]# docker logs -tf –tai1 10 dce7b86171bf</p>
<p><strong>查看容器中进程信息ps</strong></p>
<p>#命令docker top 容器id</p>
<p>UID                 PID                 PPID           		      C                   STIME            </p>
<p>root                1432624             1432594             0                   20:14             </p>
<p>root                1452486             1432624             0                   20:20               </p>
<p><strong>查看镜像的元数据</strong></p>
<p>#命令 docker inspect 容器id</p>
<p><strong>进入当前正在运行的容器</strong></p>
<p>方式一：docker exec -it 容器id &#x2F;bin&#x2F;bash		&#x2F;&#x2F;进入容器后开启一个新的终端，可以在里面操作</p>
<p>方式二：docker attach 容器id		 				 &#x2F;&#x2F;进入容器正在执行的终端，不会启动新的进程</p>
<p><strong>从容器内拷贝文件到主机上</strong></p>
<p>docker  cp 容器id:容器内路径  目的的主机路径</p>
<p>#查看当将主机目录下</p>
<p>[root@163 home]# ls<br>hhh.java  redis  www<br>[root@163 home]#  docker ps<br>CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES<br>69687a39e545   centos    “&#x2F;bin&#x2F;bash”   2 minutes ago   Up 2 minutes             vigilant_blackburn</p>
<p>#进入docker容器内部</p>
<p>[root@163 home]# docker attach 69687a39e545<br>[root@69687a39e545 &#x2F;]# cd &#x2F;home<br>[root@69687a39e545 home]# ls</p>
<p>#在容器内新建一个文件</p>
<p>[root@69687a39e545 home]# touch test.java<br>[root@69687a39e545 home]# exit<br>exit<br>[root@163 home]# docker ps<br>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES<br>[root@163 home]# docker ps -a<br>CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS                      PORTS     NAMES<br>69687a39e545   centos    “&#x2F;bin&#x2F;bash”   4 minutes ago   Exited (0) 31 seconds ago             vigilant_blackburn</p>
<p>#将文件拷贝出来到主机上</p>
<p>[root@163 home]# docker cp 69687a39e545:&#x2F;home&#x2F;test.java &#x2F;home<br>Successfully copied 1.54kB to &#x2F;home<br>[root@163 home]# ls<br>hhh.java  redis  test.java  www</p>
<p>#拷贝是一个手动过程，使用-v卷的技术可以实现</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="C:\Users\陈\AppData\Roaming\Typora\typora-user-images\image-20230730205339571.png" alt="image-20230730205339571"></p>
<table>
<thead>
<tr>
<th align="center">attach</th>
<th align="center">Attach to a running container</th>
<th align="center">当前 she11 下 attach 连接指定运行镜像</th>
</tr>
</thead>
<tbody><tr>
<td align="center">build</td>
<td align="center">Build an imagerfrom a Dockerfile</td>
<td align="center">通过 Dockerfile 定制镜像</td>
</tr>
<tr>
<td align="center">commit</td>
<td align="center">Create a new image from a container changes</td>
<td align="center">提交当前容器为新的镜像</td>
</tr>
<tr>
<td align="center">cp</td>
<td align="center">Copy files&#x2F;folders from the containers filesystem to the host path</td>
<td align="center">从容器中搏贝指定文件或者目录到宿主机中</td>
</tr>
<tr>
<td align="center">create</td>
<td align="center">Create a new container</td>
<td align="center">创建一个新的容器，同 run，但不启动容器</td>
</tr>
<tr>
<td align="center">diff</td>
<td align="center">Inspect changes on a container’s fiesystem</td>
<td align="center">查看 docker 容器变化</td>
</tr>
<tr>
<td align="center">events</td>
<td align="center">Get real time events from the server</td>
<td align="center">从 docker 服务获取容器实时事件</td>
</tr>
<tr>
<td align="center">exec</td>
<td align="center">Run a command in an existing container</td>
<td align="center">在已存在的容器上运行命令</td>
</tr>
<tr>
<td align="center">export</td>
<td align="center">Stream the contents of a container as a tar archive</td>
<td align="center">导出容器的内容作为一个 tar 归档文件[对应import]</td>
</tr>
<tr>
<td align="center">history</td>
<td align="center">Show the history of an image</td>
<td align="center">展示一个镜像形成历史</td>
</tr>
<tr>
<td align="center">images</td>
<td align="center">List images</td>
<td align="center">列出系统当前镜像</td>
</tr>
<tr>
<td align="center">import</td>
<td align="center">Create a new filesystem image from the contents of a tarball</td>
<td align="center">从tar包中的内容创建一个新的文件系统映像[对应export]</td>
</tr>
<tr>
<td align="center">info</td>
<td align="center">Display system-wide information</td>
<td align="center">显示系统相关信息</td>
</tr>
<tr>
<td align="center">inspect</td>
<td align="center">Return low-Tevel information on a container</td>
<td align="center">查看容器详细信息</td>
</tr>
<tr>
<td align="center">kill</td>
<td align="center">Kill a running container</td>
<td align="center">kill 指定 docker 容器</td>
</tr>
<tr>
<td align="center">load</td>
<td align="center">Load an image from a tar archive</td>
<td align="center">从一个 tar 包中加载一个像[对应 save]</td>
</tr>
<tr>
<td align="center">login</td>
<td align="center">Register or Login to the docker registry server</td>
<td align="center">注册或者陆一个 docker 源服务器</td>
</tr>
<tr>
<td align="center">logout</td>
<td align="center">Log out from a Docker registry server</td>
<td align="center">从当前 Docker registry 退出</td>
</tr>
<tr>
<td align="center">logs</td>
<td align="center">Fetch the logs of a container</td>
<td align="center">输出当前容器日志信息</td>
</tr>
<tr>
<td align="center">port</td>
<td align="center">Lookup the public-facing port which is NAT-ed to PRIVATE_PORT</td>
<td align="center">查看映射端口对应的容器内部源端口</td>
</tr>
<tr>
<td align="center">pause</td>
<td align="center">Pause all processes within a container</td>
<td align="center">暂停容器</td>
</tr>
<tr>
<td align="center">ps</td>
<td align="center">List containers</td>
<td align="center">列出容器列表</td>
</tr>
<tr>
<td align="center">pull</td>
<td align="center">Pull an image or a repository from the docker registry server</td>
<td align="center">从docker镜像源服务器拉取指定镜像或者库镜像</td>
</tr>
<tr>
<td align="center">push</td>
<td align="center">Push an image or a repository to the docker registry server</td>
<td align="center">推送指定镜像或者库镜像至docker源服务器</td>
</tr>
<tr>
<td align="center">restart</td>
<td align="center">Restart a running container</td>
<td align="center">重启运行的容器</td>
</tr>
<tr>
<td align="center">rm</td>
<td align="center">Remove one or more containers</td>
<td align="center">移除一个或者多个容器</td>
</tr>
<tr>
<td align="center">rmi</td>
<td align="center">Remove one or more images</td>
<td align="center">移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</td>
</tr>
<tr>
<td align="center">run</td>
<td align="center">Run a command in a new container</td>
<td align="center">创建一个新的容器并运行一个命令</td>
</tr>
<tr>
<td align="center">save</td>
<td align="center">Save an image to a tar archive</td>
<td align="center">保存一个镜像为一个 tar 包[对应 load]</td>
</tr>
<tr>
<td align="center">search</td>
<td align="center">Search for an image on the Docker Hub</td>
<td align="center">在 docker hub 中搜索镜像</td>
</tr>
<tr>
<td align="center">start</td>
<td align="center">Start a stopped containers</td>
<td align="center">启动容器</td>
</tr>
<tr>
<td align="center">stop</td>
<td align="center">Stop a running containers</td>
<td align="center">停止容器</td>
</tr>
<tr>
<td align="center">tag</td>
<td align="center">Tag an image into a repository</td>
<td align="center">给源中镜像打标签</td>
</tr>
<tr>
<td align="center">top</td>
<td align="center">Lookup the running processes of a container</td>
<td align="center">查看容器中运行的进程信息</td>
</tr>
<tr>
<td align="center">unpause</td>
<td align="center">Unpause a paused container</td>
<td align="center">取消暂停容器</td>
</tr>
<tr>
<td align="center">version</td>
<td align="center">Show the docker version information</td>
<td align="center">查看 docker 版本号</td>
</tr>
<tr>
<td align="center">wait</td>
<td align="center">Block until a container stops，then print its exit code</td>
<td align="center">截取容器止时的退出状态值</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象</title>
    <url>/2023/07/27/Java3/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><span id="more"></span>

<h1 id="Java-对象和类"><a href="#Java-对象和类" class="headerlink" title="Java 对象和类"></a>Java 对象和类</h1><ul>
<li><p><strong>类和对象的关系</strong><br><strong>类</strong>:类是对现实生活中一类具有共同属性和行为的事物的抽象<br><strong>对象</strong>:是能够看得到摸的着的真实存在的实体</p>
</li>
<li><p><strong>类的定义</strong><br><strong>类的重要性</strong>:是Java程序的基本组成单位<br><strong>类是什么</strong>:是对现实生活中一类具有共同属性和行为的事物的抽象，确定对象将会拥有的属性和行为</p>
<p><strong>类的特点</strong>：类是对象的数据类型，是具有相同属性和行为的事物的抽象</p>
<p><strong>类的组成</strong>:属性和行为<br><strong>属性</strong>:在类中通过成员变量来体现(类中方法外的变量)<br><strong>行为</strong>:在类中通过成员方法来体现(和前面的方法相比去掉static关键字即可)</p>
</li>
<li><p><strong>对象的定义</strong></p>
<p>看看周围真实的世界，会发现身边有很多对象，车，手机，人等等。所有这些对象都有自己的属性和行为。</p>
</li>
</ul>
<p>​       拿一个手机来举例，它的属性有：品牌、价格，行为有：打电话、发短信。</p>
<p>​       软件对象也有属性和行为。行为通过方法体现。</p>
<p>​       在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。</p>
<h2 id="Java-中的类"><a href="#Java-中的类" class="headerlink" title="Java 中的类"></a>Java 中的类</h2><p>类可以看成是创建 Java 对象的模板。</p>
<p>pubIic class Phone {</p>
<p>​		&#x2F;&#x2F;成员变量</p>
<p>​		String brand;</p>
<p>​		int price;</p>
<p>​		&#x2F;&#x2F;成员方法</p>
<p>​		public void call(){</p>
<p>​			System.out.printIn(“打电话”);}<br>​		public void sendMessage(){</p>
<p>​			System.out,pnintIn(“发短信”);}</p>
<p>}</p>
<p><strong>成员变量和局部变量的区别</strong></p>
<table>
<thead>
<tr>
<th align="center">区别</th>
<th align="center">成员变量</th>
<th align="center">局部变量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类中位置不同</td>
<td align="center">类中方法外</td>
<td align="center">方法内或者方法声明上</td>
</tr>
<tr>
<td align="center">内存中位置不同</td>
<td align="center">堆内存</td>
<td align="center">栈内存</td>
</tr>
<tr>
<td align="center">生命周期不同</td>
<td align="center">随着对象的存在而存在，随看对象的消失而消失</td>
<td align="center">随着方法的调用而存在，随着方法的调用完毕而消失</td>
</tr>
<tr>
<td align="center">初始化值不同</td>
<td align="center">有默认的初始化值</td>
<td align="center">没有默认的初始化值，必须先定义，赋值，才能使用</td>
</tr>
</tbody></table>
<ul>
<li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li>
<li><strong>成员变量</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li>
<li><strong>类变量</strong>：类变量也声明在类中，方法体之外，但必须声明为 static 类型。</li>
</ul>
<hr>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>格式:类名对象名 &#x3D; new 类名0;<br>范例: Phone p &#x3D; new Phone0;</p>
<h2 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h2><ol>
<li><strong>使用成员变量</strong><br>格式:对象名.变量名<br>范例:p.brand</li>
<li><strong>使用成员方法</strong><br>格式:对象名.方法名()<br>范例: p.call()</li>
</ol>
<hr>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h2 id="一、private关键字"><a href="#一、private关键字" class="headerlink" title="一、private关键字"></a>一、private关键字</h2><ul>
<li>是一个权限修饰符</li>
<li>可以修饰成员 (成员变量和成员方法)</li>
<li>作用是保护成员不被别的类使用，被private修饰的成员只在本类中才能访问</li>
</ul>
<p>针对<code>private</code>修饰的成员变量，如果需要被其他类使用，提供相应的操作</p>
<ul>
<li>提供“<code>get变量名()</code>”方法，用于获取成员变量的值，方法用<code>public</code>修饰</li>
<li>提供“<code>set变量名(参数)</code>”方法，用于设置成员变量的值，方法用<code>public</code>修饰</li>
</ul>
<h2 id="二、this关键字"><a href="#二、this关键字" class="headerlink" title="二、this关键字"></a>二、this关键字</h2><ol>
<li><p>this修饰的变量用于指代成员变量<br>方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量<br>方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量</p>
</li>
<li><p>什么时候使用this呢? <strong>解决局部变量隐藏成员变量</strong></p>
</li>
<li><p>this 代表所在类的对象引用<br>记住:方法被哪个对象调用，this就代表哪个对象</p>
</li>
</ol>
<h2 id="三、封装"><a href="#三、封装" class="headerlink" title="三、封装"></a>三、封装</h2><ol>
<li><strong>封装概述</strong><br>是面向对象三大特征之一 (封装，继承，多态)<br>是面向对象编程语言对客观世界的横拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作</li>
<li><strong>封装规则</strong><br>将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对的冠信息的操作和访问成员变量private，提供对应的getXxx()&#x2F;setXxx()方法</li>
<li><strong>好处</strong><br>通过方法来控制成员变量的操作，提高了代码的安全性<br>把代码用方法进行封装，提高了代码的复用性</li>
</ol>
<h2 id="四、构造方法"><a href="#四、构造方法" class="headerlink" title="四、构造方法"></a>四、构造方法</h2><p>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p>
<p>下面是一个构造方法示例：</p>
<p>public class Student{   </p>
<p>​		 public Student(){ }     </p>
<p>​		 public Student(String name){         </p>
<p>​			&#x2F;&#x2F; 这个构造器仅有一个参数：name    } }</p>
<p><strong>注意事项</strong>：</p>
<ol>
<li><p>构造方法的创建</p>
<p>如果没有定义构造方法，系统将给出一个认的无参数构造方法<br>如果定义了构造方法，系统将不再提供默认的构造方法</p>
</li>
<li><p>构造方法的重载<br>如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数构造方法</p>
</li>
<li><p>推荐的使用方式<br>无论是否使用，都手工书写无参数构造方法</p>
</li>
</ol>
<h5 id="标准类制作"><a href="#标准类制作" class="headerlink" title="标准类制作"></a>标准类制作</h5><ol>
<li>成员变量<br>使用private修饰</li>
<li>构造方法<br>提供一个无参构造方法<br>提供一个带多个参数的构造方法</li>
<li>成员方法<br>提供每一个成员变量对应的setXxx()&#x2F;getXxx()<br>提供一个显示对象信息的show()</li>
<li>创建对象并为其成员变量值的两种方式<br>无参构造方法创建对象后使用setXxx()赋值<br>使用带参构造方法直接创建带有属性值的对象</li>
</ol>
<p>例子：</p>
<h5 id="Student-java程序"><a href="#Student-java程序" class="headerlink" title="Student.java程序"></a>Student.java程序</h5><p>public class Student{   </p>
<p>​		prative String name;&#x2F;&#x2F;成员变量</p>
<p>​		prative int age;</p>
<p>​		public Student() { }&#x2F;&#x2F;构造方法</p>
<p>​		public Student(String name,int age){ </p>
<p>​			this.name &#x3D; name;</p>
<p>​			this.age &#x3D; age;}</p>
<p>​		&#x2F;&#x2F;成员方法</p>
<p>​		public void setName(String name){</p>
<p>​			this.name &#x3D; name;}</p>
<p>​		public String getName(){</p>
<p>​			return name;}</p>
<p>​		public void setAge(int age){</p>
<p>​			this.age &#x3D; age;}</p>
<p>​		public String getAge(){</p>
<p>​			return age;}</p>
<p>​		public void show(){</p>
<p>​			System.out.println(name+”,”+age);}</p>
<p>} </p>
<h5 id="StudentDemo-java程序"><a href="#StudentDemo-java程序" class="headerlink" title="StudentDemo.java程序"></a>StudentDemo.java程序</h5><p>package com.XXX</p>
<p>public class StudentDemo{</p>
<p>​		public static void main(String[ ] args){</p>
<p>​			&#x2F;&#x2F;无参构造方法创建对象后使用setXxx()赋值</p>
<p>​			Student s1 &#x3D; new Student( );</p>
<p>​			s1.setName(“xuan”);</p>
<p>​			s1.setAge(18);</p>
<p>​			s1.show();</p>
<p>​			&#x2F;&#x2F;使用带参构造方法直接创建带有属性值的对象</p>
<p>​			Student s2 &#x3D; new Student(“name:”xuan”,age:18);</p>
<p>​			s2.show();</p>
<p>​		}		</p>
<p>}</p>
<p><strong>运行结果</strong>：</p>
<p>xuan,18</p>
<p>xuan,18</p>
<h1 id="Java-继承"><a href="#Java-继承" class="headerlink" title="Java 继承"></a>Java 继承</h1><hr>
<h2 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h2><p>继承是面向对象的三大特征之一，可以使得子类具有父类的属性和方法，还可以在子类中重新定义，追加属性和方法</p>
<ul>
<li>格式:public class 子类名extends父类名}</li>
<li>范例: public class Zi extends Fu<br>Fu:是类，也被称为基类、超类<br>Zi: 是子类，也被称为派生类</li>
</ul>
<p>继承中子类的特点：</p>
<p>子类可以有父类的内容，还可以有自己特有的内容</p>
<h2 id="继承的好处和弊端"><a href="#继承的好处和弊端" class="headerlink" title="继承的好处和弊端"></a>继承的好处和弊端</h2><p><strong>继承好处</strong><br>提高了代码的复用性(多个类相同的成员可以放到同一个类中)<br>提高了代码的维护性(如果方法的代码需要修改，修改一处即可)<br><strong>继承弊端</strong><br>继承让类与类之间产生了关系，类的合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性<br><strong>什么时候使用继承?</strong><br>继承体现的关系:is a<br>假设法:我有两个类A和B，如果他们满足A是B的一种，或者B是A的一种，就说明他们存在继承关系，这个时候就可以考虑使用继承来体现，否则就不滥用继承</p>
<h2 id="继承中变量的访问特点"><a href="#继承中变量的访问特点" class="headerlink" title="继承中变量的访问特点"></a>继承中变量的访问特点</h2><p>在子类方法中访问一个变量</p>
<ol>
<li>子类局部范围找</li>
<li>子类成员范围找</li>
<li>父类成员范围找</li>
<li>如果都没有就报错(不考虑父亲的父亲…)</li>
</ol>
<h2 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h2><p>需要注意的是 Java 不支持多继承，但支持多重继承。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/java-extends-2020-12-08.png" alt="img"></p>
<h2 id="继承关键字"><a href="#继承关键字" class="headerlink" title="继承关键字"></a>继承关键字</h2><p>继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承 Object（这个类在 <strong>java.lang</strong> 包中，所以不需要 <strong>import</strong>）祖先类。</p>
<h3 id="extends关键字"><a href="#extends关键字" class="headerlink" title="extends关键字"></a>extends关键字</h3><p>在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。</p>
<p>public class Animal {<br>    private String name;<br>    private int id;<br>    public Animal(String myName, int myid) {<br>        &#x2F;&#x2F;初始化属性值<br>    }<br>    public void eat() {  &#x2F;&#x2F;吃东西方法的具体实现  }<br>    public void sleep() { &#x2F;&#x2F;睡觉方法的具体实现  }<br>} </p>
<p>public class Penguin  extends  Animal{<br>}</p>
<h3 id="implements关键字"><a href="#implements关键字" class="headerlink" title="implements关键字"></a>implements关键字</h3><p>使用 implements 关键字可以变相的使java具有<code>多继承</code>的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。</p>
<p>public interface A {<br>    public void eat();<br>    public void sleep();<br>}</p>
<p>public interface B {<br>    public void show();<br>}</p>
<p>public class C implements A,B {<br>}</p>
<h3 id="super-与-this-关键字"><a href="#super-与-this-关键字" class="headerlink" title="super 与 this 关键字"></a>super 与 this 关键字</h3><p>super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。</p>
<p>this关键字：指向自己的引用。</p>
<p><strong>实例</strong></p>
<p>class Animal {<br>  void eat() {<br>    System.out.println(“animal : eat”);<br>  }<br>}</p>
<p>class Dog extends Animal {<br>  void eat() {<br>    System.out.println(“dog : eat”);<br>  }<br>  void eatTest() {<br>    this.eat();   &#x2F;&#x2F; this 调用自己的方法<br>    super.eat();  &#x2F;&#x2F; super 调用父类方法<br>  }<br>}</p>
<p>public class Test {<br>  public static void main(String[] args) {<br>    Animal a &#x3D; new Animal();<br>    a.eat();<br>    Dog d &#x3D; new Dog();<br>    d.eatTest();<br>  }<br>}</p>
<p>输出结果为：</p>
<p>animal : eat<br>dog : eat<br>animal : eat</p>
<h3 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h3><p>final 可以用来修饰变量（包括类属性、对象属性、局部变量和形参）、方法（包括类方法和对象方法）和类。</p>
<p><strong>final修饰的特点</strong></p>
<ul>
<li>修饰方法:表明该方法是最终方法，不能被重写</li>
<li>修饰变量:表明该变量是常量，不能再次被赋值</li>
<li>修饰类:表明该类是最终类，不能被继承</li>
</ul>
<p>声明类：</p>
<p>final class 类名 {&#x2F;&#x2F;类体}</p>
<p>声明方法：</p>
<p>修饰符(public&#x2F;private&#x2F;default&#x2F;protected) final 返回值类型 方法名(){&#x2F;&#x2F;方法体}</p>
<p><strong>注：</strong> final 定义的类，其中的属性、方法不是 final 的。</p>
<p><strong>final修饰局部变量</strong></p>
<p>变量是基本类型: final修饰指的是基本类型的数据值不能发生改变</p>
<p>变量是引用类型: final修饰指的是引用类型的地址值不能发生改变，但是地址里面的内容是可以发生改变的</p>
<h1 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h1><p>static 关键字是静态的意思，可以修饰成员方法，成员变量<br><strong>static 修饰的特点</strong></p>
<ul>
<li>被类的所有对象共享<br>这也是我们判断是否使用静态关键字的条件</li>
<li>推荐使用类名调用</li>
</ul>
<p><strong>static 访问特点</strong></p>
<p>静态成员方法只能访问静态成员和静态成员方法</p>
<h1 id="Java-包"><a href="#Java-包" class="headerlink" title="Java 包"></a>Java 包</h1><p>包主要用来对类和接口进行分类管理</p>
<p>包的定义格式</p>
<p>格式：package 包名；</p>
<p>范例：package com.first;</p>
<h2 id="import-语句-导包"><a href="#import-语句-导包" class="headerlink" title="import 语句(导包)"></a>import 语句(导包)</h2><p>在 Java 中，如果给出一个完整的限定名，包括包名、类名，那么 Java 编译器就可以很容易地定位到源代码或者类。import 语句就是用来提供一个合理的路径，使得编译器可以找到某个类。</p>
<p>例如，下面的命令行将会命令编译器载入 java_installation&#x2F;java&#x2F;io 路径下的所有类</p>
<p>import java.io.*;(import 包名)</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识</title>
    <url>/2023/07/26/Java2/</url>
    <content><![CDATA[<h1 id="Java-基础语法"><a href="#Java-基础语法" class="headerlink" title="Java 基础语法"></a>Java 基础语法</h1><span id="more"></span>

<p>一个 Java 程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。下面简要介绍下类、对象、方法和实例变量的概念。</p>
<ul>
<li><strong>对象</strong>：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li>
<li><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</li>
<li><strong>方法</strong>：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。</li>
<li><strong>实例变量</strong>：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</li>
</ul>
<hr>
<h2 id="第一个Java程序"><a href="#第一个Java程序" class="headerlink" title="第一个Java程序"></a>第一个Java程序</h2><p>下面看一个简单的 Java 程序，它将输出字符串 <em>Hello World</em></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>Java程序中最基本的组成单位是类<br>类的定义格式：public c1ass类名{}</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">public</span> <span class="string">class</span> <span class="string">HelloWorld</span> &#123;   </span><br><span class="line"><span class="string">//这里是main方法</span></span><br><span class="line"><span class="string">//main方法是程序的入口方法，代码的执行是从main方法开始的</span></span><br><span class="line">  	<span class="string">public</span> <span class="string">static</span> <span class="string">void</span> <span class="string">main(String</span>[] <span class="string">args)</span> &#123;      </span><br><span class="line">        <span class="string">System.out.println(&quot;Hello</span> <span class="string">World&quot;);</span> <span class="string">//</span> <span class="string">输出</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line">	&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如何保存、编译以及运行这个程序：</p>
<ul>
<li>打开代码编辑器，把上面的代码添加进去；</li>
<li>把文件名保存为：HelloWorld.java；</li>
<li>打开 cmd 命令窗口，进入目标文件所在的位置，假设是 C:\</li>
<li>在命令行窗口输入 <strong>javac HelloWorld.java</strong> 按下回车键编译代码。如果代码没有错误，cmd 命令提示符会进入下一行（假设环境变量都设置好了）。</li>
<li>再键输入 <strong>java HelloWorld</strong> 按下回车键就可以运行程序了</li>
</ul>
<p>你将会在窗口看到 Hello World</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ javac HelloWorld.java</span><br><span class="line">$ java HelloWorld </span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<p>如果遇到编码问题，我们可以使用 <strong>-encoding</strong> 选项设置 <strong>utf-8</strong> 来编译：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac -encoding UTF-8 HelloWorld.java </span><br><span class="line">java HelloWorld </span><br></pre></td></tr></table></figure>

<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>编写 Java 程序时，应注意以下几点：</p>
<ul>
<li><strong>大小写敏感</strong>：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</li>
<li><strong>类名</strong>：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 <strong>MyFirstJavaClass</strong> 。</li>
<li><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</li>
<li><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 <strong>.java</strong>。（如果文件名和类名不相同则会导致编译错误）。</li>
<li><strong>主方法入口</strong>：所有的 Java 程序由 <strong>public static void main(String[] args)</strong> 方法开始执行。</li>
</ul>
<h2 id="Java-标识符"><a href="#Java-标识符" class="headerlink" title="Java 标识符"></a>Java 标识符</h2><p>Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</p>
<p>关于 Java 标识符，有以下几点需要注意：</p>
<ul>
<li><p>所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始</p>
</li>
<li><p>首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</p>
</li>
<li><p>关键字不能用作标识符</p>
</li>
<li><p>标识符是大小写敏感的</p>
</li>
<li><p>合法标识符举例：age、$salary、_value、__1_value</p>
</li>
<li><p>非法标识符举例：123abc、-salary</p>
</li>
</ul>
<h2 id="常见命名约定"><a href="#常见命名约定" class="headerlink" title="常见命名约定"></a>常见命名约定</h2><p><strong>小驼峰命名法:方法、变量</strong><br>约定1:标识符是一个单词的时候，首字母小写<br>范例1:name<br>约定2:标识符由多个单词组成的时候，第一个单词首字母小写，其他单词首字母大写<br>范例2:firstName<br><strong>大驼峰命名法:类</strong><br>约定1:标识符是一个单词的时候，首字母大写<br>范例1:Student<br>约定2:标识符由多个单词组成的时候，每个单词的首字母大写<br>范例2:GoodStudent</p>
<h2 id="Java-变量"><a href="#Java-变量" class="headerlink" title="Java 变量"></a>Java 变量</h2><p>Java 中主要有如下几种类型的变量</p>
<ul>
<li>局部变量</li>
<li>类变量（静态变量）</li>
<li>成员变量（非静态变量）</li>
</ul>
<h2 id="Java-关键字"><a href="#Java-关键字" class="headerlink" title="Java 关键字"></a>Java 关键字</h2><p>下面列出了 Java 关键字。这些保留字不能用于常量、变量、和任何标识符的名称。</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">关键字</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">访问控制</td>
<td align="left">private</td>
<td align="left">私有的</td>
</tr>
<tr>
<td align="left">protected</td>
<td align="left">受保护的</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">public</td>
<td align="left">公共的</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">default</td>
<td align="left">默认</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">类、方法和变量修饰符</td>
<td align="left">abstract</td>
<td align="left">声明抽象</td>
</tr>
<tr>
<td align="left">class</td>
<td align="left">类</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">extends</td>
<td align="left">扩充、继承</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">final</td>
<td align="left">最终值、不可改变的</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">implements</td>
<td align="left">实现（接口）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">interface</td>
<td align="left">接口</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">native</td>
<td align="left">本地、原生方法（非 Java 实现）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">new</td>
<td align="left">创建</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">静态</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">strictfp</td>
<td align="left">严格浮点、精准浮点</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">synchronized</td>
<td align="left">线程、同步</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">transient</td>
<td align="left">短暂</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">volatile</td>
<td align="left">易失</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">程序控制语句</td>
<td align="left">break</td>
<td align="left">跳出循环</td>
</tr>
<tr>
<td align="left">case</td>
<td align="left">定义一个值以供 switch 选择</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">continue</td>
<td align="left">继续</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">do</td>
<td align="left">运行</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">else</td>
<td align="left">否则</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">for</td>
<td align="left">循环</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">if</td>
<td align="left">如果</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">instanceof</td>
<td align="left">实例</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">return</td>
<td align="left">返回</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">switch</td>
<td align="left">根据值选择执行</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">while</td>
<td align="left">循环</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">错误处理</td>
<td align="left">assert</td>
<td align="left">断言表达式是否为真</td>
</tr>
<tr>
<td align="left">catch</td>
<td align="left">捕捉异常</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">finally</td>
<td align="left">有没有异常都执行</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">throw</td>
<td align="left">抛出一个异常对象</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">throws</td>
<td align="left">声明一个异常可能被抛出</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">try</td>
<td align="left">捕获异常</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">包相关</td>
<td align="left">import</td>
<td align="left">引入</td>
</tr>
<tr>
<td align="left">package</td>
<td align="left">包</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">基本类型</td>
<td align="left">boolean</td>
<td align="left">布尔型</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">字节型</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">字符型</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">双精度浮点</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">单精度浮点</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">整型</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">长整型</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">短整型</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">变量引用</td>
<td align="left">super</td>
<td align="left">父类、超类</td>
</tr>
<tr>
<td align="left">this</td>
<td align="left">本类</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">void</td>
<td align="left">无返回值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">保留关键字</td>
<td align="left">goto</td>
<td align="left">是关键字，但不能使用</td>
</tr>
<tr>
<td align="left">const</td>
<td align="left">是关键字，但不能使用</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>注意：</strong>Java 的 null 不是关键字，类似于 true 和 false，它是一个字面常量，不允许作为标识符使用。</p>
<hr>
<h2 id="Java注释"><a href="#Java注释" class="headerlink" title="Java注释"></a>Java注释</h2><p>类似于 C&#x2F;C++、Java 也支持单行以及多行注释。注释中的字符将被 Java 编译器忽略。</p>
<hr>
<h2 id="Java-空行"><a href="#Java-空行" class="headerlink" title="Java 空行"></a>Java 空行</h2><p>空白行或者有注释的行，Java 编译器都会忽略掉。</p>
<h1 id="Java-数据类型"><a href="#Java-数据类型" class="headerlink" title="Java 数据类型"></a>Java 数据类型</h1><h2 id="Java-基本数据类型"><a href="#Java-基本数据类型" class="headerlink" title="Java 基本数据类型"></a>Java 基本数据类型</h2><p><strong>类型默认值</strong></p>
<p> Java 各个类型的默认值：</p>
<table>
<thead>
<tr>
<th align="center"><strong>数据类型</strong></th>
<th align="center"><strong>默认值</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">0L</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">0.0f</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">0.0d</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">‘u0000’</td>
</tr>
<tr>
<td align="center">String (or any object)</td>
<td align="center">null</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">false</td>
</tr>
</tbody></table>
<p><strong>Java各个数据类型的内存占用和取值范围</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>数据类型</strong></th>
<th align="center">内存占用</th>
<th align="center">取值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">1</td>
<td align="center">-128~127</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">2</td>
<td align="center">-32768~32767</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">4</td>
<td align="center">-2的31次方到2的31次方-1</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">8</td>
<td align="center">-2的63次方到2的63次方-1</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">4</td>
<td align="center">负数: -3.402823E+38到-1.401298E-45 <br/>正数: 1.401298E-45到3.402823E+38</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8</td>
<td align="center">负数:-1.797693E+308到-4.9000000E-324 <br/>正数:4.9000000E-324到1.797693E+308</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">2</td>
<td align="center">0-65535</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">1</td>
<td align="center">true,false</td>
</tr>
</tbody></table>
<p><strong>说明:E+38表示是乘以10的38次方，同样，E-45表示乘以10的负45次方</strong></p>
<ul>
<li><strong>空常量（空值null）不能直接输出</strong></li>
</ul>
<h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><ol>
<li>类（class）</li>
<li>接口（interface）</li>
<li>数组（[  ]）</li>
</ol>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><strong>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</strong></p>
<p>转换从低级到高级。</p>
<p>低  ————————————————————-&gt;  高</p>
<p>byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double </p>
<p>数据类型转换必须满足如下规则：</p>
<ul>
<li><ol>
<li>不能对boolean类型进行类型转换。</li>
</ol>
</li>
<li><ol start="2">
<li>不能把对象类型转换成不相关类的对象。</li>
</ol>
</li>
<li><ol start="3">
<li>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</li>
</ol>
</li>
<li><ol start="4">
<li>转换过程中可能导致溢出或损失精度，例如：</li>
</ol>
<p>int i &#x3D;128;<br>byte b &#x3D; (byte)i;</p>
<p>因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。</p>
</li>
<li><ol start="5">
<li><p>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：</p>
<p>(int)23.7 &#x3D;&#x3D; 23;<br>(int)-45.89f &#x3D;&#x3D; -45</p>
</li>
</ol>
</li>
</ul>
<h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。</p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ul>
<li><ol>
<li>条件是转换的数据类型必须是兼容的。</li>
</ol>
</li>
<li><ol start="2">
<li>格式：(type)value type是要强制类型转换后的数据类型 实例：</li>
</ol>
</li>
</ul>
<h3 id="隐含强制类型转换"><a href="#隐含强制类型转换" class="headerlink" title="隐含强制类型转换"></a>隐含强制类型转换</h3><ol>
<li>小数默认是 double 类型浮点型，在定义 float 类型时必须在数字后面跟上 F 或者 f</li>
<li>整数的默认类型是 int,在定义long类型时，为防止整数过大，后面要加L</li>
</ol>
<h1 id="Java-变量类型"><a href="#Java-变量类型" class="headerlink" title="Java 变量类型"></a>Java 变量类型</h1><p>在Java语言中，所有的变量在使用前必须声明。声明变量的基本格式如下：</p>
<p>type identifier [ &#x3D; value];</p>
<p><strong>格式说明：</strong></p>
<ul>
<li>type – 数据类型。</li>
<li>identifier – 是变量名，可以使用逗号 <strong>,</strong> 隔开来声明多个同类型变量。</li>
</ul>
<p>以下列出了一些变量的声明实例。注意有些包含了初始化过程。</p>
<p>int a, b, c;     &#x2F;&#x2F; 声明三个int型整数：a、 b、c </p>
<p>int d &#x3D; 3, e &#x3D; 4, f &#x3D; 5; &#x2F;&#x2F; 声明三个整数并赋予初值 </p>
<p>byte z &#x3D; 22;     &#x2F;&#x2F; 声明并初始化 z </p>
<p>String s &#x3D; “runoob”;  &#x2F;&#x2F; 声明并初始化字符串 s </p>
<p>double pi &#x3D; 3.14159; &#x2F;&#x2F; 声明了双精度浮点型变量 pi </p>
<p>char x &#x3D; ‘x’;    &#x2F;&#x2F; 声明变量 x 的值是字符 ‘x’。</p>
<p><strong>Java 语言支持的变量类型有：</strong></p>
<ul>
<li><strong>局部变量（Local Variables）：</strong>定义在方法、构造方法或语句块中的变量，作用域只限于当前方法、构造方法或语句块中。局部变量必须在使用前声明，并且不能被访问修饰符修饰。</li>
<li><strong>成员变量（Instance Variables）：</strong>定义在类中、方法之外的变量，作用域为整个类，可以被类中的任何方法、构造方法和语句块访问。成员变量可以被访问修饰符修饰。</li>
<li><strong>静态变量（Class Variables）：</strong>定义在类中、方法之外的变量，并且使用 <code>static</code> 关键字修饰，作用域为整个类，可以被类中的任何方法、构造方法和语句块访问，静态变量的值在程序运行期间只有一个副本。静态变量可以被访问修饰符修饰。</li>
<li><strong>参数变量（Parameters）：</strong>方法定义时声明的变量，作为调用该方法时传递给方法的值。参数变量的作用域只限于方法内部。</li>
</ul>
<p><strong>常量和静态变量的区别</strong></p>
<p>常量也是与类相关的，但它是用 final 关键字修饰的变量，一旦被赋值就不能再修改。与静态变量不同的是，常量在编译时就已经确定了它的值，而静态变量的值可以在运行时改变。另外，常量通常用于存储一些固定的值，如数学常数、配置信息等，而静态变量通常用于存储可变的数据，如计数器、全局状态等。</p>
<p>总之，静态变量是与类相关的变量，具有唯一性和共享性，可以用于存储整个程序都需要使用的数据，但需要注意初始化时机和与常量的区别。</p>
<h1 id="Java-运算符"><a href="#Java-运算符" class="headerlink" title="Java 运算符"></a>Java 运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>算术运算符用在数学表达式中，它们的作用和在数学中的作用一样。下表列出了所有的算术运算符。</p>
<p>表格中的实例假设整数变量A的值为10，变量B的值为20：</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">描述</th>
<th align="center">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">加法 - 相加运算符两侧的值</td>
<td align="center">A + B 等于 30</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">减法 - 左操作数减去右操作数</td>
<td align="center">A – B 等于 -10</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">乘法 - 相乘操作符两侧的值</td>
<td align="center">A * B等于200</td>
</tr>
<tr>
<td align="center">&#x2F;</td>
<td align="center">除法 - 左操作数除以右操作数</td>
<td align="center">B &#x2F; A等于2</td>
</tr>
<tr>
<td align="center">％</td>
<td align="center">取余 - 左操作数除以右操作数的余数</td>
<td align="center">B%A等于0</td>
</tr>
<tr>
<td align="center">++</td>
<td align="center">自增: 操作数的值增加1</td>
<td align="center">B++ 或 ++B 等于 21</td>
</tr>
<tr>
<td align="center">–</td>
<td align="center">自减: 操作数的值减少1</td>
<td align="center">B– 或 –B 等于 19</td>
</tr>
</tbody></table>
<h2 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h2><p><strong>1、自增（++）自减（–）运算符</strong>是一种特殊的算术运算符，在算术运算符中需要两个操作数来进行运算，而自增自减运算符是一个操作数。</p>
<p><strong>2、前缀自增自减法(++a,–a):</strong> 先进行自增或者自减运算，再进行表达式运算。</p>
<p><strong>3、后缀自增自减法(a++,a–):</strong> 先进行表达式运算，再进行自增或者自减运算 关系运算符</p>
<p>下表为Java支持的关系运算符</p>
<p>表格中的实例整数变量A的值为10，变量B的值为20：</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
<th align="center">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x3D;&#x3D;</td>
<td align="center">检查如果两个操作数的值是否相等，如果相等则条件为真。</td>
<td align="center">（A &#x3D;&#x3D; B）为false</td>
</tr>
<tr>
<td align="center">!&#x3D;</td>
<td align="center">检查如果两个操作数的值是否相等，如果值不相等则条件为真。</td>
<td align="center">(A !&#x3D; B) 为true</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">检查左操作数的值是否大于右操作数的值，如果是那么条件为真。</td>
<td align="center">（A&gt; B）为false</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">检查左操作数的值是否小于右操作数的值，如果是那么条件为真。</td>
<td align="center">（A &lt;B）为true</td>
</tr>
<tr>
<td align="center">&gt;&#x3D;</td>
<td align="center">检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。</td>
<td align="center">（A&gt; &#x3D; B）false</td>
</tr>
<tr>
<td align="center">&lt;&#x3D;</td>
<td align="center">检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。</td>
<td align="center">（A &lt;&#x3D; B）为true</td>
</tr>
</tbody></table>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。</p>
<p>位运算符作用在所有的位上，并且按位运算。假设a &#x3D; 60，b &#x3D; 13;它们的二进制格式表示将如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A = 0011 1100</span><br><span class="line">B = 0000 1101</span><br><span class="line">-----------------</span><br><span class="line">A&amp;B = 0000 1100</span><br><span class="line">A | B = 0011 1101</span><br><span class="line">A ^ B = 0011 0001</span><br><span class="line">~A= 1100 0011</span><br></pre></td></tr></table></figure>

<p>下表列出了位运算符的基本运算，假设整数变量 A 的值为 60 和变量 B 的值为 13：</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left">＆</td>
<td align="left">如果相对应位都是1，则结果为1，否则为0</td>
<td align="left">（A＆B），得到12，即0000 1100</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">如果相对应位都是 0，则结果为 0，否则为 1</td>
<td align="left">（A | B）得到61，即 0011 1101</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">如果相对应位值相同，则结果为0，否则为1</td>
<td align="left">（A ^ B）得到49，即 0011 0001</td>
</tr>
<tr>
<td align="left">〜</td>
<td align="left">按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</td>
<td align="left">（〜A）得到-61，即1100 0011</td>
</tr>
<tr>
<td align="left">&lt;&lt;</td>
<td align="left">按位左移运算符。左操作数按位左移右操作数指定的位数。</td>
<td align="left">A &lt;&lt; 2得到240，即 1111 0000</td>
</tr>
<tr>
<td align="left">&gt;&gt;</td>
<td align="left">按位右移运算符。左操作数按位右移右操作数指定的位数。</td>
<td align="left">A &gt;&gt; 2得到15即 1111</td>
</tr>
<tr>
<td align="left">&gt;&gt;&gt;</td>
<td align="left">按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td>
<td align="left">A&gt;&gt;&gt;2得到15即0000 1111</td>
</tr>
</tbody></table>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>下表列出了逻辑运算符的基本运算，假设布尔变量A为真，变量B为假</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;&amp;</td>
<td align="left">称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。</td>
<td align="left">（A &amp;&amp; B）为假。</td>
</tr>
<tr>
<td align="left">| |</td>
<td align="left">称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。</td>
<td align="left">（A | | B）为真。</td>
</tr>
<tr>
<td align="left">！</td>
<td align="left">称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。</td>
<td align="left">！（A &amp;&amp; B）为真。</td>
</tr>
</tbody></table>
<h2 id="短路逻辑运算符"><a href="#短路逻辑运算符" class="headerlink" title="短路逻辑运算符"></a>短路逻辑运算符</h2><p>当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>public class LuoJi{   </p>
<p>​			 public static void main(String[] args){       </p>
<p>​						 int a &#x3D; 5;&#x2F;&#x2F;定义一个变量；        </p>
<p>​						boolean b &#x3D; (a&lt;4)&amp;&amp;(a++&lt;10);        </p>
<p>​						System.out.println(“使用短路逻辑运算符的结果为”+b);       </p>
<p>​						System.out.println(“a的结果为”+a);    } }</p>
<p>运行结果为：</p>
<p>使用短路逻辑运算符的结果为false<br>a的结果为5</p>
<blockquote>
<p><strong>解析：</strong> 该程序使用到了短路逻辑运算符(&amp;&amp;)，首先判断 a&lt;4 的结果为 false，则 b 的结果必定是 false，所以不再执行第二个操作 a++&lt;10 的判断，所以 a 的值为 5。</p>
</blockquote>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>拓展的赋值运算符隐含了强制类型转化</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">描述</th>
<th align="center">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x3D;</td>
<td align="center">简单的赋值运算符，将右操作数的值赋给左侧操作数</td>
<td align="center">C &#x3D; A + B将把A + B得到的值赋给C</td>
</tr>
<tr>
<td align="center">+ &#x3D;</td>
<td align="center">加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数</td>
<td align="center">C + &#x3D; A等价于C &#x3D; C + A</td>
</tr>
<tr>
<td align="center">- &#x3D;</td>
<td align="center">减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数</td>
<td align="center">C - &#x3D; A等价于C &#x3D; C - A</td>
</tr>
<tr>
<td align="center">* &#x3D;</td>
<td align="center">乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数</td>
<td align="center">C * &#x3D; A等价于C &#x3D; C * A</td>
</tr>
<tr>
<td align="center">&#x2F; &#x3D;</td>
<td align="center">除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数</td>
<td align="center">C &#x2F; &#x3D; A，C 与 A 同类型时等价于 C &#x3D; C &#x2F; A</td>
</tr>
<tr>
<td align="center">（％）&#x3D;</td>
<td align="center">取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数</td>
<td align="center">C％&#x3D; A等价于C &#x3D; C％A</td>
</tr>
<tr>
<td align="center">&lt;&lt; &#x3D;</td>
<td align="center">左移位赋值运算符</td>
<td align="center">C &lt;&lt; &#x3D; 2等价于C &#x3D; C &lt;&lt; 2</td>
</tr>
<tr>
<td align="center">&gt;&gt; &#x3D;</td>
<td align="center">右移位赋值运算符</td>
<td align="center">C &gt;&gt; &#x3D; 2等价于C &#x3D; C &gt;&gt; 2</td>
</tr>
<tr>
<td align="center">＆&#x3D;</td>
<td align="center">按位与赋值运算符</td>
<td align="center">C＆&#x3D; 2等价于C &#x3D; C＆2</td>
</tr>
<tr>
<td align="center">^ &#x3D;</td>
<td align="center">按位异或赋值操作符</td>
<td align="center">C ^ &#x3D; 2等价于C &#x3D; C ^ 2</td>
</tr>
<tr>
<td align="center">| &#x3D;</td>
<td align="center">按位或赋值操作符</td>
<td align="center">C | &#x3D; 2等价于C &#x3D; C | 2</td>
</tr>
</tbody></table>
<h2 id="条件运算符（-）"><a href="#条件运算符（-）" class="headerlink" title="条件运算符（?:）"></a>条件运算符（?:）</h2><p>条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。</p>
<p>variable x &#x3D; (expression) ? value if true : value if false</p>
<h2 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h2><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</p>
<p>instanceof运算符使用格式如下：</p>
<p>( Object reference variable ) instanceof  (class&#x2F;interface type)</p>
<p>如果运算符左侧变量所指的对象，是操作符右侧类或接口(class&#x2F;interface)的一个对象，那么结果为真。</p>
<p>例：</p>
<p>String name &#x3D; “James”;<br>boolean result &#x3D; name instanceof String; &#x2F;&#x2F; 由于 name 是 String 类型，所以返回真</p>
<p>如果被比较的对象兼容于右侧类型，该运算符仍然返回 true。</p>
<h2 id="Java运算符优先级"><a href="#Java运算符优先级" class="headerlink" title="Java运算符优先级"></a>Java运算符优先级</h2><p>当多个运算符出现在一个表达式中，谁先谁后呢？这就涉及到运算符的优先级别的问题。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果差别甚大。</p>
<p>例如，（1+3）＋（3+2）*2，这个表达式如果按加号最优先计算，答案就是 18，如果按照乘号最优先，答案则是 14。</p>
<p>再如，x &#x3D; 7 + 3 * 2;这里x得到13，而不是20，因为乘法运算符比加法运算符有较高的优先级，所以先计算3 * 2得到6，然后再加7。</p>
<p>下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部。</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">操作符</th>
<th align="left">关联性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">后缀</td>
<td align="left">() [] . (点操作符)</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">一元</td>
<td align="left">expr++ expr–</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">一元</td>
<td align="left">++expr –expr + - ～ ！</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">乘性</td>
<td align="left">* &#x2F;％</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">加性</td>
<td align="left">+ -</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">移位</td>
<td align="left">&gt;&gt; &gt;&gt;&gt;  &lt;&lt;</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">关系</td>
<td align="left">&gt; &gt;&#x3D; &lt; &lt;&#x3D;</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">相等</td>
<td align="left">&#x3D;&#x3D; !&#x3D;</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">按位与</td>
<td align="left">＆</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">按位异或</td>
<td align="left">^</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">按位或</td>
<td align="left">|</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">逻辑与</td>
<td align="left">&amp;&amp;</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">逻辑或</td>
<td align="left">| |</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">条件</td>
<td align="left">？：</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">赋值</td>
<td align="left">&#x3D; + &#x3D; - &#x3D; * &#x3D; &#x2F; &#x3D;％&#x3D; &gt;&gt; &#x3D; &lt;&lt; &#x3D;＆&#x3D; ^ &#x3D; | &#x3D;</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">逗号</td>
<td align="left">，</td>
<td align="left">左到右</td>
</tr>
</tbody></table>
<h1 id="Java-循环结构-for-while-及-do…while"><a href="#Java-循环结构-for-while-及-do…while" class="headerlink" title="Java 循环结构 - for, while 及 do…while"></a>Java 循环结构 - for, while 及 do…while</h1><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><p>while是最基本的循环，它的结构为：</p>
<p>while( 布尔表达式 ) {  &#x2F;&#x2F;循环内容 }</p>
<p>只要布尔表达式为 true，循环就会一直执行下去。</p>
<h2 id="do…while-循环"><a href="#do…while-循环" class="headerlink" title="do…while 循环"></a>do…while 循环</h2><p>对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。</p>
<p>do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。</p>
<p>do {<br>       &#x2F;&#x2F;代码语句<br>}while(布尔表达式);</p>
<p><strong>注意：</strong>布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。</p>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>虽然所有循环结构都可以用 while 或者 do…while表示，但 Java 提供了另一种语句 —— for 循环，使一些循环结构变得更加简单。</p>
<p>for循环执行的次数是在执行前就确定的。语法格式如下：</p>
<p>for(初始化; 布尔表达式; 更新) {    &#x2F;&#x2F;代码语句 }</p>
<p>关于 for 循环有以下几点说明：</p>
<ul>
<li>最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。</li>
<li>然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。</li>
<li>执行一次循环后，更新循环控制变量。</li>
<li>再次检测布尔表达式。循环执行上面的过程。</li>
</ul>
<h2 id="break-关键字"><a href="#break-关键字" class="headerlink" title="break 关键字"></a>break 关键字</h2><p>break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。</p>
<p>break 跳出最里层的循环，并且继续执行该循环下面的语句。</p>
<h2 id="continue-关键字"><a href="#continue-关键字" class="headerlink" title="continue 关键字"></a>continue 关键字</h2><p>continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。</p>
<p>在 for 循环中，continue 语句使程序立即跳转到更新语句。</p>
<p>在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。</p>
<h1 id="Java-条件语句-if…else"><a href="#Java-条件语句-if…else" class="headerlink" title="Java 条件语句 - if…else"></a>Java 条件语句 - if…else</h1><p>Java 中的条件语句允许程序根据条件的不同执行不同的代码块。</p>
<p>一个 if 语句包含一个布尔表达式和一条或多条语句。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>if 语句的语法如下：</p>
<p>if(布尔表达式) {   &#x2F;&#x2F;如果布尔表达式为true将执行的语句 }</p>
<p>如果布尔表达式的值为 true，则执行 if 语句中的代码块，否则执行 else 语句块后面的代码。</p>
<h2 id="if…else语句"><a href="#if…else语句" class="headerlink" title="if…else语句"></a>if…else语句</h2><p>if 语句后面可以跟 else 语句，当 if 语句的布尔表达式值为 false 时，else 语句块会被执行。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>if…else 的用法如下：</p>
<p>if(布尔表达式){   &#x2F;&#x2F;如果布尔表达式的值为true }</p>
<p>else{   &#x2F;&#x2F;如果布尔表达式的值为false }</p>
<hr>
<h2 id="if…else-语句"><a href="#if…else-语句" class="headerlink" title="if…else 语句"></a>if…else 语句</h2><p>if 语句后面可以跟 else if…else 语句，这种语句可以检测到多种可能的情况。</p>
<p>使用 if，else if，else 语句的时候，需要注意下面几点：</p>
<ul>
<li>if 语句至多有 1 个 else 语句，else 语句在所有的 else if 语句之后。</li>
<li>if 语句可以有若干个 else if 语句，它们必须在 else 语句之前。</li>
<li>一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将跳过执行。</li>
</ul>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p>if…else 语法格式如下:</p>
<p>if(布尔表达式 1){   &#x2F;&#x2F;如果布尔表达式 1的值为true执行代码 }</p>
<p>else if(布尔表达式 2){   &#x2F;&#x2F;如果布尔表达式 2的值为true执行代码 }</p>
<p>else if(布尔表达式 3){   &#x2F;&#x2F;如果布尔表达式 3的值为true执行代码 }</p>
<p>else {   &#x2F;&#x2F;如果以上布尔表达式都不为true执行代码 }</p>
<hr>
<h2 id="嵌套的-if…else-语句"><a href="#嵌套的-if…else-语句" class="headerlink" title="嵌套的 if…else 语句"></a>嵌套的 if…else 语句</h2><p>使用嵌套的 if…else 语句是合法的。也就是说你可以在另一个 if 或者 else if 语句中使用 if 或者 else if 语句。</p>
<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><p>嵌套的 if…else 语法格式如下：</p>
<p>if(布尔表达式 1){   &#x2F;&#x2F;&#x2F;&#x2F;如果布尔表达式 1的值为true执行代码 </p>
<p>​     if(布尔表达式 2){      &#x2F;&#x2F;&#x2F;&#x2F;如果布尔表达式 2的值为true执行代码 } }</p>
<h1 id="Java-switch-case-语句"><a href="#Java-switch-case-语句" class="headerlink" title="Java switch case 语句"></a>Java switch case 语句</h1><p>switch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</p>
<h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><p>switch case 语句语法格式如下：</p>
<p>switch(expression){    case value :       &#x2F;&#x2F;语句       break; &#x2F;&#x2F;可选    case value :       &#x2F;&#x2F;语句       break; &#x2F;&#x2F;可选    &#x2F;&#x2F;你可以有任意数量的case语句    default : &#x2F;&#x2F;可选       &#x2F;&#x2F;语句 }</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2018/09/java-switch-case-flow-diagram.jpeg" alt="img"></p>
<p>switch case 语句有如下规则：</p>
<ul>
<li>switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。</li>
<li>switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。</li>
<li>case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。</li>
<li>当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。</li>
<li>当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。</li>
<li>switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。</li>
</ul>
<p><strong>switch case 执行时，一定会先进行匹配，匹配成功返回当前 case 的值，再根据是否有 break，判断是否继续输出，或是跳出判断。</strong></p>
<h1 id="Java-数组"><a href="#Java-数组" class="headerlink" title="Java 数组"></a>Java 数组</h1><p>数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。</p>
<p>Java 语言中提供的数组是用来存储固定大小的同类型元素。</p>
<p>你可以声明一个数组变量，如 numbers[100] 来代替直接声明 100 个独立变量 number0，number1，….，number99。</p>
<h2 id="声明数组变量"><a href="#声明数组变量" class="headerlink" title="声明数组变量"></a>声明数组变量</h2><p>首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：</p>
<p>dataType[] arrayRefVar;   &#x2F;&#x2F; 首选的方法  或  dataType arrayRefVar[];  &#x2F;&#x2F; 效果相同，但不是首选方法</p>
<p><strong>注意:</strong> 建议使用 <strong>dataType[] arrayRefVar</strong> 的声明风格声明数组变量。 dataType arrayRefVar[] 风格是来自 C&#x2F;C++ 语言 ，在Java中采用是为了让 C&#x2F;C++ 程序员能够快速理解java语言。</p>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>下面是这两种语法的代码示例：</p>
<p>double[] myList;         &#x2F;&#x2F; 首选的方法  </p>
<p>double myList[];         &#x2F;&#x2F;  效果相同，但不是首选方法</p>
<hr>
<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>Java语言使用new操作符来创建数组，语法如下：</p>
<p>arrayRefVar &#x3D; new dataType[arraySize];</p>
<p>上面的语法语句做了两件事：</p>
<ul>
<li>一、使用 dataType[arraySize] 创建了一个数组。</li>
<li>二、把新创建的数组的引用赋值给变量 arrayRefVar。</li>
</ul>
<p>数组变量的声明，和创建数组可以用一条语句完成，如下所示：</p>
<p>dataType[] arrayRefVar &#x3D; new dataType[arraySize];</p>
<p>另外，你还可以使用如下的方式创建数组。</p>
<p>dataType[] arrayRefVar &#x3D; {value0, value1, …, valuek};</p>
<p>数组的元素是通过索引访问的。数组索引从 0 开始，所以索引值从 0 到 arrayRefVar.length-1。</p>
<hr>
<h2 id="数组作为函数的参数"><a href="#数组作为函数的参数" class="headerlink" title="数组作为函数的参数"></a>数组作为函数的参数</h2><p>数组可以作为参数传递给方法。</p>
<p>例如，下面的例子就是一个打印 int 数组中元素的方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void printArray(int[] array) &#123;</span><br><span class="line">     for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    		 System.out.print(array[i] + &quot; &quot;);  &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>下面例子调用 printArray 方法打印出 3，1，2，6，4 和 2：</p>
<p>printArray(new int[]{3, 1, 2, 6, 4, 2});</p>
<hr>
<h2 id="数组作为函数的返回值"><a href="#数组作为函数的返回值" class="headerlink" title="数组作为函数的返回值"></a>数组作为函数的返回值</h2><p>public static int[] reverse(int[] list) {  </p>
<p>​		int[] result &#x3D; new int[list.length];  </p>
<p>​	   for (int i &#x3D; 0, j &#x3D; result.length - 1; i &lt; list.length; i++, j–) { </p>
<p>​			  result[j] &#x3D; list[i];  } </p>
<p>​	   return result; }</p>
<p>以上实例中 result 数组作为函数的返回值。</p>
<hr>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组，例如：</p>
<p>String[][] str &#x3D; new String[3][4];</p>
<h3 id="多维数组的动态初始化（以二维数组为例）"><a href="#多维数组的动态初始化（以二维数组为例）" class="headerlink" title="多维数组的动态初始化（以二维数组为例）"></a>多维数组的动态初始化（以二维数组为例）</h3><p><strong>1.直接为每一维分配空间，格式如下：</strong></p>
<p>type[][] typeName &#x3D; new type[typeLength1] [typeLength2];</p>
<p>type 可以为基本数据类型和复合数据类型，typeLength1 和 typeLength2 必须为正整数，typeLength1 为行数，typeLength2 为列数。</p>
<p>例如：</p>
<p>int[][] a &#x3D; new int[2] [3];</p>
<p>解析：</p>
<p>二维数组 a 可以看成一个两行三列的数组。</p>
<p><strong>2.从最高维开始，分别为每一维分配空间，例如：</strong></p>
<p>String[][] s &#x3D; new String[2] []; </p>
<p>s[0] &#x3D; new String[2];</p>
<p>s[1] &#x3D; new String[3];</p>
<p>s[0] [0] &#x3D; new String(“Good”);</p>
<p>s[0] [1] &#x3D; new String(“Luck”); </p>
<p>s[1] [0] &#x3D; new String(“to”); </p>
<p>s[1] [1] &#x3D; new String(“you”); </p>
<p>s[1] [2] &#x3D; new String(“!”);</p>
<p>解析：</p>
<p><strong>s[0]&#x3D;new String[2]</strong> 和 <strong>s[1]&#x3D;new String[3]</strong> 是为最高维分配引用空间，也就是为最高维限制其能保存数据的最长的长度，然后再为其每个数组元素单独分配空间 <strong>s0&#x3D;new String(“Good”)</strong> 等操作。</p>
<h3 id="多维数组的引用（以二维数组为例）"><a href="#多维数组的引用（以二维数组为例）" class="headerlink" title="多维数组的引用（以二维数组为例）"></a>多维数组的引用（以二维数组为例）</h3><p>对二维数组中的每个元素，引用方式为 **arrayName[index1] [index2]**，例如：</p>
<p>num[1] [0];</p>
<hr>
<h4 id="数组操作的两个常见小问题"><a href="#数组操作的两个常见小问题" class="headerlink" title="数组操作的两个常见小问题"></a>数组操作的两个常见小问题</h4><p><strong>索引越界</strong>:访问了数组中不存在的索引对应的元素，造成索引樾越界问题<br><strong>空指针异常</strong>:访问的数组已经不再指向堆内存的数据，造成空指针异常<br><strong>null</strong>:空值，引用数据类型的默认值，表示不指向任何有效对象</p>
<h2 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h2><p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p>
<p>具有以下功能：</p>
<ul>
<li>给数组赋值：通过 fill 方法。</li>
<li>对数组排序：通过 sort 方法,按升序。</li>
<li>比较数组：通过 equals 方法比较数组中元素值是否相等。</li>
<li>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。</li>
</ul>
<p>具体说明请查看下表：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法和说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>public static int binarySearch(Object[] a, Object key)</strong> 用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(<em>插入点</em>) - 1)。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>public static boolean equals(long[] a, long[] a2)</strong> 如果两个指定的 long 型数组彼此<em>相等</em>，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>public static void fill(int[] a, int val)</strong> 将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>public static void sort(Object[] a)</strong> 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td>
</tr>
</tbody></table>
<h1 id="Java-方法"><a href="#Java-方法" class="headerlink" title="Java 方法"></a>Java 方法</h1><p>在前面几个章节中我们经常使用到 **System.out.println()**，那么它是什么呢？</p>
<ul>
<li>println() 是一个方法。</li>
<li>System 是系统类。</li>
<li>out 是标准输出对象。</li>
</ul>
<p>这句话的用法是调用系统类 System 中的标准输出对象 out 中的方法 println()。</p>
<h2 id="那么什么是方法呢？"><a href="#那么什么是方法呢？" class="headerlink" title="那么什么是方法呢？"></a>那么什么是方法呢？</h2><p>Java方法是语句的集合，它们在一起执行一个功能。</p>
<ul>
<li>方法是解决一类问题的步骤的有序组合</li>
<li>方法包含于类或对象中</li>
<li>方法在程序中被创建，在其他地方被引用</li>
</ul>
<h2 id="方法的优点"><a href="#方法的优点" class="headerlink" title="方法的优点"></a>方法的优点</h2><ul>
<li><ol>
<li>使程序变得更简短而清晰。</li>
</ol>
</li>
<li><ol start="2">
<li>有利于程序维护。</li>
</ol>
</li>
<li><ol start="3">
<li>可以提高程序开发的效率。</li>
</ol>
</li>
<li><ol start="4">
<li>提高了代码的重用性。</li>
</ol>
</li>
</ul>
<h2 id="方法的命名规则"><a href="#方法的命名规则" class="headerlink" title="方法的命名规则"></a>方法的命名规则</h2><ul>
<li>1.方法的名字的第一个单词应以小写字母作为开头，后面的单词则用大写字母开头写，不使用连接符。例如：<strong>addPerson</strong>。</li>
<li>2.下划线可能出现在 JUnit 测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：**test<MethodUnderTest>_<state>**，例如 <strong>testPop_emptyStack</strong>。</li>
</ul>
<hr>
<h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><p>一般情况下，定义一个方法包含以下语法：</p>
<p>修饰符 返回值类型 方法名(参数类型 参数名){    …    方法体    …    return 返回值; }</p>
<p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p>
<ul>
<li><strong>修饰符：</strong>修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li>
<li><strong>返回值类型 ：</strong>方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字<strong>void</strong>。</li>
<li><strong>方法名：</strong>是方法的实际名称。方法名和参数表共同构成方法签名。</li>
<li><strong>参数类型：</strong>参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li>
<li><strong>方法体：</strong>方法体包含具体的语句，定义该方法的功能。</li>
</ul>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/D53C92B3-9643-4871-8A72-33D491299653.jpg" alt="img"></p>
<p>如：</p>
<p>public static int age(int birthday){…}</p>
<p>参数可以有多个：</p>
<p>static float interest(float principal, int year){…}</p>
<p><strong>注意：</strong> 在一些其它语言中方法指过程和函数。一个返回非void类型返回值的方法称为函数；一个返回void类型返回值的方法叫做过程。</p>
<hr>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>Java 支持两种调用方法的方式，根据方法是否返回值来选择。</p>
<p>当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候交还控制权给程序。</p>
<p>当方法返回一个值的时候，方法调用通常被当做一个值。例如：</p>
<p>int larger &#x3D; max(30, 40);</p>
<p>如果方法返回值是void，方法调用一定是一条语句。例如，方法println返回void。下面的调用是个语句：</p>
<p>System.out.println(“欢迎访问菜鸟教程！”);</p>
<p>main 方法是被 JVM 调用的，除此之外，main 方法和其它方法没什么区别。</p>
<p>main 方法的头部是不变的，如例子所示，带修饰符 public 和 static,返回 void 类型值，方法名字是 main,此外带个一个 String[] 类型参数。String[] 表明参数是字符串数组。</p>
<hr>
<h2 id="void-关键字"><a href="#void-关键字" class="headerlink" title="void 关键字"></a>void 关键字</h2><p>一个void类型方法，它不返回值。</p>
<p>一个void方法的调用一定是一个语句。 就像任何以分号结束的语句一样</p>
<h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><p>上面使用的max方法仅仅适用于int型数据。但如果你想得到两个浮点类型数据的最大值呢？</p>
<p>解决方法是创建另一个有相同名字但参数不同的方法，如下面代码所示：</p>
<p>public static double max(double num1, double num2) {  </p>
<p>​		if (num1 &gt; num2)    </p>
<p>​				return num1; </p>
<p>​		 else<br>​				return num2;  }</p>
<p>如果你调用max方法时传递的是int型参数，则 int型参数的max方法就会被调用；</p>
<p>如果传递的是double型参数，则double类型的max方法体会被调用，这叫做方法重载；</p>
<p>就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。</p>
<p>Java编译器根据方法签名判断哪个方法应该被调用。</p>
<p>方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。</p>
<p>重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。</p>
<hr>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>变量的范围是程序中该变量可以被引用的部分。</p>
<p>方法内定义的变量被称为局部变量。</p>
<p>局部变量的作用范围从声明开始，直到包含它的块结束。</p>
<p>局部变量必须声明才可以使用。</p>
<p>方法的参数范围涵盖整个方法。参数实际上是一个局部变量。</p>
<p>for循环的初始化部分声明的变量，其作用范围在整个循环。</p>
<p>但循环体内声明的变量其适用范围是从它声明到循环体结束。</p>
<p>你可以在一个方法里，不同的非嵌套块中多次声明一个具有相同的名称局部变量，但你不能在嵌套块内两次声明局部变量。</p>
<h1 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h1><h2 id="Scanner使用的基本步骤"><a href="#Scanner使用的基本步骤" class="headerlink" title="Scanner使用的基本步骤"></a>Scanner使用的基本步骤</h2><p><strong>1.导包</strong><br><code>import java.util.Scanner;</code></p>
<p> 导包的动作必须出现在类定义的上边<br><strong>2.创建对象</strong><br><code>Scanner sc=new Scanner(System.in);</code><br>上面这个格式里面，只有sc是变量名，可以变，其他的都不允许变。<br><strong>3.接收数据</strong><br><code>int i=sc.nextInt();</code><br>上面这个格式里面，只有是变量名，可以变，其他的都不允许变。</p>
<h2 id="Java-Scanner-类"><a href="#Java-Scanner-类" class="headerlink" title="Java Scanner 类"></a>Java Scanner 类</h2><p>下面是创建 Scanner 对象的基本语法：</p>
<p>Scanner s &#x3D; new Scanner(System.in);</p>
<p>接下来我们演示一个最简单的数据输入，并通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据：</p>
<h3 id="使用-next-方法："><a href="#使用-next-方法：" class="headerlink" title="使用 next 方法："></a>使用 next 方法：</h3><p><strong>ScannerDemo.java 文件代码：</strong></p>
<p>import java.util.Scanner;   </p>
<p>public class ScannerDemo {  </p>
<p>​		  public static void main(String[] args) {        </p>
<p>​					Scanner scan &#x3D; new Scanner(System.in);        &#x2F;&#x2F; 从键盘接收数据         &#x2F;&#x2F; next方式接收字符串        </p>
<p>​					System.out.println(“next方式接收：”);        &#x2F;&#x2F; 判断是否还有输入      </p>
<p>​				    if (scan.hasNext()) {            </p>
<p>​						String str1 &#x3D; scan.next();            </p>
<p>​						System.out.println(“输入的数据为：” + str1);      </p>
<p>​					}        </p>
<p>​				    scan.close();   </p>
<p>​		 } </p>
<p>}</p>
<p>执行以上程序输出结果为：</p>
<p>$ javac ScannerDemo.java<br>$ java ScannerDemo<br>next方式接收：<br>runoob com<br>输入的数据为：runoob</p>
<p>可以看到 com 字符串并未输出，接下来我们看 nextLine。</p>
<h3 id="使用-nextLine-方法："><a href="#使用-nextLine-方法：" class="headerlink" title="使用 nextLine 方法："></a>使用 nextLine 方法：</h3><p><strong>ScannerDemo.java 文件代码：</strong></p>
<p>import java.util.Scanner;</p>
<p>public class ScannerDemo {<br>        public static void main(String[] args) {<br>                Scanner scan &#x3D; new Scanner(System.in);<br>                &#x2F;&#x2F; 从键盘接收数据</p>
<p>​				 &#x2F;&#x2F; nextLine方式接收字符串</p>
<p>​				System.out.println(“nextLine方式接收：”);<br>​				&#x2F;&#x2F; 判断是否还有输入<br>​				if (scan.hasNextLine()) {<br>                        String str2 &#x3D; scan.nextLine();<br>                        System.out.println(“输入的数据为：” + str2);<br>​				}<br>​				scan.close();</p>
<p>​	   }</p>
<p>}</p>
<p>执行以上程序输出结果为：</p>
<p>$ javac ScannerDemo.java<br>$ java ScannerDemo<br>nextLine方式接收：<br>runoob com<br>输入的数据为：runoob com</p>
<p>可以看到 com 字符串输出。</p>
<h3 id="next-与-nextLine-区别"><a href="#next-与-nextLine-区别" class="headerlink" title="next() 与 nextLine() 区别"></a>next() 与 nextLine() 区别</h3><p>next():</p>
<ul>
<li>1、一定要读取到有效字符后才可以结束输入。</li>
<li>2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。</li>
<li>3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</li>
<li>next() 不能得到带有空格的字符串。</li>
</ul>
<p>nextLine()：</p>
<ul>
<li>1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。</li>
<li>2、可以获得空白。</li>
</ul>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="String概述"><a href="#String概述" class="headerlink" title="String概述"></a>String概述</h2><p>String类在<code>java.lang</code> 包下，所以使用的时候不需要导包<br><code>String</code> 类代表<code>字符串</code>，Java程序中的所有字符串文字(例如“abc”)都被实现为此类的实例也就是说，<code>Java 程序中所有的双引号字符串，都是 String 类的对象</code><br><strong>字符串的特点</strong></p>
<ul>
<li>字符串不可变，它们的值在创建后不能被更改</li>
<li>虽然String的值是不可变的，但是它们可以被共享</li>
<li>字符串效果上相当于字符数组(char[])，但是底层原理是字节数组( byte[]])<br>JDK8及以前是字符数组，JDK9及以后是字节数组</li>
</ul>
<h2 id="String-构造方法"><a href="#String-构造方法" class="headerlink" title="String 构造方法"></a>String 构造方法</h2><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public String()</td>
<td align="center">创建一个空白字符串对象，不含有任何内容</td>
</tr>
<tr>
<td align="center">public String(char[] chs)</td>
<td align="center">根据字符数组的内容，来创建字符串对象</td>
</tr>
<tr>
<td align="center">public String(byte[] bys)</td>
<td align="center">根据字节数组的内容，来创建字符串对象</td>
</tr>
<tr>
<td align="center">String s &#x3D; “abc” ;</td>
<td align="center">直接赋值的方式创建字符串对象，内容就是abc</td>
</tr>
</tbody></table>
<p><code>推荐直接使用字符串赋值的方式得到字符串对象</code></p>
<h2 id="String对象的特点"><a href="#String对象的特点" class="headerlink" title="String对象的特点"></a>String对象的特点</h2><p>1)通过new 创建的字符串对象，每一次new都会申请一个内存空间，虽然内容相同，但是地址值不同<br>char[] chs &#x3D;{a’，”b，c’};<br>String s1 &#x3D; new String(chs);<br>String s2 &#x3D; new String(chs);<br>上面的代码中，JVM会首先创建一个字符数组，然后每一次new的时候都会有一个新的地址，只不过s1和s2参考的字符串内容是相同的</p>
<ol start="2">
<li>以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次JVM都只会建立一个String对象，并在字符串池中维护<br>String s3 &#x3D; “abc”;<br>String s4 &#x3D; “abc”;<br>在上面的代码中，针对第一行代码，JVM 会建立一个String对象放在字符串池中，并给s3参考；第二行则让s4直接参考字符串池中的String对象，也就是说它们本质上是同一个对象</li>
</ol>
<h2 id="String方法"><a href="#String方法" class="headerlink" title="String方法"></a>String方法</h2><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-charat.html">char charAt(int index)</a> 返回指定索引处的 char 值。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-compareto.html">int compareTo(Object o)</a> 把这个字符串和另一个对象比较。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-compareto.html">int compareTo(String anotherString)</a> 按字典顺序比较两个字符串。</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-comparetoignorecase.html">int compareToIgnoreCase(String str)</a> 按字典顺序比较两个字符串，不考虑大小写。</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-concat.html">String concat(String str)</a> 将指定字符串连接到此字符串的结尾。</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-contentequals.html">boolean contentEquals(StringBuffer sb)</a> 当且仅当字符串与指定的StringBuffer有相同顺序的字符时候返回真。</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-copyvalueof.html">static String copyValueOf(char[] data)</a> 返回指定数组中表示该字符序列的 String。</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-copyvalueof.html">static String copyValueOf(char[] data, int offset, int count)</a> 返回指定数组中表示该字符序列的 String。</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-endswith.html">boolean endsWith(String suffix)</a> 测试此字符串是否以指定的后缀结束。</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-equals.html">boolean equals(Object anObject)</a> 将此字符串与指定的对象比较。</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-equalsignorecase.html">boolean equalsIgnoreCase(String anotherString)</a> 将此 String 与另一个 String 比较，不考虑大小写。</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-getbytes.html">byte[] getBytes()</a>  使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-getbytes.html">byte[] getBytes(String charsetName)</a> 使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-getchars.html">void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</a> 将字符从此字符串复制到目标字符数组。</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-hashcode.html">int hashCode()</a> 返回此字符串的哈希码。</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-indexof.html">int indexOf(int ch)</a> 返回指定字符在此字符串中第一次出现处的索引。</td>
</tr>
<tr>
<td align="center">17</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-indexof.html">int indexOf(int ch, int fromIndex)</a> 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。</td>
</tr>
<tr>
<td align="center">18</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-indexof.html">int indexOf(String str)</a>  返回指定子字符串在此字符串中第一次出现处的索引。</td>
</tr>
<tr>
<td align="center">19</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-indexof.html">int indexOf(String str, int fromIndex)</a> 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</td>
</tr>
<tr>
<td align="center">20</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-intern.html">String intern()</a>  返回字符串对象的规范化表示形式。</td>
</tr>
<tr>
<td align="center">21</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-lastindexof.html">int lastIndexOf(int ch)</a>  返回指定字符在此字符串中最后一次出现处的索引。</td>
</tr>
<tr>
<td align="center">22</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-lastindexof.html">int lastIndexOf(int ch, int fromIndex)</a> 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。</td>
</tr>
<tr>
<td align="center">23</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-lastindexof.html">int lastIndexOf(String str)</a> 返回指定子字符串在此字符串中最右边出现处的索引。</td>
</tr>
<tr>
<td align="center">24</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-lastindexof.html">int lastIndexOf(String str, int fromIndex)</a>  返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</td>
</tr>
<tr>
<td align="center">25</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-length.html">int length()</a> 返回此字符串的长度。</td>
</tr>
<tr>
<td align="center">26</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-matches.html">boolean matches(String regex)</a> 告知此字符串是否匹配给定的正则表达式。</td>
</tr>
<tr>
<td align="center">27</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-regionmatches.html">boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)</a> 测试两个字符串区域是否相等。</td>
</tr>
<tr>
<td align="center">28</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-regionmatches.html">boolean regionMatches(int toffset, String other, int ooffset, int len)</a> 测试两个字符串区域是否相等。</td>
</tr>
<tr>
<td align="center">29</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-replace.html">String replace(char oldChar, char newChar)</a> 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</td>
</tr>
<tr>
<td align="center">30</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-replaceall.html">String replaceAll(String regex, String replacement)</a> 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</td>
</tr>
<tr>
<td align="center">31</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-replacefirst.html">String replaceFirst(String regex, String replacement)</a>  使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</td>
</tr>
<tr>
<td align="center">32</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-split.html">String[] split(String regex)</a> 根据给定正则表达式的匹配拆分此字符串。</td>
</tr>
<tr>
<td align="center">33</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-split.html">String[] split(String regex, int limit)</a> 根据匹配给定的正则表达式来拆分此字符串。</td>
</tr>
<tr>
<td align="center">34</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-startswith.html">boolean startsWith(String prefix)</a> 测试此字符串是否以指定的前缀开始。</td>
</tr>
<tr>
<td align="center">35</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-startswith.html">boolean startsWith(String prefix, int toffset)</a> 测试此字符串从指定索引开始的子字符串是否以指定前缀开始。</td>
</tr>
<tr>
<td align="center">36</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-subsequence.html">CharSequence subSequence(int beginIndex, int endIndex)</a>  返回一个新的字符序列，它是此序列的一个子序列。</td>
</tr>
<tr>
<td align="center">37</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-substring.html">String substring(int beginIndex)</a> 返回一个新的字符串，它是此字符串的一个子字符串。</td>
</tr>
<tr>
<td align="center">38</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-substring.html">String substring(int beginIndex, int endIndex)</a> 返回一个新字符串，它是此字符串的一个子字符串。</td>
</tr>
<tr>
<td align="center">39</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-tochararray.html">char[] toCharArray()</a> 将此字符串转换为一个新的字符数组。</td>
</tr>
<tr>
<td align="center">40</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-tolowercase.html">String toLowerCase()</a> 使用默认语言环境的规则将此 String 中的所有字符都转换为小写。</td>
</tr>
<tr>
<td align="center">41</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-tolowercase.html">String toLowerCase(Locale locale)</a>  使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。</td>
</tr>
<tr>
<td align="center">42</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-tostring.html">String toString()</a>  返回此对象本身（它已经是一个字符串！）。</td>
</tr>
<tr>
<td align="center">43</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-touppercase.html">String toUpperCase()</a> 使用默认语言环境的规则将此 String 中的所有字符都转换为大写。</td>
</tr>
<tr>
<td align="center">44</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-touppercase.html">String toUpperCase(Locale locale)</a> 使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。</td>
</tr>
<tr>
<td align="center">45</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-trim.html">String trim()</a> 返回字符串的副本，忽略前导空白和尾部空白。</td>
</tr>
<tr>
<td align="center">46</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-valueof.html">static String valueOf(primitive data type x)</a> 返回给定data type类型x参数的字符串表示形式。</td>
</tr>
<tr>
<td align="center">47</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-contains.html">contains(CharSequence chars)</a> 判断是否包含指定的字符系列。</td>
</tr>
<tr>
<td align="center">48</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-isempty.html">isEmpty()</a> 判断字符串是否为空。</td>
</tr>
</tbody></table>
<p><strong>字符串的比较</strong></p>
<p>使用 &#x3D; &#x3D; 做比较</p>
<ul>
<li>基本类型:比较的是数据值是否相同</li>
<li>引用类型:比较的是地址值是否相同</li>
</ul>
<p>字符串是对象，它比较内容是否相同，是通过一个方法来实现的，这个方法叫: equals()</p>
<ul>
<li>publicboolean equals(bject anobject): 将此字符串与指定对象进行比较。由于我们比较的是字符串对象，所以参数直接传递一个字符串</li>
</ul>
<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><h3 id="StringBuilder概述"><a href="#StringBuilder概述" class="headerlink" title="StringBuilder概述"></a>StringBuilder概述</h3><p>StringBuilder是一个可变的字符串类，我们可以把它看成是一个容器这里的可变指的是StringBuilder对象中的内容是可变的<br><strong>String 和 StringBuilder 的区别:</strong><br>String:内容是不可变的<br>StringBuilder:内容是可变的</p>
<h3 id="StringBuilder构造方法"><a href="#StringBuilder构造方法" class="headerlink" title="StringBuilder构造方法"></a>StringBuilder构造方法</h3><table>
<thead>
<tr>
<th align="center">构造器</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>StringBuilder()</code>（常用）</td>
<td align="center">构造一个字符串构建器，其中不包含任何字符，初始容量为16个字符。</td>
</tr>
<tr>
<td align="center"><code>StringBuilder(int capacity)</code></td>
<td align="center">构造一个字符串构建器，其中没有字符，并且具有 <code>capacity</code>参数指定的初始容量。</td>
</tr>
<tr>
<td align="center"><code>StringBuilder(CharSequence seq)</code></td>
<td align="center">构造一个字符串构建器，其中包含与指定的 <code>CharSequence</code>相同的字符。</td>
</tr>
<tr>
<td align="center"><code>StringBuilder(String str)</code>（常用）</td>
<td align="center">构造一个初始化为指定字符串内容的字符串构建器。</td>
</tr>
</tbody></table>
<h3 id="StringBuilder的添加和反转方法"><a href="#StringBuilder的添加和反转方法" class="headerlink" title="StringBuilder的添加和反转方法"></a>StringBuilder的添加和反转方法</h3><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>StringBuilder append(任意类型) </code></td>
<td align="center">添加数据，并返回对象本身</td>
</tr>
<tr>
<td align="center"><code>StringBuilder reverse()</code></td>
<td align="center">返回相反的字符序列</td>
</tr>
</tbody></table>
<h3 id="StringBuilder和String的相互转换"><a href="#StringBuilder和String的相互转换" class="headerlink" title="StringBuilder和String的相互转换"></a>StringBuilder和String的相互转换</h3><ol>
<li>StringBuilder转换为 String<br>public String toString():通过toString()就可以实现把StringBuilder转换为String</li>
<li>String 转换为StringBuilder<br>public StringBuilder(String s): 通过构造方法就可以实现把 String转换为StringBuilder</li>
</ol>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
